"mov long [esi+26], ebx"
"push 0x6e69622f \n push 0x7273752f \n mov ecx, esp"
push eax
"test eax, eax \n jz ready_to_proxy"
"mov bl, byte [esi]"
push dword 0x73656c62
"shr ax, 1"
"cmp BYTE al, 0x1 \n je 0x1"
jns dup2
push bx
"mov bx, [esi]"
"mov byte [edi], bl"
push word 0x697a
push 0xefffff7f
loopnz L1
call sprint
"mov edx, eatlen"
push byte 0xaa \n pop eax
 incpage:
"and eax, 0000000fh"
"mov al, 61"
push 0x622f7273
"push edi \n mov ebx, esp"
"mov eax, 37"
"test eax, eax \n jnz checkforfile"
"cmp al, 9 \n jge l1"
set_mark:
push 0x3d4c4c41
arr dd 20
"lea eax, [zero_reg+3]"
push 0x2f3a746f
not eax
push dword 0x2335738c onto the stack
"cmp eax, ebx \n je exit \n add al, 0x4"
"cmp eax, eax \n jne infinite"
call writestring
"cmp byte [esi], 0xD \n jl wrap_around"
"test eax, eax \n jz short loc_402C13"
"message db 'hello',13,0"
"mov ecx, esi"
"mov ax, word [ebp+22]"
move the byte at the address contained in eax
not byte [var2]
push byte 16
"xor dl, 0xBB \n jz Next_Cycle"
"mov al, 15"
set_mark:
loop decode
"mov cl, 0x2"
call prepare
jmp short search
"shl ecx, 4"
string: db 'tmp.txt'
"mov dl, 0x7f"
jmp short gotocall
push ecx
"mov al, 102"
"mov eax, 4"
"msg db , 0ah"
"shr edx, 24"
push 0x64687373
"push 0x64687373 \n mov eax, esp"
"mov esi, 0x222933f0"
"mov edi, al"
"loop l2 \n mov ebx, esp"
"xor ax, ax"
push byte 0xc \n pop eax
"xor esi, esi"
"xor [ecx], dh"
cld
"add edi, [edi]"
 prepare:
"cmp DWORD [eax], edx \n jne loop \n jmp eax"
"mov bl, 0xe"
jump to the large if not equal
"add byte_value, byte"
"sub dx, dx"
"xor ah, ah"
"mov ebp, esp"
"cmp al, 0xf2"
push word 0x5c11
push esi
"add edx, 32"
"mov eax, 29"
subtract 0table from the contents of the ecx register
"mov cl, 0102"
pop eax
call esp
"mov cl, byte [esi]"
push 0x6873732f
push word 0x1b6
jmp short _file
push 0x3a303a3a
push byte 10
"cmp eax, ebx \n ja exit \n jmp eax"
"mov dl, byte 0ffh"
dup2:
"msg db  world!', 0ah"
me:
"mov edx, ecx"
push 0x61702f63
"sar ebx, 31"
push dword 0x6b6e756a
loop l2 \n jmp edi
"sub dx, dx"
push dword 0x7264632f
"mov eax, 1"
push 0x68735858
"mov ebx, 1"
"loop l2 \n mov ebx, esp"
"shr ecx, 2"
db 10
"mov eax, 4"
"xor byte [esi+ecx], 0x0f"
"mov edx, 3"
dec ecx
"shr dl, 1"
89 db 1
push 0x1c
"mov eax, 4"
str db 'hey'
"mov cl, 9"
"lea ecx, [zero_reg+117]"
not byte [eax]
"mov eax, esi"
loop ROT_WO
push byte my_read \n pop eax
array word 0xb315
"mov al, 0x06"
push 0xsetup
div esi
"cmp BYTE [edx], 0x2e \n jne l2 \n jmp while"
"cmp eax, ebx"
push byte +0x8
push eax
push 0x0a206873
"mov al, 0xcd"
"mov ebx, filename"
"test eax, eax \n js old_dirent"
 start:
decrypt:
"mov eax, 37"
"mov esp, ebp"
"push 0x61702f2f \n push 0x6374652f \n mov eax, esp"
push 0x0
"mov ebx, type var3"
pop edx
inc no
priv_numer:
"rol byte [esi], 4"
"test eax, eax \n jnz l4 \n call search"
"mov ebx, [ebx]"
"push dword 0x62732f2f \n mov ebx, esp"
"lea ax, [ebph]"
egg equ ' mark'
"mov bl, cl"
push esp
push 0x74756873
section .text
section .bss
"push 0x6e7a762d \n mov edi, esp"
string: db 'test.txt'
"mov eax, 64"
"mov bl, byte [eax]"
"xor cl, 0xaa"
jmp short end
"mov eax, 67"
"xor ah, ah"
push byte 0x1f
"cmp DWORD [edx], 0x636f7270 \n je while"
"test eax, eax \n jz write \n xor eax, eax"
jmp _return
"mov eax, [ebx+24]"
"mov eax, key"
"xchg [ebp+16], ecx"
"mov edx, esp"
"xchg ecx, edx"
"mov [esp+59], ebx"
pop word forlVqhP
_dup2:
inc bl
section .data
"mov eax, 27"
"mov bl, 2"
"push esi \n mov eax, esp"
push '/bin'
jmp reading
"mov bl, 3"
loop fill
"mov ecx, readbuffer"
pop ebx
"mov byte [esi + 1], dl"
writestring:
section .bss
"lea edx, [esi + 12]"
"mov byte [esi+12], al"
mul ebx
"mov eax, 6"
"mov edi, hexstr_socketcall"
push 0x68732f2f
"mov eax, 6"
"mov cl, 13"
"mov eax, 20"
"mov ebx, zero_reg"
push word [edx]
jnz 0 hexstr
"mov esi, 0x72702f2f"
"lea eax,[ebx+0xf0xc"
div edx
"add ax, 1"
"mov al, 6"
jmp _star
push ebx
jz shift_decode
"mov cx, 0xfff"
push eax
close:
z: dd 0x b
rotate:
"mov edx, [esp]"
"sub ax, 13"
call egghunter
mul edx
"mov long [esi+30], eax"
next:
"mov al, 0x66"
"mov ax, 0x010ch"
push 0x74
push byte 0x64 \n pop eax
priv_on_error
push 0x6f635f64
"xor eax, 0xffffffff"
push byte 6 \n pop eax
"xor eax, eax"
"cmp al, 0xf2 \n je _start"
"add eax, esi"
"mov bl, byte [eax]"
"test eax, eax \n jz found \n xor eax, eax"
next
"mov dl, 0x2"
"mov eax, 27"
"mov eax, 64"
"cmp BYTE [esi], 0x7 \n jl lowbound"
"mov byte [esi+ecx], bl"
"add eax, esi"
 entrypoint:
"cmp al, 0xf2 \n je next_page"
jmp loop
call two
fill_ret:
db '/proc/sys/kernel/randomize_va_spacex'
"mov al, 9h"
push 0x204c4c41
close_the_egg
inc ebx
priv:
"ror esi, 1"
"push byte 3 \n mov ebx, esp"
"sub ebx, 0x2e2aa163"
"cmp eax, ebx \n ja exit \n jmp eax"
"mov eax, 5"
buffer: resw 1
push esi
push byte 9 \n pop eax
"and al, 0fh"
push 0execve
"mov esi, v_src"
"define an array of bytes and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce"
"xchg eax, ebx"
push byte 49
"test eax, eax \n js close"
"cmp al, 0xf2 \n je incpage"
"mov dword [esp-4], esi"
"push eax \n mov edx, esp"
jz 0x86
"mov eax, 11"
push 0x0a4c4c41
jmp short stage
"cmp BYTE bl, [esi] \n jne loop_1"
call _appendfile
jmp esp
"msg db  world!', 0h"
push 0x10
"mov esi, 0x91969dd0"
"xor ebx, ebx"
"push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp"
exit:
"mov bl, byte [edi]"
"mov eax, 0x8000"
"rol edx, 0x4"
6839 dw -f
"mov byte [ecx+92], dl"
"test eax, eax \n jnz l1 \n call myfunct"
push 0x4
"add al, 0xa"
"mov eax, 19"
jz decoded
int 80h
push 0x6d722f2f
"mov cx, word_table[3]"
"mov eax, esp"
global _ global
"cmp BYTE al, 2 \n je do_inject \n jmp while"
inc dword [tmp]
push eax
04:
"mov eax, 0"
"mov eax, 0x9a8dd091"
"mov ebx, 2"
"rol edi, 1"
"mov ecx, 25"
"sub ecx, 0x6374612e cxe"
inc dx
"push 0x6374652f \n mov ecx, esp"
"cmp cl, 0x5 \n jb l11"
"push 0x68732f2f \n push 0x6e69622f \n mov edx, esp"
len equ $-shellcode
"lea eax, [zero_reg+6]"
"mov cl, len"
pop cx
