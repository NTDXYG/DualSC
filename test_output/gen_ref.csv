"mov long [esi+26], ebx"
"push 0x6e69622f \n push 0x7273752f \n mov ecx, esp"
push eax
"test eax, eax \n jz ready_to_proxy"
"mov bl, byte [esi]"
push dword 0x73656c62
"shr ax, 1"
"cmp al, 0x38 \n je 0x40 \n push byte 0x1"
jns dup2
push bx
"mov bx, [esi]"
"mov byte [edi], bl"
push word 0x697a
push 0xefffff7f
loopnz L1
call sprint
"mov edx, eatlen"
push byte 0x43 \n pop eax
incpage:
"and eax, 0000000fh"
"mov al, 61"
push 0x622f7273
"push edi \n mov ebx, esp"
"mov eax, 37"
"test eax, eax \n jnz checkforfile"
"cmp al, 9 \n jge l1"
set_mark:
push 0x3d4c4c41
array dd 20
"lea eax, [zero_reg+3]"
push 0x2f3a746f
not eax
push dword 0x2335738c
"cmp eax, ebx \n je exit \n mov al, 0x4"
"cmp eax, edi \n jne infinite"
call writestring
"cmp byte [esi], 0xD \n jl wrap_around"
"test eax, eax \n jz short loc_402C13"
matrix qw 12*10
"mov ecx, esi"
"mov [ebp+22], word ax"
"mov al, 0xb"
not byte [var2]
push byte 16
"xor dl, 0xBB \n jz Next_Cycle"
"mov al, 15"
set_mark:
loop 3
"mov cl, 0x2"
call prepare
jmp short search
"shl ecx, 2"
string: db 'tmp.txt'
"mov dl, 0x7f"
jmp short gotocall
push ecx
"mov al, 102"
"mov eax, 4"
"msg db 'we found the egg!', 0ah, 0dh"
"shr edx, byte 24"
push 0x64687373
"push 0x64687373 \n mov eax, esp"
"mov esi, 0x222933f0"
"mov [edi], al"
"loop l2 \n mov ebx, esp"
"mov ax, 00"
push byte 0xc \n pop eax
"xor esi, esi"
"xor [ecx], dh"
cld
"add edi, edi"
prepare:
"cmp DWORD [eax], edx \n jne loop \n jmp eax"
"mov bl, 0xe"
dim: equ 512
"add byte_value, 65"
"sub dx, 15444"
"xor ah, ah"
"mov ebp, esp"
"cmp al, 0xf2"
push word 0x5c11
push esi
"add edx, 32"
"mov eax, 29"
"byte_table db 14, 15, 22, 45"
"mov cl, 0102"
pop eax
call esp
"mov cl, byte [esi]"
push 0x6873732f
push word 0x1b6
jmp short _file
push 0x3a303a3a
push byte 10
"cmp eax, ebx \n je connect \n ja exit"
"mov dl, byte 0ffh"
dup2:
"msg db 'hello, world!', 0xa"
me:
"mov edx, ecx"
push 0x61702f63
"sar ebx, 31"
push dword 0x6b6e756a
loop l2 \n jmp edi
"sub dx, 15444"
push dword 0x7264632f
"mov eax, 1"
push 0x68735858
"mov ebx, 1"
"loop l2 \n mov ebx, esp"
"shr ecx, 1"
db 10
"mov eax, 4"
"xor byte [esi+ecx],0x0f"
"mov edx, 3"
dec ecx
"shr dl,1"
choice db 'y'
push 0x1c
"mov eax, 4"
"str db 'hey',0"
"mov cl, 9"
"lea ecx, [zero_reg+117]"
not byte [tmp]
"mov eax, buzz"
dec ecx \n jz counter_is_now_zero
push byte CHMOD_CALL \n pop eax
array word 5
"mov al, 0x06"
push 0x68732f2f
div esi
"cmp BYTE [edx], 0x2e \n jne l2 \n jmp while"
"cmp eax,ebx"
push byte +0x8
push eax
push 0x0a206873
"mov al, 0xcd"
"mov ebx, filename"
"test eax, eax \n js old_dirent"
start:
shellcode:
"mov eax, 37"
"mov esp, ebp"
"push 0x61702f2f \n push 0x6374652f \n mov eax, esp"
push 0x0
"mov ebx, type var3"
pop edx
jnz incaddr
odd_number:
"rol byte [esi], 4"
"test eax, eax \n jnz l4 \n call search"
"mov ebx, [esp]"
"push dword 0x62732f2f \n mov ebx, esp"
"mov ax, [1000h]"
egg equ 'egg '
"mov bl, cl"
push esp
push 0x74756873
section .text
section .bss
"push 0x6e7a762d \n mov edi, esp"
string db 'test.txt'
"mov eax, 64"
"mov bl, byte [eax]"
"xor cl, 0xaa"
jmp short end
push byte 0x43
"xor ah, ah"
push byte 0x1f
"cmp DWORD [edx], 0x636f7270 \n je while"
"test eax, eax \n jz write \n xor eax, eax"
jmp _return
"mov eax, [ebx+esi*2+4]"
"mov eax, key"
"xchg [ebp+16], ecx"
"mov edx, esp"
"xchg ecx, edx"
"mov [esp+59], ebx"
bignum: resw 1
_dup2_loop:
inc bl
section .data
"mov eax, 27"
"mov bl, 2"
"push esi \n mov eax, esp"
push '/bin'
jmp reading
"mov bl, 3"
loop fill
"mov ecx, readbuffer"
pop ebx
"mov byte [esi + 1], dl"
callit:
section .data
"lea edx, [esi + 12]"
"mov byte [esi+12], al"
mul ebx
"mov eax, 6"
"mov edi, eax"
push 0x6e69622f
"mov eax, 6"
"mov cl, 13"
"mov eax, 20"
"mov ebx, zero_reg"
push word [edx]
jnz top
"mov esi, 0x72702f2f"
"lea eax, [ebx+0xf]"
div edx
inc ax
"mov al, 6"
jmp _star
push ebx
jz shift_decode
"mov cx, 0xfff"
push eax
closefile:
b: dd 0x0
gotocall:
"mov edx, esp"
"sub ax, 13"
call egghunter
mul edx
"mov long [esi+30], eax"
next:
"mov al, 0x66"
"mov ax, 010ch"
push 0x74
push byte 0x64 \n pop eax
exit_on_error:
push 0x6f635f64
"xor eax, 0xffffffff"
push byte 6 \n pop eax
"xor eax, eax"
"cmp al, 0xf2 \n jz _start"
"add eax, c"
"mov bl, byte [eax]"
"test eax, eax \n jz write \n xor eax, eax"
closefile:
"mov dl, 0x2"
"mov eax, 27"
"mov eax, 64"
"cmp BYTE [esi], 0x7 \n jl lowbound"
"mov byte [esi+ecx], bl"
"add eax, esi"
entrypoint:
"cmp al, 0xf2 \n je next_page"
jmp loop
call two
shell_ret:
db '/proc/sys/kernel/randomize_va_spacex'
"mov al, 05h"
push 0x204c4c41
total_students equ 50
inc ebx
format:
"ror byte [esi], 0x1"
"push byte 3 \n mov ebx, esp"
"sub ebx, 0x2e2aa163"
"cmp eax, ebx \n je connect \n ja exit"
"mov eax, 5"
ymmval: resw 1
push esi
push byte 9 \n pop eax
"and al, 0fh"
push sys_execve
"mov esi, v_src"
"encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce"
"xchg eax, ebx"
push byte 49
"test eax, eax \n js close"
"cmp al, 0xf2 \n jz incpage"
"mov dword [esp-4], esi"
"push eax \n mov edx, esp"
jnc 0x86
int 0x80
push 0x0a4c4c41
jmp short stage
"cmp BYTE bl, [esi] \n jne loop_1"
call _appendfile
jmp esp
message: db 'hello world!'
push 0x10
"mov esi, 0x91969dd0"
"xor ebx, ebx"
"push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp"
exit:
"mov bl, byte [edi]"
"mov eax, 0x8000"
"rol edx, 0x4"
"db ',ajm,pk#########'"
"mov byte [ecx+92], dl"
"test eax, eax \n jnz l1 \n call myfunct"
push 0x4
"add al, 0xa"
"mov eax, 64"
jz decoded_shellcode
int 80h
push 0x6d722f2f
"mov cx, word_table + 3"
"mov eax, esp"
global _shell
"cmp BYTE al, 2 \n je do_inject \n jmp while"
inc dword [value]
push eax
shell:
"mov ebx, 0"
"mov eax, 0x9a8dd091"
"mov ebx, 4"
"rol edi, 1"
"mov [ecx], 25"
"sub ecx, 0x6374612e"
inc dx
"push 0x6374652f \n mov ecx, esp"
"cmp cl, 0x11 \n jb 0xff \n add dl, 0x5"
"push 0x68732f2f \n push 0x6e69622f \n mov edx, esp"
len equ $ - msg
"lea eax, [zero_reg+6]"
"mov cl, len"
pop cx
