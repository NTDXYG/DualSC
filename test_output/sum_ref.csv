move ecx into edx
move dl into the byte at address [ecx+92]
push eax onto the stack
push the byte +0x8 onto the stack
subtract 15444 from the contents of the dx register
clear the esi register
declare the prepare label
"define the byte string ',ajm,pk#########'"
move the word at the address ax into [ebp+22]
push 0x6f635f64 onto the stack
move 0x9a8dd091 into eax
system call alarm
move 0x66 into al
jump to the incpage label if the contents of the al register is equal to the value 0xf2
push sys_execve onto the stack
move 0xcd into al
declare the shellcode label
increment address if no match
push 0xefffff7f onto the stack
point ebp to top of stack
perform the xor operation between the byte at memory location esi+ecx and 0x0f
put the byte my_label into the eax register
declare _shell as global label
jump to decoded if zero
define an array of 5 initialized word
put the syscall 0xc into the eax register
subtract 0x6374612e from the contents in ecx and save the result in ecx
load the effective address of the result of the operation [zero_reg+3] into the eax register
jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7
decrement the counter and jump to the fill label if the count is not zero
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
push the 0x74756873 onto the stack
move the contents of the esi register into the bx register
clear the ah register
getpid
push the contents of the eax register onto the stack
make the system call getppid
"define the array of bytes encodedshellcode and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce"
negate all bits in the byte at the memory location tmp
negate all the bits of the eax register
define variable choice of 1 byte and initialize to y
jump short to the end label
move the contents of the eax register into the long starting at the address [esi+30]
restore ebx from the value we pushed onto the stack at the start
system call sigaction
move cl into bl
increment the contents of the ebx register
right shift the contents of the edx register by the byte 24
section bss
define dim to be 512 bytes large
push 0x2f3a746f onto the stack
jump short to stage
jump to dup2 if not negative
jump to _star
declare the set_mark label
push the word 0x697a onto the stack
perform a logical xor between the cl register and 0xaa and save the result in cl
move 0x7f into dl
push the contents of the eax register onto the stack and point edx to the stack register
multiply the contents of the eax register by the contents of the ebx register
jump to 0x86 if the carry flag is zero
load the effective address of the result of the operation [zero_reg+117] into the ecx register
right shift the contents of dl register by 1 bit positions
subtract 0x2e2aa163 from the contents in ebx and save the result in ebx
call the egghunter function
jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
move the byte 0ffh into dl
move 0x06 into al
declare the entrypoint label
mask out lowest 4 bits of the eax register
move al into the byte at address [esi+12]
preserve esi on the stack
"define a tables of bytes byte_table and initialize to 14, 15 and 22"
define len equal to the length of msg
jump to the label l1 if the contents of the eax register is not zero else call the function myfunct
push the contents of the esi register onto the stack and point eax to the stack register
system call write
push 0x4 onto the stack
pop the next argument off the stack into eax
push 0x0a4c4c41 onto the stack
if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0xff else add the 0x5 value to the dl register
system call getppid
jump short to the _file label
move the contents of memory address ebx+esi*2+4 into eax
declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively
code for exit syscall
put the syscall 6 into the eax register
multiply eax by edx
move filename into ebx
move bl into the byte at address [esi+ecx]
move the contents of the ebp register ino the esp register
initialize ax to 00
push 0x3a303a3a onto the stack
zero out ah register
push the contents of the bx register onto the stack
move the address of buzz string into eax
jump short to the search label
push the byte 49 onto the stack
push the contents of the edi register onto the stack and point ebx to the stack register
jump to the _return label
add c to eax
jump short to the gotocall label
move 0x72702f2f into esi
compare the contents of eax with ebx
divide ecx by 2 using right shift
if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1
define msg as the byte string 'we found the egg!'
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
define the closefile function
preserve ecx on the stack
restore the top of the stack into edx register
move len into cl
if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label
left rotate the contents of the edx register by 0x4 bits
push the double word 0x2335738c onto the stack
create variable b in memory and initialize to zero
declare the start label
add 1 to ax
move the byte at the address [eax] into bl
pop the last element pushed onto the stack into cx
clear the eax register
preserve ebx on the stack
move the byte in esi into bl
push 0x622f7273 to the stack
push the byte 10 to the stack
move 0xfff into cx
kill
perform a logical xor between the eax register and 0xffffffff and save the result in eax
if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270 then jump to the while label
move 6 into al
move the return value of sys_socketcall into edi
move 3 decimal into edx
declare the shell_ret label
move 05h into al
move esi into the dword at address [esp-4]
push the dword 0x7264632f onto the stack
jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD
add the contents of edi to the contents of edi
invoke sys_write
push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register
move 102 into al
increment the contents of the bl register
jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
decrement ecx by 1
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register
execute execve with system call interrupt
perform the xor operation between the value stored at the location ecx and dh
push ASCII /bin/sh onto the stack and point the edx register to the stack register
subtract 15444 from dx and save the result into dx
compare the contents of the al register and 0xf2
call writestring
move /bin/sh into the ecx register
declare odd_numer function
system call open
add the contents of the esi register to the contents of eax register
push /bin to the stack
decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero
add 32 to edx
allocate memory for a 12*10 quad-bytes matrix
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
define dup2 function
move 2 into bl
add an immediate operand 65 to byte_value
define egg equal to 'egg '
push the word 0x5c11 onto the stack
jump to the label loop
decrement the counter and jump to the L1 label if the count is not zero and the zero flag is equal to zero
define the callit label
jump to the connect label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
push the contents of the esp register onto the stack
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
jump to the label close if the contents of the eax register is negative
declare section .data
divide eax by esi
swap the contents of the ecx register with the contents of the edx register
define the doubleword arr and initialize it to 20
divide eax by value in edx
subtract 13 from ax and save the result into ax
call the _appendfile function
call the esp function
put syscall sigaction into the eax register
jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack
move eatlen into edx
push the word [edx] onto the stack
move 0x222933f0 into esi
move al into edi
add 0xa to the al register
jump to the _start label if the contents of the al register is equal to the value 0xf2
move the contents of the ebx register into the long starting at the address [esi+26]
declare the shell label
move 0x2 into dl
push esi to the stack
define exit function
push the 0x61702f63 onto the stack
push the value 0x68735858 onto the stack
move 25 decimal into the memory address ecx
push 0x1c to the stack
jump to the Next_Cycle label if the result of the logical xor between the dl register and the value 0xBB is zero
call the prepare function
move 1 into ebx
move 15 into lower byte of the eax register
reserve 1 word at location bignum
define string as the byte string 'test.txt'
push the byte 0x1f onto the stack
push 0x204c4c41 onto the stack
declare the me label
move readbuffer into ecx
"jump to the label write if the contents of the eax register is zero, else zero out the contents of the eax register"
push 0x0 onto the stack
move the byte at the address [esi] into cl
push the dword 0x6b6e756a onto the stack
move 0x91969dd0 into esi
declare message to contain the bytes 'hello world!'
load the object at the address 1000h into the ax register
if not 0 then jump to the top label
move value at top of the stack to ebx
suspend the process until the signal arrives
jump to the esp label
put the syscall 9 into the eax register
define the closefile label
push the doubleword 0x73656c62 to the stack
move v_src to esi
jump short to the memory location loc_402C13 if the contents of the eax register is zero
define set_mark label
move 0xe into bl
push the byte 3 onto the stack and point ebx to the stack register
right shift the contents of ebx by 31 bits
move the byte in edi into bl
invoke subroutine listen
close the file
right shift ax by 1 bit
define the _dup2_loop label
left rotate the edi register 1 time
move 0102 into cl
make the system call to set set signal delivery alarm clock
if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1
move the 32-bit value 0x8000 into register eax
put the syscall 0x64 into the eax register
move the byte in eax into bl
move ebx into the address [esp+59]
declare an unlabeled byte initialized to 10
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register
move value of 0x010ch into the register ax
if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
push eax to the stack
right rotate the byte in esi 1 time
push the value 0x6374652f onto the stack and point ecx to the stack register
move 61 into al
declare the data section
reset both lower and uppper bytes of ebx to be 0
swap the contents of the eax register with the contents of the ebx register
system call kill
push //sh to the stack
direction flag equal to zero
push the value 0x6873732f onto the stack
push the value 0x6e7a762d onto the stack and point the edi register to the stack register
call the sprint function
move the number of bytes of var3 into ebx
call sys_read
move 13 into cl
exit with return code of 0
jump to the label old_dirent if the contents of the eax register is negative
push 0x74 onto the stack
section .text
increment the contents of the dx register
load the effective address of the result of the operation [esi + 12] into the edx register
move bl into the byte in edi
push the word 0x1b6 onto the stack
push '/bin' onto the stack
move the address of the current stack pointer into eax
push the value 0x10 onto the stack
swap the contents in ebp+16 and ecx
declare the exit_on_error label
perform a logical and operation between the al register and the 0fh value and store the result in the al register
declare the format label
declare the gotocall label
reserve one word for ymmval
rotate 4 bits left the byte starting at the address esi
decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero
make the system call close
move 0x2 into cl
if the byte representation of 2 is equal to the contents of the al register else jump to the while label then jump to the label do_inject
move esp into edx
move key into eax
make the system call to get the parent process ID
define string as the byte string 'tmp.txt'
push the 0x3d4c4c41 onto the stack
load the effective address of the result of the operation [ebx+0xf] into the eax register
move 3 into bl
define the byte string '/proc/sys/kernel/randomize_va_spacex'
negate all bits in the byte at the memory location var2
declare incpage function
push eax value to the stack
move esi into ecx
if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register
jump to the reading label
if the contents of the al register is equal to the value 0xf2 then jump to the label next_page
jump to the label checkforfile if the contents of the eax register is not zero
push the 0x6d722f2f onto the stack
move the contents of the esp register into the edx register
jump to the label l4 if the contents of the eax register is not zero else call the function search
multiply ecx by 4 using left shift
push the value 0x64687373 onto the stack and point the eax register to the stack register
add one to the doubleword integer stored at memory location value
move 9 into cl
push 0x64687373 onto the stack
load the effective address of the result of the operation [zero_reg+6] into the eax register
push 0x0a206873 onto the stack
if zero jump to the shift_decode label
define constant total_students equal to 50
move the 4th element of the word_table into cx
declare msg string containing 'hello world!'
call the two function
jump to the label ready_to_proxy if the contents of the eax register is zero
move zero_reg into ebx
mov 0xb into lower byte of eax
make the system call to write to the file
declare the next label
move dl into the byte at address [esi + 1]
push byte 16 onto stack
