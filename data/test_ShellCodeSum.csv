INTENTS,SNIPPETS
"ShellCodeSum: mov esi, 0x222933f0",move 0x222933f0 into esi
ShellCodeSum: push 0x204c4c41,push 0x204c4c41 onto the stack
"ShellCodeSum: mov esp, ebp",move the contents of the ebp register ino the esp register
"ShellCodeSum: mov ecx, readbuffer",move readbuffer into ecx
ShellCodeSum: section .data,declare the data section
"ShellCodeSum: byte_table db 14, 15, 22, 45","define a tables of bytes byte_table and initialize to 14, 15 and 22"
ShellCodeSum: format:,declare the format label
ShellCodeSum: odd_number:,declare odd_numer function
"ShellCodeSum: mov al, 0xcd",move 0xcd into al
ShellCodeSum: push bx,push the contents of the bx register onto the stack
ShellCodeSum: div esi,divide eax by esi
"ShellCodeSum: sub ecx, 0x6374612e",subtract 0x6374612e from the contents in ecx and save the result in ecx
ShellCodeSum: push 0x61702f63,push the 0x61702f63 onto the stack
ShellCodeSum: section .text,section .text
ShellCodeSum: dec ecx \n jz counter_is_now_zero,decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero
ShellCodeSum: string: db 'tmp.txt',define string as the byte string 'tmp.txt'
"ShellCodeSum: mov byte [ecx+92], dl",move dl into the byte at address [ecx+92]
ShellCodeSum: push 0x4,push 0x4 onto the stack
ShellCodeSum: int 80h,call sys_read
"ShellCodeSum: xchg ecx, edx",swap the contents of the ecx register with the contents of the edx register
"ShellCodeSum: mov al, 6",move 6 into al
"ShellCodeSum: mov ax, 00",initialize ax to 00
ShellCodeSum: set_mark:,define set_mark label
"ShellCodeSum: sub ax, 13",subtract 13 from ax and save the result into ax
"ShellCodeSum: cmp cl, 0x11 \n jb 0xff \n add dl, 0x5",if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0xff else add the 0x5 value to the dl register
"ShellCodeSum: mov [ecx], 25",move 25 decimal into the memory address ecx
"ShellCodeSum: cmp BYTE bl, [esi] \n jne loop_1",if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1
ShellCodeSum: db 10,declare an unlabeled byte initialized to 10
ShellCodeSum: call esp,call the esp function
"ShellCodeSum: xor ah, ah",zero out ah register
"ShellCodeSum: xor cl, 0xaa",perform a logical xor between the cl register and 0xaa and save the result in cl
"ShellCodeSum: cmp BYTE [edx], 0x2e \n jne l2 \n jmp while",if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label
"ShellCodeSum: test eax, eax \n jz write \n xor eax, eax","jump to the label write if the contents of the eax register is zero, else zero out the contents of the eax register"
"ShellCodeSum: cmp al, 0xf2",compare the contents of the al register and 0xf2
"ShellCodeSum: rol byte [esi], 4",rotate 4 bits left the byte starting at the address esi
"ShellCodeSum: mov long [esi+30], eax",move the contents of the eax register into the long starting at the address [esi+30]
"ShellCodeSum: mov [edi], al",move al into edi
ShellCodeSum: push 0x74756873,push the 0x74756873 onto the stack
"ShellCodeSum: mov eax, 1",code for exit syscall
ShellCodeSum: jmp esp,jump to the esp label
"ShellCodeSum: cmp eax, edi \n jne infinite",jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
ShellCodeSum: push byte 0x43 \n pop eax,put syscall sigaction into the eax register
ShellCodeSum: shellcode:,declare the shellcode label
"ShellCodeSum: mov al, 102",move 102 into al
"ShellCodeSum: mov eax, 4",invoke sys_write
"ShellCodeSum: mov eax, 5",system call open
"ShellCodeSum: cmp al, 0xf2 \n je next_page",if the contents of the al register is equal to the value 0xf2 then jump to the label next_page
"ShellCodeSum: encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce","define the array of bytes encodedshellcode and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce"
"ShellCodeSum: mov esi, 0x72702f2f",move 0x72702f2f into esi
ShellCodeSum: jz decoded_shellcode,jump to decoded if zero
ShellCodeSum: int 0x80,execute execve with system call interrupt
ShellCodeSum: call _appendfile,call the _appendfile function
"ShellCodeSum: cmp byte [esi], 0xD \n jl wrap_around",jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD
"ShellCodeSum: mov cl, byte [esi]",move the byte at the address [esi] into cl
"ShellCodeSum: push eax \n mov edx, esp",push the contents of the eax register onto the stack and point edx to the stack register
"ShellCodeSum: xor dl, 0xBB \n jz Next_Cycle",jump to the Next_Cycle label if the result of the logical xor between the dl register and the value 0xBB is zero
ShellCodeSum: pop ebx,restore ebx from the value we pushed onto the stack at the start
ShellCodeSum: call sprint,call the sprint function
"ShellCodeSum: lea eax, [zero_reg+3]",load the effective address of the result of the operation [zero_reg+3] into the eax register
"ShellCodeSum: mov cl, 9",move 9 into cl
"ShellCodeSum: cmp al, 9 \n jge l1",if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1
"ShellCodeSum: mov al, 05h",move 05h into al
ShellCodeSum: array dd 20,define the doubleword arr and initialize it to 20
ShellCodeSum: choice db 'y',define variable choice of 1 byte and initialize to y
"ShellCodeSum: cmp eax, ebx \n je connect \n ja exit",jump to the connect label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
ShellCodeSum: dec ecx,decrement ecx by 1
"ShellCodeSum: mov cl, 0102",move 0102 into cl
"ShellCodeSum: mov edx, 3",move 3 decimal into edx
ShellCodeSum: b: dd 0x0,create variable b in memory and initialize to zero
"ShellCodeSum: mov al, 61",move 61 into al
ShellCodeSum: push ebx,preserve ebx on the stack
"ShellCodeSum: mov edx, esp",move the contents of the esp register into the edx register
ShellCodeSum: push byte 0x1f,push the byte 0x1f onto the stack
"ShellCodeSum: mov bx, [esi]",move the contents of the esi register into the bx register
ShellCodeSum: push dword 0x6b6e756a,push the dword 0x6b6e756a onto the stack
"ShellCodeSum: sub dx, 15444",subtract 15444 from dx and save the result into dx
"ShellCodeSum: mov eax, key",move key into eax
"ShellCodeSum: lea eax, [ebx+0xf]",load the effective address of the result of the operation [ebx+0xf] into the eax register
"ShellCodeSum: cmp DWORD [edx], 0x636f7270 \n je while",if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270 then jump to the while label
"ShellCodeSum: add eax, esi",add the contents of the esi register to the contents of eax register
"ShellCodeSum: mov bl, cl",move cl into bl
ShellCodeSum: _dup2_loop:,define the _dup2_loop label
ShellCodeSum: global _shell,declare _shell as global label
"ShellCodeSum: add al, 0xa",add 0xa to the al register
"ShellCodeSum: mov [ebp+22], word ax",move the word at the address ax into [ebp+22]
"ShellCodeSum: xor ebx, ebx",reset both lower and uppper bytes of ebx to be 0
"ShellCodeSum: mov edx, ecx",move ecx into edx
"ShellCodeSum: shr ecx, 1",divide ecx by 2 using right shift
"ShellCodeSum: mov eax, 27",make the system call to set set signal delivery alarm clock
"ShellCodeSum: cmp eax, ebx \n je connect \n ja exit",if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
"ShellCodeSum: shr edx, byte 24",right shift the contents of the edx register by the byte 24
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov edx, esp",push ASCII /bin/sh onto the stack and point the edx register to the stack register
ShellCodeSum: push 0xefffff7f,push 0xefffff7f onto the stack
ShellCodeSum: push 0x3d4c4c41,push the 0x3d4c4c41 onto the stack
ShellCodeSum: mul ebx,multiply the contents of the eax register by the contents of the ebx register
ShellCodeSum: push 0x0a4c4c41,push 0x0a4c4c41 onto the stack
ShellCodeSum: div edx,divide eax by value in edx
ShellCodeSum: push eax,push the contents of the eax register onto the stack
ShellCodeSum: push 0x10,push the value 0x10 onto the stack
"ShellCodeSum: mov esi, v_src",move v_src to esi
ShellCodeSum: gotocall:,declare the gotocall label
"ShellCodeSum: mov eax, buzz",move the address of buzz string into eax
"ShellCodeSum: push 0x6e7a762d \n mov edi, esp",push the value 0x6e7a762d onto the stack and point the edi register to the stack register
ShellCodeSum: push byte 0x43,system call sigaction
"ShellCodeSum: mov cx, word_table + 3",move the 4th element of the word_table into cx
"ShellCodeSum: add edx, 32",add 32 to edx
ShellCodeSum: db '/proc/sys/kernel/randomize_va_spacex',define the byte string '/proc/sys/kernel/randomize_va_spacex'
"ShellCodeSum: mov ebp, esp",point ebp to top of stack
"ShellCodeSum: test eax, eax \n jnz checkforfile",jump to the label checkforfile if the contents of the eax register is not zero
"ShellCodeSum: mov eax, [ebx+esi*2+4]",move the contents of memory address ebx+esi*2+4 into eax
"ShellCodeSum: xor byte [esi+ecx],0x0f",perform the xor operation between the byte at memory location esi+ecx and 0x0f
"ShellCodeSum: test eax, eax \n jz ready_to_proxy",jump to the label ready_to_proxy if the contents of the eax register is zero
"ShellCodeSum: mov dl, 0x2",move 0x2 into dl
ShellCodeSum: push byte 10,push the byte 10 to the stack
"ShellCodeSum: mov dword [esp-4], esi",move esi into the dword at address [esp-4]
"ShellCodeSum: mov eax, 4",system call write
"ShellCodeSum: push esi \n mov eax, esp",push the contents of the esi register onto the stack and point eax to the stack register
ShellCodeSum: push sys_execve,push sys_execve onto the stack
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp",move /bin/sh into the ecx register
ShellCodeSum: closefile:,define the closefile label
"ShellCodeSum: cmp eax,ebx",compare the contents of eax with ebx
ShellCodeSum: push 0x64687373,push 0x64687373 onto the stack
ShellCodeSum: push byte CHMOD_CALL \n pop eax,put the byte my_label into the eax register
ShellCodeSum: call two,call the two function
ShellCodeSum: section .bss,section bss
ShellCodeSum: push byte 0xc \n pop eax,put the syscall 0xc into the eax register
"ShellCodeSum: mov ebx, 1",move 1 into ebx
ShellCodeSum: exit_on_error:,declare the exit_on_error label
ShellCodeSum: prepare:,declare the prepare label
"ShellCodeSum: mov cx, 0xfff",move 0xfff into cx
ShellCodeSum: push byte 49,push the byte 49 onto the stack
ShellCodeSum: shell_ret:,declare the shell_ret label
"ShellCodeSum: push 0x6e69622f \n push 0x7273752f \n mov ecx, esp",push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
ShellCodeSum: call writestring,call writestring
"ShellCodeSum: mov byte [esi + 1], dl",move dl into the byte at address [esi + 1]
ShellCodeSum: push 0x6d722f2f,push the 0x6d722f2f onto the stack
"ShellCodeSum: mov eax, 64",make the system call getppid
"ShellCodeSum: mov eax, 6",make the system call close
ShellCodeSum: loop l2 \n jmp edi,decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register
ShellCodeSum: jnz top,if not 0 then jump to the top label
ShellCodeSum: push esp,push the contents of the esp register onto the stack
ShellCodeSum: push 0x6e69622f,push /bin to the stack
ShellCodeSum: push byte +0x8,push the byte +0x8 onto the stack
ShellCodeSum: pop eax,pop the next argument off the stack into eax
ShellCodeSum: matrix qw 12*10,allocate memory for a 12*10 quad-bytes matrix
"ShellCodeSum: mov edx, eatlen",move eatlen into edx
ShellCodeSum: jmp short stage,jump short to stage
ShellCodeSum: push 0x622f7273,push 0x622f7273 to the stack
"ShellCodeSum: mov eax, 0x9a8dd091",move 0x9a8dd091 into eax
ShellCodeSum: jmp _return,jump to the _return label
ShellCodeSum: push 0x0a206873,push 0x0a206873 onto the stack
ShellCodeSum: next:,declare the next label
ShellCodeSum: push 0x1c,push 0x1c to the stack
ShellCodeSum: bignum: resw 1,reserve 1 word at location bignum
"ShellCodeSum: mov al, 0x06",move 0x06 into al
ShellCodeSum: len equ $ - msg,define len equal to the length of msg
ShellCodeSum: push 0x2f3a746f,push 0x2f3a746f onto the stack
ShellCodeSum: ymmval: resw 1,reserve one word for ymmval
"ShellCodeSum: xchg eax, ebx",swap the contents of the eax register with the contents of the ebx register
"ShellCodeSum: mov al, 0xb",mov 0xb into lower byte of eax
ShellCodeSum: exit:,define exit function
ShellCodeSum: dim: equ 512,define dim to be 512 bytes large
"ShellCodeSum: mov ebx, 4",invoke subroutine listen
ShellCodeSum: jmp short end,jump short to the end label
"ShellCodeSum: rol edi, 1",left rotate the edi register 1 time
"ShellCodeSum: msg db 'hello, world!', 0xa",declare msg string containing 'hello world!'
"ShellCodeSum: add eax, c",add c to eax
"ShellCodeSum: mov bl, byte [eax]",move the byte in eax into bl
ShellCodeSum: loop fill,decrement the counter and jump to the fill label if the count is not zero
ShellCodeSum: jns dup2,jump to dup2 if not negative
"ShellCodeSum: mov eax, 27",system call alarm
ShellCodeSum: push byte 6 \n pop eax,put the syscall 6 into the eax register
"ShellCodeSum: mov byte [edi], bl",move bl into the byte in edi
"ShellCodeSum: mov ebx, zero_reg",move zero_reg into ebx
ShellCodeSum: jmp short search,jump short to the search label
"ShellCodeSum: mov al, 0x66",move 0x66 into al
"ShellCodeSum: test eax, eax \n jnz l4 \n call search",jump to the label l4 if the contents of the eax register is not zero else call the function search
"ShellCodeSum: mov bl, byte [esi]",move the byte in esi into bl
ShellCodeSum: set_mark:,declare the set_mark label
ShellCodeSum: jmp short gotocall,jump short to the gotocall label
ShellCodeSum: push 0x3a303a3a,push 0x3a303a3a onto the stack
ShellCodeSum: jnc 0x86,jump to 0x86 if the carry flag is zero
"ShellCodeSum: push byte 3 \n mov ebx, esp",push the byte 3 onto the stack and point ebx to the stack register
"ShellCodeSum: test eax, eax \n jnz l1 \n call myfunct",jump to the label l1 if the contents of the eax register is not zero else call the function myfunct
ShellCodeSum: push dword 0x2335738c,push the double word 0x2335738c onto the stack
"ShellCodeSum: mov byte [esi+ecx], bl",move bl into the byte at address [esi+ecx]
"ShellCodeSum: push 0x6374652f \n mov ecx, esp",push the value 0x6374652f onto the stack and point ecx to the stack register
"ShellCodeSum: push 0x61702f2f \n push 0x6374652f \n mov eax, esp",push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register
"ShellCodeSum: mov bl, byte [edi]",move the byte in edi into bl
"ShellCodeSum: and eax, 0000000fh",mask out lowest 4 bits of the eax register
"ShellCodeSum: cmp eax, ebx \n je exit \n mov al, 0x4",jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
"ShellCodeSum: shr dl,1",right shift the contents of dl register by 1 bit positions
"ShellCodeSum: mov ax, 010ch",move value of 0x010ch into the register ax
"ShellCodeSum: mov bl, 3",move 3 into bl
ShellCodeSum: not eax,negate all the bits of the eax register
ShellCodeSum: push byte 16,push byte 16 onto stack
"ShellCodeSum: lea edx, [esi + 12]",load the effective address of the result of the operation [esi + 12] into the edx register
ShellCodeSum: mul edx,multiply eax by edx
"ShellCodeSum: rol edx, 0x4",left rotate the contents of the edx register by 0x4 bits
"ShellCodeSum: mov ax, [1000h]",load the object at the address 1000h into the ax register
"ShellCodeSum: mov eax, 64",system call getppid
"ShellCodeSum: mov eax, 6",close the file
ShellCodeSum: total_students equ 50,define constant total_students equal to 50
ShellCodeSum: jmp _star,jump to _star
"ShellCodeSum: cmp al, 0xf2 \n jz _start",jump to the _start label if the contents of the al register is equal to the value 0xf2
ShellCodeSum: push 0x68732f2f,push //sh to the stack
ShellCodeSum: push 0x6f635f64,push 0x6f635f64 onto the stack
"ShellCodeSum: mov edi, eax",move the return value of sys_socketcall into edi
"ShellCodeSum: mov ebx, filename",move filename into ebx
"ShellCodeSum: ror byte [esi], 0x1",right rotate the byte in esi 1 time
"ShellCodeSum: mov al, 15",move 15 into lower byte of the eax register
"ShellCodeSum: lea ecx, [zero_reg+117]",load the effective address of the result of the operation [zero_reg+117] into the ecx register
ShellCodeSum: push dword 0x7264632f,push the dword 0x7264632f onto the stack
ShellCodeSum: dup2:,define dup2 function
ShellCodeSum: inc ebx,increment the contents of the ebx register
"ShellCodeSum: xor [ecx], dh",perform the xor operation between the value stored at the location ecx and dh
"ShellCodeSum: cmp DWORD [eax], edx \n jne loop \n jmp eax",jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
"ShellCodeSum: mov ebx, type var3",move the number of bytes of var3 into ebx
"ShellCodeSum: push dword 0x62732f2f \n mov ebx, esp",push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register
"ShellCodeSum: test eax, eax \n js old_dirent",jump to the label old_dirent if the contents of the eax register is negative
ShellCodeSum: push 0x6873732f,push the value 0x6873732f onto the stack
ShellCodeSum: jz shift_decode,if zero jump to the shift_decode label
"ShellCodeSum: mov eax, esp",move the address of the current stack pointer into eax
"ShellCodeSum: db ',ajm,pk#########'","define the byte string ',ajm,pk#########'"
ShellCodeSum: jnz incaddr,increment address if no match
ShellCodeSum: inc dword [value],add one to the doubleword integer stored at memory location value
"ShellCodeSum: cmp BYTE [esi], 0x7 \n jl lowbound",jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7
ShellCodeSum: push eax,push eax to the stack
"ShellCodeSum: test eax, eax \n js close",jump to the label close if the contents of the eax register is negative
ShellCodeSum: push word 0x5c11,push the word 0x5c11 onto the stack
ShellCodeSum: incpage:,declare incpage function
"ShellCodeSum: mov ebx, 0",exit with return code of 0
ShellCodeSum: push eax,push eax value to the stack
"ShellCodeSum: mov bl, byte [eax]",move the byte at the address [eax] into bl
"ShellCodeSum: sub ebx, 0x2e2aa163",subtract 0x2e2aa163 from the contents in ebx and save the result in ebx
ShellCodeSum: inc bl,increment the contents of the bl register
"ShellCodeSum: add byte_value, 65",add an immediate operand 65 to byte_value
"ShellCodeSum: mov eax, 0x8000",move the 32-bit value 0x8000 into register eax
"ShellCodeSum: mov cl, 13",move 13 into cl
"ShellCodeSum: mov eax, 4",make the system call to write to the file
"ShellCodeSum: mov ecx, esi",move esi into ecx
ShellCodeSum: jmp loop,jump to the label loop
ShellCodeSum: entrypoint:,declare the entrypoint label
"ShellCodeSum: cmp al, 0xf2 \n jz incpage",jump to the incpage label if the contents of the al register is equal to the value 0xf2
ShellCodeSum: callit:,define the callit label
ShellCodeSum: push esi,preserve esi on the stack
ShellCodeSum: string db 'test.txt',define string as the byte string 'test.txt'
ShellCodeSum: call prepare,call the prepare function
ShellCodeSum: not byte [var2],negate all bits in the byte at the memory location var2
"ShellCodeSum: push 0x64687373 \n mov eax, esp",push the value 0x64687373 onto the stack and point the eax register to the stack register
"ShellCodeSum: mov esi, 0x91969dd0",move 0x91969dd0 into esi
"ShellCodeSum: mov eax, 37",system call kill
"ShellCodeSum: loop l2 \n mov ebx, esp",decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
ShellCodeSum: start:,declare the start label
ShellCodeSum: closefile:,define the closefile function
"ShellCodeSum: mov eax, 37",kill
ShellCodeSum: push 0x74,push 0x74 onto the stack
"ShellCodeSum: msg db 'we found the egg!', 0ah, 0dh",define msg as the byte string 'we found the egg!'
"ShellCodeSum: loop l2 \n mov ebx, esp",decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
"ShellCodeSum: mov byte [esi+12], al",move al into the byte at address [esi+12]
"ShellCodeSum: mov edx, esp",move esp into edx
"ShellCodeSum: mov ebx, [esp]",move value at top of the stack to ebx
"ShellCodeSum: xchg [ebp+16], ecx",swap the contents in ebp+16 and ecx
"ShellCodeSum: cmp al, 0x38 \n je 0x40 \n push byte 0x1",jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack
ShellCodeSum: message: db 'hello world!',declare message to contain the bytes 'hello world!'
ShellCodeSum: push 0x68735858,push the value 0x68735858 onto the stack
"ShellCodeSum: xor esi, esi",clear the esi register
"ShellCodeSum: mov cl, 0x2",move 0x2 into cl
ShellCodeSum: push dword 0x73656c62,push the doubleword 0x73656c62 to the stack
"ShellCodeSum: mov bl, 0xe",move 0xe into bl
"ShellCodeSum: and al, 0fh",perform a logical and operation between the al register and the 0fh value and store the result in the al register
"ShellCodeSum: test eax, eax \n jz short loc_402C13",jump short to the memory location loc_402C13 if the contents of the eax register is zero
"ShellCodeSum: test eax, eax \n jz write \n xor eax, eax",if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register
ShellCodeSum: cld,direction flag equal to zero
"ShellCodeSum: shr ax, 1",right shift ax by 1 bit
ShellCodeSum: shell:,declare the shell label
"ShellCodeSum: str db 'hey',0",declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively
ShellCodeSum: push esi,push esi to the stack
ShellCodeSum: push word 0x697a,push the word 0x697a onto the stack
"ShellCodeSum: mov eax, 64",make the system call to get the parent process ID
ShellCodeSum: push '/bin',push '/bin' onto the stack
"ShellCodeSum: sar ebx, 31",right shift the contents of ebx by 31 bits
ShellCodeSum: jmp short _file,jump short to the _file label
"ShellCodeSum: lea eax, [zero_reg+6]",load the effective address of the result of the operation [zero_reg+6] into the eax register
ShellCodeSum: push 0x0,push 0x0 onto the stack
ShellCodeSum: inc ax,add 1 to ax
ShellCodeSum: egg equ 'egg ',define egg equal to 'egg '
ShellCodeSum: section .data,declare section .data
ShellCodeSum: inc dx,increment the contents of the dx register
ShellCodeSum: jmp reading,jump to the reading label
"ShellCodeSum: mov cl, len",move len into cl
"ShellCodeSum: mov dl, 0x7f",move 0x7f into dl
"ShellCodeSum: mov bl, 2",move 2 into bl
"ShellCodeSum: shl ecx, 2",multiply ecx by 4 using left shift
ShellCodeSum: loopnz L1,decrement the counter and jump to the L1 label if the count is not zero and the zero flag is equal to zero
"ShellCodeSum: mov eax, 20",getpid
ShellCodeSum: pop edx,restore the top of the stack into edx register
ShellCodeSum: push byte 9 \n pop eax,put the syscall 9 into the eax register
"ShellCodeSum: xor ah, ah",clear the ah register
"ShellCodeSum: cmp BYTE al, 2 \n je do_inject \n jmp while",if the byte representation of 2 is equal to the contents of the al register else jump to the while label then jump to the label do_inject
ShellCodeSum: push word 0x1b6,push the word 0x1b6 onto the stack
ShellCodeSum: array word 5,define an array of 5 initialized word
"ShellCodeSum: mov eax, 29",suspend the process until the signal arrives
ShellCodeSum: call egghunter,call the egghunter function
ShellCodeSum: me:,declare the me label
ShellCodeSum: pop cx,pop the last element pushed onto the stack into cx
"ShellCodeSum: xor eax, 0xffffffff",perform a logical xor between the eax register and 0xffffffff and save the result in eax
ShellCodeSum: push word [edx],push the word [edx] onto the stack
ShellCodeSum: push eax,push eax onto the stack
"ShellCodeSum: mov dl, byte 0ffh",move the byte 0ffh into dl
"ShellCodeSum: push edi \n mov ebx, esp",push the contents of the edi register onto the stack and point ebx to the stack register
ShellCodeSum: not byte [tmp],negate all bits in the byte at the memory location tmp
"ShellCodeSum: xor eax, eax",clear the eax register
"ShellCodeSum: mov [esp+59], ebx",move ebx into the address [esp+59]
ShellCodeSum: loop 3,decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero
ShellCodeSum: push ecx,preserve ecx on the stack
ShellCodeSum: push byte 0x64 \n pop eax,put the syscall 0x64 into the eax register
"ShellCodeSum: add edi, edi",add the contents of edi to the contents of edi
"ShellCodeSum: mov long [esi+26], ebx",move the contents of the ebx register into the long starting at the address [esi+26]
"ShellCodeSum: sub dx, 15444",subtract 15444 from the contents of the dx register
