input_text,target_text
ShellCodeGen: move the contents of the ebx register into the long starting at the address [esi+26],"mov long [esi+26], ebx"
ShellCodeGen: push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register,"push 0x6e69622f \n push 0x7273752f \n mov ecx, esp"
"ShellCodeSum: mov edx, ecx",move ecx into edx
ShellCodeGen: push eax to the stack,push eax
"ShellCodeSum: mov byte [ecx+92], dl",move dl into the byte at address [ecx+92]
ShellCodeSum: push eax,push eax onto the stack
ShellCodeGen: jump to the label ready_to_proxy if the contents of the eax register is zero,"test eax, eax \n jz ready_to_proxy"
ShellCodeGen: move the byte in esi into bl,"mov bl, byte [esi]"
ShellCodeSum: push byte +0x8,push the byte +0x8 onto the stack
"ShellCodeSum: sub dx, 15444",subtract 15444 from the contents of the dx register
"ShellCodeSum: xor esi, esi",clear the esi register
ShellCodeSum: prepare:,declare the prepare label
"ShellCodeSum: db ',ajm,pk#########'","define the byte string ',ajm,pk#########'"
ShellCodeGen: push the doubleword 0x73656c62 to the stack,push dword 0x73656c62
"ShellCodeSum: mov [ebp+22], word ax",move the word at the address ax into [ebp+22]
ShellCodeGen: right shift ax by 1 bit,"shr ax, 1"
ShellCodeSum: push 0x6f635f64,push 0x6f635f64 onto the stack
ShellCodeGen: jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack,"cmp al, 0x38 \n je 0x40 \n push byte 0x1"
ShellCodeGen: jump to dup2 if not negative,jns dup2
"ShellCodeSum: mov eax, 0x9a8dd091",move 0x9a8dd091 into eax
"ShellCodeSum: mov eax, 27",system call alarm
ShellCodeGen: push the contents of the bx register onto the stack,push bx
ShellCodeGen: move the contents of the esi register into the bx register,"mov bx, [esi]"
"ShellCodeSum: mov al, 0x66",move 0x66 into al
ShellCodeGen: move bl into the byte in edi,"mov byte [edi], bl"
ShellCodeGen: push the word 0x697a onto the stack,push word 0x697a
"ShellCodeSum: cmp al, 0xf2 \n jz incpage",jump to the incpage label if the contents of the al register is equal to the value 0xf2
ShellCodeGen: push 0xefffff7f onto the stack,push 0xefffff7f
ShellCodeGen: decrement the counter and jump to the L1 label if the count is not zero and the zero flag is equal to zero,loopnz L1
ShellCodeGen: call the sprint function,call sprint
ShellCodeGen: move eatlen into edx,"mov edx, eatlen"
ShellCodeSum: push sys_execve,push sys_execve onto the stack
ShellCodeGen: put syscall sigaction into the eax register,push byte 0x43 \n pop eax
ShellCodeGen: declare incpage function,incpage:
ShellCodeGen: mask out lowest 4 bits of the eax register,"and eax, 0000000fh"
ShellCodeGen: move 61 into al,"mov al, 61"
"ShellCodeSum: mov al, 0xcd",move 0xcd into al
ShellCodeGen: push 0x622f7273 to the stack,push 0x622f7273
ShellCodeSum: shellcode:,declare the shellcode label
ShellCodeGen: push the contents of the edi register onto the stack and point ebx to the stack register,"push edi \n mov ebx, esp"
ShellCodeGen: kill,"mov eax, 37"
ShellCodeSum: jnz incaddr,increment address if no match
ShellCodeSum: push 0xefffff7f,push 0xefffff7f onto the stack
ShellCodeGen: jump to the label checkforfile if the contents of the eax register is not zero,"test eax, eax \n jnz checkforfile"
"ShellCodeSum: mov ebp, esp",point ebp to top of stack
"ShellCodeSum: xor byte [esi+ecx],0x0f",perform the xor operation between the byte at memory location esi+ecx and 0x0f
ShellCodeGen: if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1,"cmp al, 9 \n jge l1"
ShellCodeSum: push byte CHMOD_CALL \n pop eax,put the byte my_label into the eax register
ShellCodeSum: global _shell,declare _shell as global label
ShellCodeSum: jz decoded_shellcode,jump to decoded if zero
ShellCodeGen: declare the set_mark label,set_mark:
ShellCodeGen: push the 0x3d4c4c41 onto the stack,push 0x3d4c4c41
ShellCodeSum: array word 5,define an array of 5 initialized word
ShellCodeSum: push byte 0xc \n pop eax,put the syscall 0xc into the eax register
"ShellCodeSum: sub ecx, 0x6374612e",subtract 0x6374612e from the contents in ecx and save the result in ecx
"ShellCodeSum: lea eax, [zero_reg+3]",load the effective address of the result of the operation [zero_reg+3] into the eax register
"ShellCodeSum: cmp BYTE [esi], 0x7 \n jl lowbound",jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7
ShellCodeSum: loop fill,decrement the counter and jump to the fill label if the count is not zero
ShellCodeGen: define the doubleword arr and initialize it to 20,array dd 20
ShellCodeGen: load the effective address of the result of the operation [zero_reg+3] into the eax register,"lea eax, [zero_reg+3]"
ShellCodeGen: push 0x2f3a746f onto the stack,push 0x2f3a746f
"ShellCodeSum: cmp eax, ebx \n je exit \n mov al, 0x4",jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
ShellCodeSum: push 0x74756873,push the 0x74756873 onto the stack
"ShellCodeSum: mov bx, [esi]",move the contents of the esi register into the bx register
ShellCodeGen: negate all the bits of the eax register,not eax
ShellCodeGen: push the double word 0x2335738c onto the stack,push dword 0x2335738c
"ShellCodeSum: xor ah, ah",clear the ah register
ShellCodeGen: jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register,"cmp eax, ebx \n je exit \n mov al, 0x4"
"ShellCodeSum: mov eax, 20",getpid
ShellCodeSum: push eax,push the contents of the eax register onto the stack
ShellCodeGen: jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register,"cmp eax, edi \n jne infinite"
ShellCodeGen: call writestring,call writestring
ShellCodeGen: jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD,"cmp byte [esi], 0xD \n jl wrap_around"
"ShellCodeSum: mov eax, 64",make the system call getppid
ShellCodeGen: jump short to the memory location loc_402C13 if the contents of the eax register is zero,"test eax, eax \n jz short loc_402C13"
ShellCodeGen: allocate memory for a 12*10 quad-bytes matrix,matrix qw 12*10
ShellCodeGen: move esi into ecx,"mov ecx, esi"
ShellCodeGen: move the word at the address ax into [ebp+22],"mov [ebp+22], word ax"
ShellCodeGen: mov 0xb into lower byte of eax,"mov al, 0xb"
ShellCodeGen: negate all bits in the byte at the memory location var2,not byte [var2]
ShellCodeGen: push byte 16 onto stack,push byte 16
"ShellCodeSum: encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce","define the array of bytes encodedshellcode and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce"
ShellCodeSum: not byte [tmp],negate all bits in the byte at the memory location tmp
ShellCodeGen: jump to the Next_Cycle label if the result of the logical xor between the dl register and the value 0xBB is zero,"xor dl, 0xBB \n jz Next_Cycle"
ShellCodeSum: not eax,negate all the bits of the eax register
ShellCodeSum: choice db 'y',define variable choice of 1 byte and initialize to y
ShellCodeSum: jmp short end,jump short to the end label
ShellCodeGen: move 15 into lower byte of the eax register,"mov al, 15"
"ShellCodeSum: mov long [esi+30], eax",move the contents of the eax register into the long starting at the address [esi+30]
ShellCodeGen: define set_mark label,set_mark:
ShellCodeGen: decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero,loop 3
ShellCodeGen: move 0x2 into cl,"mov cl, 0x2"
ShellCodeSum: pop ebx,restore ebx from the value we pushed onto the stack at the start
ShellCodeSum: push byte 0x43,system call sigaction
ShellCodeGen: call the prepare function,call prepare
ShellCodeGen: jump short to the search label,jmp short search
"ShellCodeSum: mov bl, cl",move cl into bl
ShellCodeGen: multiply ecx by 4 using left shift,"shl ecx, 2"
ShellCodeSum: inc ebx,increment the contents of the ebx register
"ShellCodeSum: shr edx, byte 24",right shift the contents of the edx register by the byte 24
ShellCodeGen: define string as the byte string 'tmp.txt',string: db 'tmp.txt'
ShellCodeSum: section .bss,section bss
ShellCodeSum: dim: equ 512,define dim to be 512 bytes large
ShellCodeSum: push 0x2f3a746f,push 0x2f3a746f onto the stack
ShellCodeGen: move 0x7f into dl,"mov dl, 0x7f"
ShellCodeSum: jmp short stage,jump short to stage
ShellCodeGen: jump short to the gotocall label,jmp short gotocall
ShellCodeGen: preserve ecx on the stack,push ecx
ShellCodeSum: jns dup2,jump to dup2 if not negative
ShellCodeGen: move 102 into al,"mov al, 102"
ShellCodeGen: system call write,"mov eax, 4"
ShellCodeSum: jmp _star,jump to _star
ShellCodeGen: define msg as the byte string 'we found the egg!',"msg db 'we found the egg!', 0ah, 0dh"
ShellCodeSum: set_mark:,declare the set_mark label
ShellCodeSum: push word 0x697a,push the word 0x697a onto the stack
"ShellCodeSum: xor cl, 0xaa",perform a logical xor between the cl register and 0xaa and save the result in cl
ShellCodeGen: right shift the contents of the edx register by the byte 24,"shr edx, byte 24"
"ShellCodeSum: mov dl, 0x7f",move 0x7f into dl
ShellCodeGen: push 0x64687373 onto the stack,push 0x64687373
ShellCodeGen: push the value 0x64687373 onto the stack and point the eax register to the stack register,"push 0x64687373 \n mov eax, esp"
ShellCodeGen: move 0x222933f0 into esi,"mov esi, 0x222933f0"
ShellCodeGen: move al into edi,"mov [edi], al"
"ShellCodeSum: push eax \n mov edx, esp",push the contents of the eax register onto the stack and point edx to the stack register
ShellCodeSum: mul ebx,multiply the contents of the eax register by the contents of the ebx register
ShellCodeGen: decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register,"loop l2 \n mov ebx, esp"
ShellCodeGen: initialize ax to 00,"mov ax, 00"
ShellCodeSum: jnc 0x86,jump to 0x86 if the carry flag is zero
ShellCodeGen: put the syscall 0xc into the eax register,push byte 0xc \n pop eax
"ShellCodeSum: lea ecx, [zero_reg+117]",load the effective address of the result of the operation [zero_reg+117] into the ecx register
"ShellCodeSum: shr dl,1",right shift the contents of dl register by 1 bit positions
ShellCodeGen: clear the esi register,"xor esi, esi"
ShellCodeGen: perform the xor operation between the value stored at the location ecx and dh,"xor [ecx], dh"
"ShellCodeSum: sub ebx, 0x2e2aa163",subtract 0x2e2aa163 from the contents in ebx and save the result in ebx
ShellCodeSum: call egghunter,call the egghunter function
ShellCodeGen: direction flag equal to zero,cld
ShellCodeGen: add the contents of edi to the contents of edi,"add edi, edi"
ShellCodeGen: declare the prepare label,prepare:
"ShellCodeSum: cmp eax, edi \n jne infinite",jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
ShellCodeGen: jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register,"cmp DWORD [eax], edx \n jne loop \n jmp eax"
"ShellCodeSum: mov dl, byte 0ffh",move the byte 0ffh into dl
ShellCodeGen: move 0xe into bl,"mov bl, 0xe"
ShellCodeGen: define dim to be 512 bytes large,dim: equ 512
"ShellCodeSum: mov al, 0x06",move 0x06 into al
ShellCodeGen: add an immediate operand 65 to byte_value,"add byte_value, 65"
ShellCodeSum: entrypoint:,declare the entrypoint label
"ShellCodeSum: and eax, 0000000fh",mask out lowest 4 bits of the eax register
"ShellCodeSum: mov byte [esi+12], al",move al into the byte at address [esi+12]
ShellCodeSum: push esi,preserve esi on the stack
"ShellCodeSum: byte_table db 14, 15, 22, 45","define a tables of bytes byte_table and initialize to 14, 15 and 22"
ShellCodeGen: subtract 15444 from dx and save the result into dx,"sub dx, 15444"
ShellCodeSum: len equ $ - msg,define len equal to the length of msg
"ShellCodeSum: test eax, eax \n jnz l1 \n call myfunct",jump to the label l1 if the contents of the eax register is not zero else call the function myfunct
"ShellCodeSum: push esi \n mov eax, esp",push the contents of the esi register onto the stack and point eax to the stack register
ShellCodeGen: clear the ah register,"xor ah, ah"
"ShellCodeSum: mov eax, 4",system call write
ShellCodeSum: push 0x4,push 0x4 onto the stack
ShellCodeGen: point ebp to top of stack,"mov ebp, esp"
ShellCodeGen: compare the contents of the al register and 0xf2,"cmp al, 0xf2"
ShellCodeSum: pop eax,pop the next argument off the stack into eax
ShellCodeSum: push 0x0a4c4c41,push 0x0a4c4c41 onto the stack
ShellCodeGen: push the word 0x5c11 onto the stack,push word 0x5c11
ShellCodeGen: preserve esi on the stack,push esi
ShellCodeGen: add 32 to edx,"add edx, 32"
"ShellCodeSum: cmp cl, 0x11 \n jb 0xff \n add dl, 0x5",if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0xff else add the 0x5 value to the dl register
ShellCodeGen: suspend the process until the signal arrives,"mov eax, 29"
"ShellCodeSum: mov eax, 64",system call getppid
"ShellCodeGen: define a tables of bytes byte_table and initialize to 14, 15 and 22","byte_table db 14, 15, 22, 45"
ShellCodeGen: move 0102 into cl,"mov cl, 0102"
ShellCodeGen: pop the next argument off the stack into eax,pop eax
ShellCodeSum: jmp short _file,jump short to the _file label
ShellCodeGen: call the esp function,call esp
"ShellCodeSum: mov eax, [ebx+esi*2+4]",move the contents of memory address ebx+esi*2+4 into eax
"ShellCodeSum: str db 'hey',0",declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively
"ShellCodeSum: mov eax, 1",code for exit syscall
ShellCodeGen: move the byte at the address [esi] into cl,"mov cl, byte [esi]"
ShellCodeGen: push the value 0x6873732f onto the stack,push 0x6873732f
ShellCodeGen: push the word 0x1b6 onto the stack,push word 0x1b6
ShellCodeSum: push byte 6 \n pop eax,put the syscall 6 into the eax register
ShellCodeGen: jump short to the _file label,jmp short _file
ShellCodeSum: mul edx,multiply eax by edx
ShellCodeGen: push 0x3a303a3a onto the stack,push 0x3a303a3a
ShellCodeGen: push the byte 10 to the stack,push byte 10
"ShellCodeSum: mov ebx, filename",move filename into ebx
"ShellCodeSum: mov byte [esi+ecx], bl",move bl into the byte at address [esi+ecx]
"ShellCodeSum: mov esp, ebp",move the contents of the ebp register ino the esp register
"ShellCodeSum: mov ax, 00",initialize ax to 00
ShellCodeSum: push 0x3a303a3a,push 0x3a303a3a onto the stack
"ShellCodeSum: xor ah, ah",zero out ah register
ShellCodeGen: jump to the connect label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register,"cmp eax, ebx \n je connect \n ja exit"
ShellCodeGen: move the byte 0ffh into dl,"mov dl, byte 0ffh"
ShellCodeSum: push bx,push the contents of the bx register onto the stack
"ShellCodeSum: mov eax, buzz",move the address of buzz string into eax
ShellCodeSum: jmp short search,jump short to the search label
ShellCodeGen: define dup2 function,dup2:
ShellCodeGen: declare msg string containing 'hello world!',"msg db 'hello, world!', 0xa"
ShellCodeGen: declare the me label,me:
ShellCodeSum: push byte 49,push the byte 49 onto the stack
"ShellCodeSum: push edi \n mov ebx, esp",push the contents of the edi register onto the stack and point ebx to the stack register
ShellCodeGen: move ecx into edx,"mov edx, ecx"
ShellCodeSum: jmp _return,jump to the _return label
ShellCodeGen: push the 0x61702f63 onto the stack,push 0x61702f63
"ShellCodeSum: add eax, c",add c to eax
ShellCodeSum: jmp short gotocall,jump short to the gotocall label
ShellCodeGen: right shift the contents of ebx by 31 bits,"sar ebx, 31"
"ShellCodeSum: mov esi, 0x72702f2f",move 0x72702f2f into esi
"ShellCodeSum: cmp eax,ebx",compare the contents of eax with ebx
"ShellCodeSum: shr ecx, 1",divide ecx by 2 using right shift
"ShellCodeSum: cmp BYTE bl, [esi] \n jne loop_1",if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1
ShellCodeGen: push the dword 0x6b6e756a onto the stack,push dword 0x6b6e756a
ShellCodeGen: decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register,loop l2 \n jmp edi
"ShellCodeSum: msg db 'we found the egg!', 0ah, 0dh",define msg as the byte string 'we found the egg!'
"ShellCodeSum: loop l2 \n mov ebx, esp",decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
ShellCodeSum: closefile:,define the closefile function
ShellCodeGen: subtract 15444 from the contents of the dx register,"sub dx, 15444"
ShellCodeGen: push the dword 0x7264632f onto the stack,push dword 0x7264632f
ShellCodeSum: push ecx,preserve ecx on the stack
ShellCodeSum: pop edx,restore the top of the stack into edx register
ShellCodeGen: code for exit syscall,"mov eax, 1"
"ShellCodeSum: mov cl, len",move len into cl
"ShellCodeSum: cmp BYTE [edx], 0x2e \n jne l2 \n jmp while",if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label
ShellCodeGen: push the value 0x68735858 onto the stack,push 0x68735858
"ShellCodeSum: rol edx, 0x4",left rotate the contents of the edx register by 0x4 bits
ShellCodeSum: push dword 0x2335738c,push the double word 0x2335738c onto the stack
ShellCodeSum: b: dd 0x0,create variable b in memory and initialize to zero
ShellCodeSum: start:,declare the start label
ShellCodeSum: inc ax,add 1 to ax
"ShellCodeSum: mov bl, byte [eax]",move the byte at the address [eax] into bl
ShellCodeGen: move 1 into ebx,"mov ebx, 1"
ShellCodeSum: pop cx,pop the last element pushed onto the stack into cx
"ShellCodeSum: xor eax, eax",clear the eax register
ShellCodeSum: push ebx,preserve ebx on the stack
ShellCodeGen: decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register,"loop l2 \n mov ebx, esp"
ShellCodeGen: divide ecx by 2 using right shift,"shr ecx, 1"
"ShellCodeSum: mov bl, byte [esi]",move the byte in esi into bl
ShellCodeGen: declare an unlabeled byte initialized to 10,db 10
ShellCodeSum: push 0x622f7273,push 0x622f7273 to the stack
ShellCodeGen: make the system call to write to the file,"mov eax, 4"
ShellCodeGen: perform the xor operation between the byte at memory location esi+ecx and 0x0f,"xor byte [esi+ecx],0x0f"
ShellCodeGen: move 3 decimal into edx,"mov edx, 3"
ShellCodeGen: decrement ecx by 1,dec ecx
ShellCodeSum: push byte 10,push the byte 10 to the stack
"ShellCodeSum: mov cx, 0xfff",move 0xfff into cx
"ShellCodeSum: mov eax, 37",kill
ShellCodeGen: right shift the contents of dl register by 1 bit positions,"shr dl,1"
"ShellCodeSum: xor eax, 0xffffffff",perform a logical xor between the eax register and 0xffffffff and save the result in eax
"ShellCodeSum: cmp DWORD [edx], 0x636f7270 \n je while",if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270 then jump to the while label
ShellCodeGen: define variable choice of 1 byte and initialize to y,choice db 'y'
ShellCodeGen: push 0x1c to the stack,push 0x1c
ShellCodeGen: invoke sys_write,"mov eax, 4"
"ShellCodeSum: mov al, 6",move 6 into al
ShellCodeGen: declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively,"str db 'hey',0"
ShellCodeGen: move 9 into cl,"mov cl, 9"
"ShellCodeSum: mov edi, eax",move the return value of sys_socketcall into edi
ShellCodeGen: load the effective address of the result of the operation [zero_reg+117] into the ecx register,"lea ecx, [zero_reg+117]"
ShellCodeGen: negate all bits in the byte at the memory location tmp,not byte [tmp]
"ShellCodeSum: mov edx, 3",move 3 decimal into edx
ShellCodeSum: shell_ret:,declare the shell_ret label
"ShellCodeSum: mov al, 05h",move 05h into al
ShellCodeGen: move the address of buzz string into eax,"mov eax, buzz"
ShellCodeGen: decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero,dec ecx \n jz counter_is_now_zero
ShellCodeGen: put the byte my_label into the eax register,push byte CHMOD_CALL \n pop eax
ShellCodeGen: define an array of 5 initialized word,array word 5
ShellCodeGen: move 0x06 into al,"mov al, 0x06"
ShellCodeGen: push //sh to the stack,push 0x68732f2f
ShellCodeGen: divide eax by esi,div esi
"ShellCodeSum: mov dword [esp-4], esi",move esi into the dword at address [esp-4]
ShellCodeSum: push dword 0x7264632f,push the dword 0x7264632f onto the stack
ShellCodeGen: if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label,"cmp BYTE [edx], 0x2e \n jne l2 \n jmp while"
ShellCodeGen: compare the contents of eax with ebx,"cmp eax,ebx"
ShellCodeGen: push the byte +0x8 onto the stack,push byte +0x8
"ShellCodeSum: cmp byte [esi], 0xD \n jl wrap_around",jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD
"ShellCodeSum: add edi, edi",add the contents of edi to the contents of edi
ShellCodeGen: push eax value to the stack,push eax
"ShellCodeSum: mov eax, 4",invoke sys_write
ShellCodeGen: push 0x0a206873 onto the stack,push 0x0a206873
"ShellCodeSum: push dword 0x62732f2f \n mov ebx, esp",push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register
"ShellCodeSum: mov al, 102",move 102 into al
ShellCodeGen: move 0xcd into al,"mov al, 0xcd"
ShellCodeGen: move filename into ebx,"mov ebx, filename"
ShellCodeSum: inc bl,increment the contents of the bl register
ShellCodeGen: jump to the label old_dirent if the contents of the eax register is negative,"test eax, eax \n js old_dirent"
ShellCodeGen: declare the start label,start:
ShellCodeGen: declare the shellcode label,shellcode:
"ShellCodeSum: cmp DWORD [eax], edx \n jne loop \n jmp eax",jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
ShellCodeSum: dec ecx,decrement ecx by 1
ShellCodeGen: system call kill,"mov eax, 37"
ShellCodeGen: move the contents of the ebp register ino the esp register,"mov esp, ebp"
"ShellCodeSum: push 0x61702f2f \n push 0x6374652f \n mov eax, esp",push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register
ShellCodeSum: int 0x80,execute execve with system call interrupt
"ShellCodeSum: xor [ecx], dh",perform the xor operation between the value stored at the location ecx and dh
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov edx, esp",push ASCII /bin/sh onto the stack and point the edx register to the stack register
"ShellCodeSum: sub dx, 15444",subtract 15444 from dx and save the result into dx
"ShellCodeSum: cmp al, 0xf2",compare the contents of the al register and 0xf2
ShellCodeGen: push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register,"push 0x61702f2f \n push 0x6374652f \n mov eax, esp"
ShellCodeSum: call writestring,call writestring
ShellCodeGen: push 0x0 onto the stack,push 0x0
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp",move /bin/sh into the ecx register
ShellCodeGen: move the number of bytes of var3 into ebx,"mov ebx, type var3"
ShellCodeSum: odd_number:,declare odd_numer function
ShellCodeGen: restore the top of the stack into edx register,pop edx
"ShellCodeSum: mov eax, 5",system call open
"ShellCodeSum: add eax, esi",add the contents of the esi register to the contents of eax register
ShellCodeGen: increment address if no match,jnz incaddr
ShellCodeGen: declare odd_numer function,odd_number:
ShellCodeSum: push 0x6e69622f,push /bin to the stack
ShellCodeSum: dec ecx \n jz counter_is_now_zero,decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero
ShellCodeGen: rotate 4 bits left the byte starting at the address esi,"rol byte [esi], 4"
ShellCodeGen: jump to the label l4 if the contents of the eax register is not zero else call the function search,"test eax, eax \n jnz l4 \n call search"
"ShellCodeSum: add edx, 32",add 32 to edx
ShellCodeGen: move value at top of the stack to ebx,"mov ebx, [esp]"
ShellCodeSum: matrix qw 12*10,allocate memory for a 12*10 quad-bytes matrix
ShellCodeGen: push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register,"push dword 0x62732f2f \n mov ebx, esp"
ShellCodeGen: load the object at the address 1000h into the ax register,"mov ax, [1000h]"
"ShellCodeSum: loop l2 \n mov ebx, esp",decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
ShellCodeSum: dup2:,define dup2 function
"ShellCodeSum: mov bl, 2",move 2 into bl
"ShellCodeSum: add byte_value, 65",add an immediate operand 65 to byte_value
ShellCodeSum: egg equ 'egg ',define egg equal to 'egg '
ShellCodeGen: define egg equal to 'egg ',egg equ 'egg '
ShellCodeGen: move cl into bl,"mov bl, cl"
ShellCodeSum: push word 0x5c11,push the word 0x5c11 onto the stack
ShellCodeSum: jmp loop,jump to the label loop
ShellCodeSum: loopnz L1,decrement the counter and jump to the L1 label if the count is not zero and the zero flag is equal to zero
ShellCodeSum: callit:,define the callit label
"ShellCodeSum: cmp eax, ebx \n je connect \n ja exit",jump to the connect label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
ShellCodeSum: push esp,push the contents of the esp register onto the stack
"ShellCodeSum: push 0x6e69622f \n push 0x7273752f \n mov ecx, esp",push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
"ShellCodeSum: test eax, eax \n js close",jump to the label close if the contents of the eax register is negative
ShellCodeSum: section .data,declare section .data
ShellCodeSum: div esi,divide eax by esi
ShellCodeGen: push the contents of the esp register onto the stack,push esp
"ShellCodeSum: xchg ecx, edx",swap the contents of the ecx register with the contents of the edx register
ShellCodeSum: array dd 20,define the doubleword arr and initialize it to 20
ShellCodeGen: push the 0x74756873 onto the stack,push 0x74756873
ShellCodeSum: div edx,divide eax by value in edx
"ShellCodeSum: sub ax, 13",subtract 13 from ax and save the result into ax
ShellCodeSum: call _appendfile,call the _appendfile function
ShellCodeSum: call esp,call the esp function
ShellCodeGen: section .text,section .text
ShellCodeSum: push byte 0x43 \n pop eax,put syscall sigaction into the eax register
ShellCodeGen: section bss,section .bss
"ShellCodeSum: cmp al, 0x38 \n je 0x40 \n push byte 0x1",jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack
"ShellCodeSum: mov edx, eatlen",move eatlen into edx
ShellCodeSum: push word [edx],push the word [edx] onto the stack
ShellCodeGen: push the value 0x6e7a762d onto the stack and point the edi register to the stack register,"push 0x6e7a762d \n mov edi, esp"
ShellCodeGen: define string as the byte string 'test.txt',string db 'test.txt'
ShellCodeGen: system call getppid,"mov eax, 64"
"ShellCodeSum: mov esi, 0x222933f0",move 0x222933f0 into esi
"ShellCodeSum: mov [edi], al",move al into edi
ShellCodeGen: move the byte in eax into bl,"mov bl, byte [eax]"
ShellCodeGen: perform a logical xor between the cl register and 0xaa and save the result in cl,"xor cl, 0xaa"
"ShellCodeSum: add al, 0xa",add 0xa to the al register
"ShellCodeSum: cmp al, 0xf2 \n jz _start",jump to the _start label if the contents of the al register is equal to the value 0xf2
"ShellCodeSum: mov long [esi+26], ebx",move the contents of the ebx register into the long starting at the address [esi+26]
ShellCodeSum: shell:,declare the shell label
"ShellCodeSum: mov dl, 0x2",move 0x2 into dl
ShellCodeGen: jump short to the end label,jmp short end
ShellCodeGen: system call sigaction,push byte 0x43
ShellCodeGen: zero out ah register,"xor ah, ah"
ShellCodeSum: push esi,push esi to the stack
ShellCodeGen: push the byte 0x1f onto the stack,push byte 0x1f
ShellCodeSum: exit:,define exit function
ShellCodeGen: if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270 then jump to the while label,"cmp DWORD [edx], 0x636f7270 \n je while"
ShellCodeSum: push 0x61702f63,push the 0x61702f63 onto the stack
ShellCodeSum: push 0x68735858,push the value 0x68735858 onto the stack
ShellCodeGen: if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register,"test eax, eax \n jz write \n xor eax, eax"
"ShellCodeSum: mov [ecx], 25",move 25 decimal into the memory address ecx
ShellCodeGen: jump to the _return label,jmp _return
ShellCodeGen: move the contents of memory address ebx+esi*2+4 into eax,"mov eax, [ebx+esi*2+4]"
ShellCodeGen: move key into eax,"mov eax, key"
ShellCodeGen: swap the contents in ebp+16 and ecx,"xchg [ebp+16], ecx"
ShellCodeGen: move esp into edx,"mov edx, esp"
ShellCodeGen: swap the contents of the ecx register with the contents of the edx register,"xchg ecx, edx"
ShellCodeSum: push 0x1c,push 0x1c to the stack
"ShellCodeSum: xor dl, 0xBB \n jz Next_Cycle",jump to the Next_Cycle label if the result of the logical xor between the dl register and the value 0xBB is zero
ShellCodeGen: move ebx into the address [esp+59],"mov [esp+59], ebx"
ShellCodeGen: reserve 1 word at location bignum,bignum: resw 1
ShellCodeGen: define the _dup2_loop label,_dup2_loop:
ShellCodeSum: call prepare,call the prepare function
"ShellCodeSum: mov ebx, 1",move 1 into ebx
ShellCodeGen: increment the contents of the bl register,inc bl
ShellCodeGen: declare the data section,section .data
ShellCodeGen: make the system call to set set signal delivery alarm clock,"mov eax, 27"
"ShellCodeSum: mov al, 15",move 15 into lower byte of the eax register
ShellCodeGen: move 2 into bl,"mov bl, 2"
ShellCodeSum: bignum: resw 1,reserve 1 word at location bignum
ShellCodeSum: string db 'test.txt',define string as the byte string 'test.txt'
ShellCodeGen: push the contents of the esi register onto the stack and point eax to the stack register,"push esi \n mov eax, esp"
ShellCodeGen: push '/bin' onto the stack,push '/bin'
ShellCodeSum: push byte 0x1f,push the byte 0x1f onto the stack
ShellCodeSum: push 0x204c4c41,push 0x204c4c41 onto the stack
ShellCodeSum: me:,declare the me label
ShellCodeGen: jump to the reading label,jmp reading
ShellCodeGen: move 3 into bl,"mov bl, 3"
ShellCodeGen: decrement the counter and jump to the fill label if the count is not zero,loop fill
"ShellCodeSum: mov ecx, readbuffer",move readbuffer into ecx
"ShellCodeSum: test eax, eax \n jz write \n xor eax, eax","jump to the label write if the contents of the eax register is zero, else zero out the contents of the eax register"
ShellCodeGen: move readbuffer into ecx,"mov ecx, readbuffer"
ShellCodeSum: push 0x0,push 0x0 onto the stack
ShellCodeGen: restore ebx from the value we pushed onto the stack at the start,pop ebx
"ShellCodeSum: mov cl, byte [esi]",move the byte at the address [esi] into cl
ShellCodeGen: move dl into the byte at address [esi + 1],"mov byte [esi + 1], dl"
ShellCodeGen: define the callit label,callit:
ShellCodeSum: push dword 0x6b6e756a,push the dword 0x6b6e756a onto the stack
ShellCodeGen: declare section .data,section .data
"ShellCodeSum: mov esi, 0x91969dd0",move 0x91969dd0 into esi
ShellCodeSum: message: db 'hello world!',declare message to contain the bytes 'hello world!'
"ShellCodeSum: mov ax, [1000h]",load the object at the address 1000h into the ax register
ShellCodeGen: load the effective address of the result of the operation [esi + 12] into the edx register,"lea edx, [esi + 12]"
ShellCodeGen: move al into the byte at address [esi+12],"mov byte [esi+12], al"
ShellCodeSum: jnz top,if not 0 then jump to the top label
"ShellCodeSum: mov ebx, [esp]",move value at top of the stack to ebx
"ShellCodeSum: mov eax, 29",suspend the process until the signal arrives
ShellCodeSum: jmp esp,jump to the esp label
ShellCodeGen: multiply the contents of the eax register by the contents of the ebx register,mul ebx
ShellCodeGen: close the file,"mov eax, 6"
ShellCodeSum: push byte 9 \n pop eax,put the syscall 9 into the eax register
ShellCodeGen: move the return value of sys_socketcall into edi,"mov edi, eax"
ShellCodeSum: closefile:,define the closefile label
ShellCodeGen: push /bin to the stack,push 0x6e69622f
ShellCodeSum: push dword 0x73656c62,push the doubleword 0x73656c62 to the stack
ShellCodeGen: make the system call close,"mov eax, 6"
"ShellCodeSum: mov esi, v_src",move v_src to esi
ShellCodeGen: move 13 into cl,"mov cl, 13"
ShellCodeGen: getpid,"mov eax, 20"
ShellCodeGen: move zero_reg into ebx,"mov ebx, zero_reg"
ShellCodeGen: push the word [edx] onto the stack,push word [edx]
ShellCodeGen: if not 0 then jump to the top label,jnz top
ShellCodeGen: move 0x72702f2f into esi,"mov esi, 0x72702f2f"
"ShellCodeSum: test eax, eax \n jz short loc_402C13",jump short to the memory location loc_402C13 if the contents of the eax register is zero
ShellCodeGen: load the effective address of the result of the operation [ebx+0xf] into the eax register,"lea eax, [ebx+0xf]"
ShellCodeSum: set_mark:,define set_mark label
ShellCodeGen: divide eax by value in edx,div edx
"ShellCodeSum: mov bl, 0xe",move 0xe into bl
"ShellCodeSum: push byte 3 \n mov ebx, esp",push the byte 3 onto the stack and point ebx to the stack register
"ShellCodeSum: sar ebx, 31",right shift the contents of ebx by 31 bits
"ShellCodeSum: mov bl, byte [edi]",move the byte in edi into bl
ShellCodeGen: add 1 to ax,inc ax
"ShellCodeSum: mov ebx, 4",invoke subroutine listen
ShellCodeGen: move 6 into al,"mov al, 6"
ShellCodeGen: jump to _star,jmp _star
ShellCodeGen: preserve ebx on the stack,push ebx
ShellCodeGen: if zero jump to the shift_decode label,jz shift_decode
"ShellCodeSum: mov eax, 6",close the file
ShellCodeGen: move 0xfff into cx,"mov cx, 0xfff"
ShellCodeGen: push the contents of the eax register onto the stack,push eax
"ShellCodeSum: shr ax, 1",right shift ax by 1 bit
ShellCodeSum: _dup2_loop:,define the _dup2_loop label
ShellCodeGen: define the closefile label,closefile:
"ShellCodeSum: rol edi, 1",left rotate the edi register 1 time
"ShellCodeSum: mov cl, 0102",move 0102 into cl
"ShellCodeSum: mov eax, 27",make the system call to set set signal delivery alarm clock
"ShellCodeSum: cmp al, 9 \n jge l1",if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1
"ShellCodeSum: mov eax, 0x8000",move the 32-bit value 0x8000 into register eax
ShellCodeSum: push byte 0x64 \n pop eax,put the syscall 0x64 into the eax register
ShellCodeGen: create variable b in memory and initialize to zero,b: dd 0x0
ShellCodeGen: declare the gotocall label,gotocall:
ShellCodeGen: move the contents of the esp register into the edx register,"mov edx, esp"
"ShellCodeSum: mov bl, byte [eax]",move the byte in eax into bl
"ShellCodeSum: mov [esp+59], ebx",move ebx into the address [esp+59]
ShellCodeSum: db 10,declare an unlabeled byte initialized to 10
ShellCodeSum: loop l2 \n jmp edi,decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register
ShellCodeGen: subtract 13 from ax and save the result into ax,"sub ax, 13"
"ShellCodeSum: mov ax, 010ch",move value of 0x010ch into the register ax
"ShellCodeSum: cmp eax, ebx \n je connect \n ja exit",if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
ShellCodeGen: call the egghunter function,call egghunter
ShellCodeSum: push eax,push eax to the stack
"ShellCodeSum: ror byte [esi], 0x1",right rotate the byte in esi 1 time
ShellCodeGen: multiply eax by edx,mul edx
ShellCodeGen: move the contents of the eax register into the long starting at the address [esi+30],"mov long [esi+30], eax"
"ShellCodeSum: push 0x6374652f \n mov ecx, esp",push the value 0x6374652f onto the stack and point ecx to the stack register
ShellCodeGen: declare the next label,next:
"ShellCodeSum: mov al, 61",move 61 into al
ShellCodeGen: move 0x66 into al,"mov al, 0x66"
ShellCodeGen: move value of 0x010ch into the register ax,"mov ax, 010ch"
ShellCodeGen: push 0x74 onto the stack,push 0x74
ShellCodeGen: put the syscall 0x64 into the eax register,push byte 0x64 \n pop eax
ShellCodeGen: declare the exit_on_error label,exit_on_error:
ShellCodeGen: push 0x6f635f64 onto the stack,push 0x6f635f64
ShellCodeSum: section .data,declare the data section
"ShellCodeSum: xor ebx, ebx",reset both lower and uppper bytes of ebx to be 0
ShellCodeGen: perform a logical xor between the eax register and 0xffffffff and save the result in eax,"xor eax, 0xffffffff"
ShellCodeGen: put the syscall 6 into the eax register,push byte 6 \n pop eax
ShellCodeGen: clear the eax register,"xor eax, eax"
"ShellCodeSum: xchg eax, ebx",swap the contents of the eax register with the contents of the ebx register
"ShellCodeSum: mov eax, 37",system call kill
ShellCodeGen: jump to the _start label if the contents of the al register is equal to the value 0xf2,"cmp al, 0xf2 \n jz _start"
ShellCodeGen: add c to eax,"add eax, c"
ShellCodeGen: move the byte at the address [eax] into bl,"mov bl, byte [eax]"
ShellCodeSum: push 0x68732f2f,push //sh to the stack
"ShellCodeGen: jump to the label write if the contents of the eax register is zero, else zero out the contents of the eax register","test eax, eax \n jz write \n xor eax, eax"
ShellCodeGen: define the closefile function,closefile:
ShellCodeGen: move 0x2 into dl,"mov dl, 0x2"
ShellCodeSum: cld,direction flag equal to zero
ShellCodeSum: push 0x6873732f,push the value 0x6873732f onto the stack
"ShellCodeSum: push 0x6e7a762d \n mov edi, esp",push the value 0x6e7a762d onto the stack and point the edi register to the stack register
ShellCodeGen: system call alarm,"mov eax, 27"
ShellCodeGen: make the system call to get the parent process ID,"mov eax, 64"
ShellCodeSum: call sprint,call the sprint function
"ShellCodeSum: mov ebx, type var3",move the number of bytes of var3 into ebx
ShellCodeGen: jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7,"cmp BYTE [esi], 0x7 \n jl lowbound"
ShellCodeGen: move bl into the byte at address [esi+ecx],"mov byte [esi+ecx], bl"
ShellCodeSum: int 80h,call sys_read
ShellCodeGen: add the contents of the esi register to the contents of eax register,"add eax, esi"
ShellCodeGen: declare the entrypoint label,entrypoint:
ShellCodeGen: if the contents of the al register is equal to the value 0xf2 then jump to the label next_page,"cmp al, 0xf2 \n je next_page"
ShellCodeGen: jump to the label loop,jmp loop
ShellCodeGen: call the two function,call two
"ShellCodeSum: mov cl, 13",move 13 into cl
ShellCodeGen: declare the shell_ret label,shell_ret:
ShellCodeGen: define the byte string '/proc/sys/kernel/randomize_va_spacex',db '/proc/sys/kernel/randomize_va_spacex'
ShellCodeGen: move 05h into al,"mov al, 05h"
ShellCodeGen: push 0x204c4c41 onto the stack,push 0x204c4c41
ShellCodeGen: define constant total_students equal to 50,total_students equ 50
ShellCodeGen: increment the contents of the ebx register,inc ebx
ShellCodeGen: declare the format label,format:
ShellCodeGen: right rotate the byte in esi 1 time,"ror byte [esi], 0x1"
"ShellCodeSum: mov ebx, 0",exit with return code of 0
"ShellCodeSum: test eax, eax \n js old_dirent",jump to the label old_dirent if the contents of the eax register is negative
ShellCodeSum: push 0x74,push 0x74 onto the stack
ShellCodeSum: section .text,section .text
ShellCodeSum: inc dx,increment the contents of the dx register
ShellCodeGen: push the byte 3 onto the stack and point ebx to the stack register,"push byte 3 \n mov ebx, esp"
"ShellCodeSum: lea edx, [esi + 12]",load the effective address of the result of the operation [esi + 12] into the edx register
ShellCodeGen: subtract 0x2e2aa163 from the contents in ebx and save the result in ebx,"sub ebx, 0x2e2aa163"
"ShellCodeSum: mov byte [edi], bl",move bl into the byte in edi
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register,"cmp eax, ebx \n je connect \n ja exit"
ShellCodeSum: push word 0x1b6,push the word 0x1b6 onto the stack
ShellCodeGen: system call open,"mov eax, 5"
ShellCodeGen: reserve one word for ymmval,ymmval: resw 1
ShellCodeSum: push '/bin',push '/bin' onto the stack
ShellCodeGen: push esi to the stack,push esi
ShellCodeGen: put the syscall 9 into the eax register,push byte 9 \n pop eax
"ShellCodeSum: mov eax, esp",move the address of the current stack pointer into eax
ShellCodeSum: push 0x10,push the value 0x10 onto the stack
ShellCodeGen: perform a logical and operation between the al register and the 0fh value and store the result in the al register,"and al, 0fh"
ShellCodeGen: push sys_execve onto the stack,push sys_execve
ShellCodeGen: move v_src to esi,"mov esi, v_src"
"ShellCodeSum: xchg [ebp+16], ecx",swap the contents in ebp+16 and ecx
"ShellCodeGen: define the array of bytes encodedshellcode and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce","encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce"
ShellCodeGen: swap the contents of the eax register with the contents of the ebx register,"xchg eax, ebx"
ShellCodeSum: exit_on_error:,declare the exit_on_error label
ShellCodeGen: push the byte 49 onto the stack,push byte 49
"ShellCodeSum: and al, 0fh",perform a logical and operation between the al register and the 0fh value and store the result in the al register
ShellCodeSum: format:,declare the format label
ShellCodeGen: jump to the label close if the contents of the eax register is negative,"test eax, eax \n js close"
ShellCodeGen: jump to the incpage label if the contents of the al register is equal to the value 0xf2,"cmp al, 0xf2 \n jz incpage"
ShellCodeGen: move esi into the dword at address [esp-4],"mov dword [esp-4], esi"
ShellCodeGen: push the contents of the eax register onto the stack and point edx to the stack register,"push eax \n mov edx, esp"
ShellCodeSum: gotocall:,declare the gotocall label
ShellCodeGen: jump to 0x86 if the carry flag is zero,jnc 0x86
ShellCodeGen: execute execve with system call interrupt,int 0x80
ShellCodeGen: push 0x0a4c4c41 onto the stack,push 0x0a4c4c41
ShellCodeSum: ymmval: resw 1,reserve one word for ymmval
"ShellCodeSum: rol byte [esi], 4",rotate 4 bits left the byte starting at the address esi
ShellCodeGen: jump short to stage,jmp short stage
ShellCodeGen: if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1,"cmp BYTE bl, [esi] \n jne loop_1"
ShellCodeSum: loop 3,decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero
ShellCodeGen: call the _appendfile function,call _appendfile
"ShellCodeSum: mov eax, 6",make the system call close
ShellCodeGen: jump to the esp label,jmp esp
ShellCodeGen: declare message to contain the bytes 'hello world!',message: db 'hello world!'
"ShellCodeSum: mov cl, 0x2",move 0x2 into cl
ShellCodeGen: push the value 0x10 onto the stack,push 0x10
ShellCodeGen: move 0x91969dd0 into esi,"mov esi, 0x91969dd0"
"ShellCodeSum: cmp BYTE al, 2 \n je do_inject \n jmp while",if the byte representation of 2 is equal to the contents of the al register else jump to the while label then jump to the label do_inject
"ShellCodeSum: mov edx, esp",move esp into edx
ShellCodeGen: reset both lower and uppper bytes of ebx to be 0,"xor ebx, ebx"
ShellCodeGen: move /bin/sh into the ecx register,"push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp"
ShellCodeGen: define exit function,exit:
ShellCodeGen: move the byte in edi into bl,"mov bl, byte [edi]"
ShellCodeGen: move the 32-bit value 0x8000 into register eax,"mov eax, 0x8000"
"ShellCodeSum: mov eax, key",move key into eax
"ShellCodeSum: mov eax, 64",make the system call to get the parent process ID
ShellCodeSum: string: db 'tmp.txt',define string as the byte string 'tmp.txt'
ShellCodeSum: push 0x3d4c4c41,push the 0x3d4c4c41 onto the stack
"ShellCodeSum: lea eax, [ebx+0xf]",load the effective address of the result of the operation [ebx+0xf] into the eax register
ShellCodeGen: left rotate the contents of the edx register by 0x4 bits,"rol edx, 0x4"
"ShellCodeSum: mov bl, 3",move 3 into bl
"ShellCodeGen: define the byte string ',ajm,pk#########'","db ',ajm,pk#########'"
ShellCodeSum: db '/proc/sys/kernel/randomize_va_spacex',define the byte string '/proc/sys/kernel/randomize_va_spacex'
ShellCodeGen: move dl into the byte at address [ecx+92],"mov byte [ecx+92], dl"
ShellCodeSum: not byte [var2],negate all bits in the byte at the memory location var2
ShellCodeGen: jump to the label l1 if the contents of the eax register is not zero else call the function myfunct,"test eax, eax \n jnz l1 \n call myfunct"
ShellCodeSum: incpage:,declare incpage function
ShellCodeSum: push eax,push eax value to the stack
"ShellCodeSum: mov ecx, esi",move esi into ecx
"ShellCodeSum: test eax, eax \n jz write \n xor eax, eax",if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register
ShellCodeGen: push 0x4 onto the stack,push 0x4
ShellCodeSum: jmp reading,jump to the reading label
"ShellCodeSum: cmp al, 0xf2 \n je next_page",if the contents of the al register is equal to the value 0xf2 then jump to the label next_page
ShellCodeGen: add 0xa to the al register,"add al, 0xa"
ShellCodeGen: make the system call getppid,"mov eax, 64"
"ShellCodeSum: test eax, eax \n jnz checkforfile",jump to the label checkforfile if the contents of the eax register is not zero
ShellCodeSum: push 0x6d722f2f,push the 0x6d722f2f onto the stack
"ShellCodeSum: mov edx, esp",move the contents of the esp register into the edx register
ShellCodeGen: jump to decoded if zero,jz decoded_shellcode
"ShellCodeSum: test eax, eax \n jnz l4 \n call search",jump to the label l4 if the contents of the eax register is not zero else call the function search
"ShellCodeSum: shl ecx, 2",multiply ecx by 4 using left shift
ShellCodeGen: call sys_read,int 80h
"ShellCodeSum: push 0x64687373 \n mov eax, esp",push the value 0x64687373 onto the stack and point the eax register to the stack register
ShellCodeSum: inc dword [value],add one to the doubleword integer stored at memory location value
"ShellCodeSum: mov cl, 9",move 9 into cl
ShellCodeGen: push the 0x6d722f2f onto the stack,push 0x6d722f2f
ShellCodeGen: move the 4th element of the word_table into cx,"mov cx, word_table + 3"
ShellCodeGen: move the address of the current stack pointer into eax,"mov eax, esp"
ShellCodeSum: push 0x64687373,push 0x64687373 onto the stack
ShellCodeGen: declare _shell as global label,global _shell
"ShellCodeSum: lea eax, [zero_reg+6]",load the effective address of the result of the operation [zero_reg+6] into the eax register
ShellCodeGen: if the byte representation of 2 is equal to the contents of the al register else jump to the while label then jump to the label do_inject,"cmp BYTE al, 2 \n je do_inject \n jmp while"
ShellCodeSum: push 0x0a206873,push 0x0a206873 onto the stack
ShellCodeGen: add one to the doubleword integer stored at memory location value,inc dword [value]
ShellCodeGen: push eax onto the stack,push eax
ShellCodeGen: declare the shell label,shell:
ShellCodeSum: jz shift_decode,if zero jump to the shift_decode label
ShellCodeGen: exit with return code of 0,"mov ebx, 0"
ShellCodeGen: move 0x9a8dd091 into eax,"mov eax, 0x9a8dd091"
ShellCodeSum: total_students equ 50,define constant total_students equal to 50
ShellCodeGen: invoke subroutine listen,"mov ebx, 4"
ShellCodeGen: left rotate the edi register 1 time,"rol edi, 1"
"ShellCodeSum: mov cx, word_table + 3",move the 4th element of the word_table into cx
"ShellCodeSum: msg db 'hello, world!', 0xa",declare msg string containing 'hello world!'
ShellCodeSum: call two,call the two function
ShellCodeGen: move 25 decimal into the memory address ecx,"mov [ecx], 25"
ShellCodeGen: subtract 0x6374612e from the contents in ecx and save the result in ecx,"sub ecx, 0x6374612e"
"ShellCodeSum: test eax, eax \n jz ready_to_proxy",jump to the label ready_to_proxy if the contents of the eax register is zero
"ShellCodeSum: mov ebx, zero_reg",move zero_reg into ebx
"ShellCodeSum: mov al, 0xb",mov 0xb into lower byte of eax
ShellCodeGen: increment the contents of the dx register,inc dx
"ShellCodeSum: mov eax, 4",make the system call to write to the file
ShellCodeGen: push the value 0x6374652f onto the stack and point ecx to the stack register,"push 0x6374652f \n mov ecx, esp"
ShellCodeGen: if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0xff else add the 0x5 value to the dl register,"cmp cl, 0x11 \n jb 0xff \n add dl, 0x5"
ShellCodeGen: push ASCII /bin/sh onto the stack and point the edx register to the stack register,"push 0x68732f2f \n push 0x6e69622f \n mov edx, esp"
ShellCodeGen: define len equal to the length of msg,len equ $ - msg
ShellCodeGen: load the effective address of the result of the operation [zero_reg+6] into the eax register,"lea eax, [zero_reg+6]"
ShellCodeSum: next:,declare the next label
ShellCodeGen: move len into cl,"mov cl, len"
"ShellCodeSum: mov byte [esi + 1], dl",move dl into the byte at address [esi + 1]
ShellCodeSum: push byte 16,push byte 16 onto stack
ShellCodeGen: pop the last element pushed onto the stack into cx,pop cx
