move 0x222933f0 into esi
push 0x204c4c41 onto the stack
move the contents of the ebp register ino the esp register
move readbuffer into ecx
declare the data section
"define a tables of bytes byte_table and initialize to 14, 15 and 22"
declare the format label
declare odd_numer function
move 0xcd into al
push the contents of the bx register onto the stack
divide eax by esi
subtract 0x6374612e from the contents in ecx and save the result in ecx
push the 0x61702f63 onto the stack
section .text
decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero
define string as the byte string 'tmp.txt'
move dl into the byte at address [ecx+92]
push 0x4 onto the stack
call sys_read
swap the contents of the ecx register with the contents of the edx register
move 6 into al
initialize ax to 00
define set_mark label
subtract 13 from ax and save the result into ax
if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0xff else add the 0x5 value to the dl register
move 25 decimal into the memory address ecx
if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1
declare an unlabeled byte initialized to 10
call the esp function
zero out ah register
perform a logical xor between the cl register and 0xaa and save the result in cl
if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label
"jump to the label write if the contents of the eax register is zero, else zero out the contents of the eax register"
compare the contents of the al register and 0xf2
rotate 4 bits left the byte starting at the address esi
move the contents of the eax register into the long starting at the address [esi+30]
move al into edi
push the 0x74756873 onto the stack
code for exit syscall
jump to the esp label
jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
put syscall sigaction into the eax register
declare the shellcode label
move 102 into al
invoke sys_write
system call open
if the contents of the al register is equal to the value 0xf2 then jump to the label next_page
"define the array of bytes encodedshellcode and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce"
move 0x72702f2f into esi
jump to decoded if zero
execute execve with system call interrupt
call the _appendfile function
jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xd
move the byte at the address [esi] into cl
push the contents of the eax register onto the stack and point edx to the stack register
jump to the next_cycle label if the result of the logical xor between the dl register and the value 0xbb is zero
restore ebx from the value we pushed onto the stack at the start
call the sprint function
load the effective address of the result of the operation [zero_reg+3] into the eax register
move 9 into cl
if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1
move 05h into al
define the doubleword arr and initialize it to 20
define variable choice of 1 byte and initialize to y
jump to the connect label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
decrement ecx by 1
move 0102 into cl
move 3 decimal into edx
create variable b in memory and initialize to zero
move 61 into al
preserve ebx on the stack
move the contents of the esp register into the edx register
push the byte 0x1f onto the stack
move the contents of the esi register into the bx register
push the dword 0x6b6e756a onto the stack
subtract 15444 from dx and save the result into dx
move key into eax
load the effective address of the result of the operation [ebx+0xf] into the eax register
if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270 then jump to the while label
add the contents of the esi register to the contents of eax register
move cl into bl
define the _dup2_loop label
declare _shell as global label
add 0xa to the al register
move the word at the address ax into [ebp+22]
reset both lower and uppper bytes of ebx to be 0
move ecx into edx
divide ecx by 2 using right shift
make the system call to set set signal delivery alarm clock
if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
right shift the contents of the edx register by the byte 24
push ascii /bin/sh onto the stack and point the edx register to the stack register
push 0xefffff7f onto the stack
push the 0x3d4c4c41 onto the stack
multiply the contents of the eax register by the contents of the ebx register
push 0x0a4c4c41 onto the stack
divide eax by value in edx
push the contents of the eax register onto the stack
push the value 0x10 onto the stack
move v_src to esi
declare the gotocall label
move the address of buzz string into eax
push the value 0x6e7a762d onto the stack and point the edi register to the stack register
system call sigaction
move the 4th element of the word_table into cx
add 32 to edx
define the byte string '/proc/sys/kernel/randomize_va_spacex'
point ebp to top of stack
jump to the label checkforfile if the contents of the eax register is not zero
move the contents of memory address ebx+esi*2+4 into eax
perform the xor operation between the byte at memory location esi+ecx and 0x0f
jump to the label ready_to_proxy if the contents of the eax register is zero
move 0x2 into dl
push the byte 10 to the stack
move esi into the dword at address [esp-4]
system call write
push the contents of the esi register onto the stack and point eax to the stack register
push sys_execve onto the stack
move /bin/sh into the ecx register
define the closefile label
compare the contents of eax with ebx
push 0x64687373 onto the stack
put the byte my_label into the eax register
call the two function
section bss
put the syscall 0xc into the eax register
move 1 into ebx
declare the exit_on_error label
declare the prepare label
move 0xfff into cx
push the byte 49 onto the stack
declare the shell_ret label
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
call writestring
move dl into the byte at address [esi + 1]
push the 0x6d722f2f onto the stack
make the system call getppid
make the system call close
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register
if not 0 then jump to the top label
push the contents of the esp register onto the stack
push /bin to the stack
push the byte +0x8 onto the stack
pop the next argument off the stack into eax
allocate memory for a 12*10 quad-bytes matrix
move eatlen into edx
jump short to stage
push 0x622f7273 to the stack
move 0x9a8dd091 into eax
jump to the _return label
push 0x0a206873 onto the stack
declare the next label
push 0x1c to the stack
reserve 1 word at location bignum
move 0x06 into al
define len equal to the length of msg
push 0x2f3a746f onto the stack
reserve one word for ymmval
swap the contents of the eax register with the contents of the ebx register
mov 0xb into lower byte of eax
define exit function
define dim to be 512 bytes large
invoke subroutine listen
jump short to the end label
left rotate the edi register 1 time
declare msg string containing 'hello world!'
add c to eax
move the byte in eax into bl
decrement the counter and jump to the fill label if the count is not zero
jump to dup2 if not negative
system call alarm
put the syscall 6 into the eax register
move bl into the byte in edi
move zero_reg into ebx
jump short to the search label
move 0x66 into al
jump to the label l4 if the contents of the eax register is not zero else call the function search
move the byte in esi into bl
declare the set_mark label
jump short to the gotocall label
push 0x3a303a3a onto the stack
jump to 0x86 if the carry flag is zero
push the byte 3 onto the stack and point ebx to the stack register
jump to the label l1 if the contents of the eax register is not zero else call the function myfunct
push the double word 0x2335738c onto the stack
move bl into the byte at address [esi+ecx]
push the value 0x6374652f onto the stack and point ecx to the stack register
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register
move the byte in edi into bl
mask out lowest 4 bits of the eax register
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
right shift the contents of dl register by 1 bit positions
move value of 0x010ch into the register ax
move 3 into bl
negate all the bits of the eax register
push byte 16 onto stack
load the effective address of the result of the operation [esi + 12] into the edx register
multiply eax by edx
left rotate the contents of the edx register by 0x4 bits
load the object at the address 1000h into the ax register
system call getppid
close the file
define constant total_students equal to 50
jump to _star
jump to the _start label if the contents of the al register is equal to the value 0xf2
push //sh to the stack
push 0x6f635f64 onto the stack
move the return value of sys_socketcall into edi
move filename into ebx
right rotate the byte in esi 1 time
move 15 into lower byte of the eax register
load the effective address of the result of the operation [zero_reg+117] into the ecx register
push the dword 0x7264632f onto the stack
define dup2 function
increment the contents of the ebx register
perform the xor operation between the value stored at the location ecx and dh
jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
move the number of bytes of var3 into ebx
push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register
jump to the label old_dirent if the contents of the eax register is negative
push the value 0x6873732f onto the stack
if zero jump to the shift_decode label
move the address of the current stack pointer into eax
"define the byte string ',ajm,pk#########'"
increment address if no match
add one to the doubleword integer stored at memory location value
jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7
push eax to the stack
jump to the label close if the contents of the eax register is negative
push the word 0x5c11 onto the stack
declare incpage function
exit with return code of 0
push eax value to the stack
move the byte at the address [eax] into bl
subtract 0x2e2aa163 from the contents in ebx and save the result in ebx
increment the contents of the bl register
add an immediate operand 65 to byte_value
move the 32-bit value 0x8000 into register eax
move 13 into cl
make the system call to write to the file
move esi into ecx
jump to the label loop
declare the entrypoint label
jump to the incpage label if the contents of the al register is equal to the value 0xf2
define the callit label
preserve esi on the stack
define string as the byte string 'test.txt'
call the prepare function
negate all bits in the byte at the memory location var2
push the value 0x64687373 onto the stack and point the eax register to the stack register
move 0x91969dd0 into esi
system call kill
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
declare the start label
define the closefile function
kill
push 0x74 onto the stack
define msg as the byte string 'we found the egg!'
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
move al into the byte at address [esi+12]
move esp into edx
move value at top of the stack to ebx
swap the contents in ebp+16 and ecx
jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack
declare message to contain the bytes 'hello world!'
push the value 0x68735858 onto the stack
clear the esi register
move 0x2 into cl
push the doubleword 0x73656c62 to the stack
move 0xe into bl
perform a logical and operation between the al register and the 0fh value and store the result in the al register
jump short to the memory location loc_402c13 if the contents of the eax register is zero
if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register
direction flag equal to zero
right shift ax by 1 bit
declare the shell label
declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively
push esi to the stack
push the word 0x697a onto the stack
make the system call to get the parent process id
push '/bin' onto the stack
right shift the contents of ebx by 31 bits
jump short to the _file label
load the effective address of the result of the operation [zero_reg+6] into the eax register
push 0x0 onto the stack
add 1 to ax
define egg equal to 'egg '
declare section .data
increment the contents of the dx register
jump to the reading label
move len into cl
move 0x7f into dl
move 2 into bl
multiply ecx by 4 using left shift
decrement the counter and jump to the l1 label if the count is not zero and the zero flag is equal to zero
getpid
restore the top of the stack into edx register
put the syscall 9 into the eax register
clear the ah register
if the byte representation of 2 is equal to the contents of the al register else jump to the while label then jump to the label do_inject
push the word 0x1b6 onto the stack
define an array of 5 initialized word
suspend the process until the signal arrives
call the egghunter function
declare the me label
pop the last element pushed onto the stack into cx
perform a logical xor between the eax register and 0xffffffff and save the result in eax
push the word [edx] onto the stack
push eax onto the stack
move the byte 0ffh into dl
push the contents of the edi register onto the stack and point ebx to the stack register
negate all bits in the byte at the memory location tmp
clear the eax register
move ebx into the address [esp+59]
decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero
preserve ecx on the stack
put the syscall 0x64 into the eax register
add the contents of edi to the contents of edi
move the contents of the ebx register into the long starting at the address [esi+26]
subtract 15444 from the contents of the dx register
